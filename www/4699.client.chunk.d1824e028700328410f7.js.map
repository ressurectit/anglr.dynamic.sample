{"version":3,"file":"4699.client.chunk.d1824e028700328410f7.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../forms/src/modules/formPipes/pipes/asFormControl/asFormControl.pipe.ts","webpack://ng-universal-demo/../../../form/src/components/formComponentBase/formComponentBase.ts","webpack://ng-universal-demo/../../../form/src/misc/tokens.ts","webpack://ng-universal-demo/../../../layout-editor/src/decorators/layoutEditorMetadata/layoutEditorMetadata.decorator.ts","webpack://ng-universal-demo/../../../layout/src/components/layoutComponentBase/layoutComponentBase.ts","webpack://ng-universal-demo/../../../layout/src/extensions/componentStyling/componentStyling.extension.ts","webpack://ng-universal-demo/../../../src/material/radio/module.ts","webpack://ng-universal-demo/../../../material-components/src/dynamicItems/radio/radio.metadata.ts","webpack://ng-universal-demo/../../../src/material/radio/radio.ts","webpack://ng-universal-demo/../src/material/radio/radio.html","webpack://ng-universal-demo/../../../src/material/radio/radio.html","webpack://ng-universal-demo/../../../material-components/src/dynamicItems/radio/radio.component.ts","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/material-components/src/dynamicItems/radio/radio.component.html","webpack://ng-universal-demo/../../../material-components/src/dynamicItems/radio/type.ts","webpack://ng-universal-demo/../../../relations/src/decorators/dynamicOutput/dynamicOutput.decorator.ts","webpack://ng-universal-demo/../../../relations/src/extensions/relationsRegistration/relationsRegistration.extension.ts","webpack://ng-universal-demo/../../../src/misc/dynamicItemExtensionBase.ts","webpack://ng-universal-demo/../../../src/cdk/collections/unique-selection-dispatcher.ts"],"sourcesContent":["import {Inject, Optional, Pipe} from '@angular/core';\nimport {AbstractControl, FormControl} from '@angular/forms';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {isBlank} from '@jscrpt/common';\n\n/**\n * Tries to convert `AbstractControl` to `FormControl`\n */\n@Pipe({name: 'asFormControl'})\nexport class AsFormControlPipe\n{\n    //######################### constructors #########################\n    constructor(@Optional() @Inject(LOGGER) private _logger?: Logger)\n    {\n    }\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Allows casting of `AbstractControl` to `FormControl`\n     * @param value - `AbstractControl` to be cast to `FormControl`\n     * @param _valueHash - Parameter that can be used to change value, indicates that pipe input value has changed\n     */\n    public transform<TModel>(value: AbstractControl<TModel>|null|undefined, _valueHash?: any): FormControl<TModel>|null\n    {\n        if(isBlank(value))\n        {\n            return null;\n        }\n\n        if(value instanceof FormControl)\n        {\n            return value as FormControl<TModel>;\n        }\n\n        this._logger?.warn('Failed to cast AbstractControl to FormControl');\n\n        return null;\n    }\n}","import {ChangeDetectorRef, Directive, ElementRef, Inject, Injector, Input, Optional} from '@angular/core';\nimport {AbstractControl, FormControl, Validators} from '@angular/forms';\nimport {LayoutComponentBase} from '@anglr/dynamic/layout';\nimport {LOGGER, Logger} from '@anglr/common';\nimport {DynamicOutput} from '@anglr/dynamic/relations';\nimport {PromiseOr} from '@jscrpt/common';\nimport {Subscription} from 'rxjs';\n\nimport {FORM_COMPONENT_CONTROL} from '../../misc/tokens';\nimport {FormComponentOptions} from '../../misc/formComponentBase.options';\nimport {FormComponentControlType} from '../../misc/enums';\nimport {getControlForType, getFormControl} from '../../misc/utils';\n\n/**\n * Base component for form component\n */\n@Directive()\nexport abstract class FormComponentBase<TOptions extends FormComponentOptions, TValue = string> extends LayoutComponentBase<TOptions>\n{\n    //######################### private properties #########################\n\n    /**\n     * Indication whether form component is required\n     */\n    private _required: boolean|null|undefined;\n\n    /**\n     * Indication whether form component is disabled\n     */\n    private _disabled: boolean|null|undefined;\n\n    //######################### protected properties #########################\n\n    /**\n     * Form component control\n     */\n    protected control: AbstractControl = new FormControl();\n\n    /**\n     * Form component control subscriptions\n     */\n    protected controlSubscription: Subscription|null|undefined;\n\n    //######################### public properties - inputs #########################\n\n    /**\n     * Form component value\n     */\n    @Input()\n    public set value(value: TValue|null|undefined)\n    {\n        const oldValue = this.value;\n        this.valueOutput = value;\n\n        if (value !== oldValue)\n        {\n            this.control?.patchValue(value);\n        }\n    }\n    public get value(): TValue|null|undefined\n    {\n        return this.valueOutput;\n    }\n\n    /**\n     * Indication whether form component is required\n     */\n    @Input()\n    public set required(value: boolean|null|undefined)\n    {\n        this._required = value;\n\n        if (value === true)\n        {\n            this.control?.addValidators(Validators.required);\n            return;\n        }\n\n        this.control?.removeValidators(Validators.required);\n    }\n    public get required(): boolean|null|undefined\n    {\n        return this._required;\n    }\n\n    /**\n     * Indication whether form component is disabled\n     */\n    @Input()\n    public set disabled(value: boolean|null|undefined)\n    {\n        this._disabled = value;\n\n        if (value === true)\n        {\n            this.control?.disable();\n            return;\n        }\n\n        this.control?.enable();\n    }\n    public get disabled(): boolean|null|undefined\n    {\n        return this._disabled;\n    }\n\n    //######################### public properties - dynamicOutputs #########################\n\n    /**\n     * Form component value\n     */\n    @DynamicOutput()\n    public valueOutput: TValue|null|undefined;\n\n    //######################### constructor #########################\n\n    constructor(_changeDetector: ChangeDetectorRef,\n                _element: ElementRef<HTMLElement>,\n                _injector: Injector,\n                @Inject(FORM_COMPONENT_CONTROL) @Optional() protected _parentControl?: AbstractControl,\n                @Inject(LOGGER) @Optional() _logger?: Logger,)\n    {\n        super(_changeDetector, _element, _injector, _logger);\n    }\n\n    //######################### protected methods - _onOptionsSet implementation #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override onOptionsSet(): PromiseOr<void> \n    {\n        if(!this.options)\n        {\n            return;\n        }\n\n        this.controlSubscription?.unsubscribe();\n        this.controlSubscription = null;\n\n        this.control = this._getFormControl(this.options?.controlName, this._parentControl, FormComponentControlType.FormControl, this.value); \n        this._registerValidations();\n\n        this.controlSubscription = this.control\n            ?.valueChanges\n            ?.subscribe(value => \n            {\n                this.valueOutput = value;\n            });\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Registers component-specific validators\n     */\n    protected _registerValidations(): void\n    {}\n\n    //######################### private methods #########################\n\n    /**\n     * Gets form component control for control name\n     * @param controlName Form component control name\n     * @param parentControl Parent form control\n     * @param defaultControlType Default control type when parent does not exists or not contains control with specified name\n     * @param initValue Initial value for control\n     * @returns Specified type of control\n     */\n    private _getFormControl(controlName: string|null|undefined, parentControl: AbstractControl|undefined, defaultControlType: FormComponentControlType = FormComponentControlType.FormControl, initValue: TValue|null|undefined): AbstractControl\n    {\n        let control = getFormControl(controlName, parentControl, defaultControlType, initValue);\n\n        if (!control)\n        {\n            this.logger?.warn('FormComponentBase: Unable to find control with name {@name}', {name: controlName});\n\n            control = getControlForType(defaultControlType, initValue);\n        }\n\n        if (this.required)\n        {\n            control.addValidators(Validators.required);\n        }\n\n        if (this.disabled)\n        {\n            control.disable();\n        }\n\n        return control;\n    }\n}","import {InjectionToken} from '@angular/core';\nimport {AbstractControl} from '@angular/forms';\n\n/**\n * Injection token for form component control\n */\nexport const FORM_COMPONENT_CONTROL : InjectionToken<AbstractControl> = new InjectionToken<AbstractControl>('FORM_COMPONENT_CONTROL');","import {DynamicClassMetadata, DynamicMetadataLoader} from '@anglr/dynamic';\n\nimport {LayoutEditorMetadataDescriptor, LayoutEditorMetadataType} from '../../decorators';\n\n/**\n * Sets layout editor metadata to class on which is this decorator applied\n * @param metadataLoader - Layout editor metadata loader function used for obtaining metadata\n */\nexport function LayoutEditorMetadata(metadataLoader: DynamicMetadataLoader<LayoutEditorMetadataDescriptor>): ClassDecorator\n{\n    return DynamicClassMetadata<LayoutEditorMetadataDescriptor, LayoutEditorMetadataType>(metadataLoader, 'layoutEditorMetadata');\n}","import {ChangeDetectorRef, Directive, ElementRef, Inject, Injector, OnDestroy, Optional, SimpleChanges} from '@angular/core';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {DynamicItemExtension} from '@anglr/dynamic';\nimport {isEmptyObject, nameof, PromiseOr} from '@jscrpt/common';\n\nimport {LayoutComponent} from '../../interfaces';\n\n/**\n * Base component for layout component\n */\n@Directive()\nexport abstract class LayoutComponentBase<TOptions> implements LayoutComponent<TOptions>, OnDestroy\n{\n    //######################### protected fields #########################\n\n    /**\n     * Array of extensions that are registered for component\n     */\n    protected extensions: DynamicItemExtension<TOptions>[] = [];\n\n    /**\n     * Indication whether initialization was already done\n     */\n    protected initialized: boolean = false;\n\n    /**\n     * Indication whether was component destroyed\n     */\n    protected destroyed: boolean = false;\n\n    //######################### protected properties #########################\n\n    /**\n     * Gets element that is used within extension\n     */\n    protected get element(): ElementRef<HTMLElement>\n    {\n        return this.componentElement;\n    }\n\n    /**\n     * Gets options that are used within extension\n     */\n    protected get extensionsOptions(): any|undefined|null\n    {\n        return this.options;\n    }\n\n    //######################### public properties - implementation of LayoutComponent #########################\n\n    /**\n     * @inheritdoc\n     */\n    public options: TOptions|undefined|null;\n\n    //######################### constructor #########################\n    constructor(protected changeDetector: ChangeDetectorRef,\n                protected componentElement: ElementRef<HTMLElement>,\n                protected injector: Injector,\n                @Inject(LOGGER) @Optional() protected logger?: Logger,)\n    {\n    }\n\n    //######################### public methods - implementation of OnDestroy #########################\n    \n    /**\n     * Called when component is destroyed\n     */\n    public ngOnDestroy(): void\n    {\n        if(this.destroyed)\n        {\n            return;\n        }\n\n        this.destroyed = true;\n\n        for(const ext of this.extensions)\n        {\n            ext.destroy();\n        }\n\n        this.onDestroy();\n    }\n\n    //######################### public methods - implementation of LayoutComponent #########################\n\n    /**\n     * @inheritdoc\n     */\n    public async ngOnInit(): Promise<void>\n    {\n        if(this.initialized)\n        {\n            return;\n        }\n\n        this.initialized = true;\n        const extensionsOptions = this.extensionsOptions;\n        \n        await this.onInit();\n        await this.onOptionsSet();\n\n        if(extensionsOptions)\n        {\n            for(const extension of this.extensions)\n            {\n                await extension.initialize(this.injector, this.element, this);\n            }\n        }\n\n        await this.afterInit();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public async ngOnChanges(changes: SimpleChanges): Promise<void>\n    {\n        //options has changed\n        if(nameof<LayoutComponentBase<TOptions>>('options') in changes)\n        {\n            await this.onOptionsSet();\n\n            const extensionsOptions = this.extensionsOptions;\n\n            //set options in extensions\n            if(extensionsOptions)\n            {\n                for(const extension of this.extensions)\n                {\n                    await extension.optionsChange(extensionsOptions);\n                }\n            }\n\n            if(!this.initialized)\n            {\n                return;\n            }\n\n            await this.onOptionsChange();\n        }\n\n        delete changes[nameof<LayoutComponentBase<TOptions>>('options')];\n\n        if(!isEmptyObject(changes))\n        {\n            this.onChanges(changes);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public registerExtensions(extensions: DynamicItemExtension[]): void\n    {\n        this.extensions = extensions;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public invalidateVisuals(): void\n    {\n        this.changeDetector.detectChanges();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Called on initialzation of component, options are already set\n     */\n    protected onInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called right after initialization finished, including extesions\n     */\n    protected afterInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on change of options, after initialization\n     */\n    protected onOptionsChange(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Occurs when some property changes on component\n     * @param _changes - Changes that occured on component\n     */\n    protected onChanges(_changes: SimpleChanges): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called everytime options are set, after initialization and later\n     */\n    protected onOptionsSet(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called when component is being destroyed\n     */\n    protected onDestroy(): void\n    {\n    }\n}","import {DynamicItemExtension, DynamicItemExtensionBase} from '@anglr/dynamic';\nimport {isPresent} from '@jscrpt/common';\n\nimport {ComponentStylingOptions} from '../../interfaces';\n\n/**\n * Extension that applies common component styling to component\n */\nexport class ComponentStylingExtension extends DynamicItemExtensionBase<ComponentStylingOptions> implements DynamicItemExtension<ComponentStylingOptions>\n{\n    //######################### protected properties #########################\n\n    /**\n     * Value of last css class\n     */\n    protected lastCssClass: string|undefined|null;\n\n    //######################### public methods - overrides #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override onInit(): void\n    {\n        this._applyStyling();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected override onOptionsChange(): void\n    {\n        this._applyStyling();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Applies component styling to element\n     */\n    protected _applyStyling(): void\n    {\n        const options = this.options;\n        const style = this.element?.nativeElement.style;\n\n        if(this.element)\n        {\n            if(isPresent(this.lastCssClass))\n            {\n                for(const cssClass of this.lastCssClass.split(' '))\n                {\n                    if(cssClass)\n                    {\n                        this.element.nativeElement.classList.remove(cssClass);\n                    }\n                }\n            }\n\n            this.lastCssClass = options?.cssClass;\n\n            if(options?.cssClass)\n            {\n                for(const cssClass of options.cssClass.split(' '))\n                {\n                    if(cssClass)\n                    {\n                        this.element?.nativeElement.classList.add(cssClass);\n                    }\n                }\n            }\n        }\n\n        if(isPresent(style))\n        {\n            if(options?.margin)\n            {\n                if(isPresent(options.margin.bottom))\n                {\n                    style.marginBottom = options.margin.bottom;\n                }\n\n                if(isPresent(options.margin.right))\n                {\n                    style.marginRight = options.margin.right;\n                }\n\n                if(isPresent(options.margin.top))\n                {\n                    style.marginTop = options.margin.top;\n                }\n\n                if(isPresent(options.margin.left))\n                {\n                    style.marginLeft = options.margin.left;\n                }\n            }\n\n            if(options?.padding)\n            {\n                if(isPresent(options.padding.bottom))\n                {\n                    style.paddingBottom = options.padding.bottom;\n                }\n\n                if(isPresent(options.padding.right))\n                {\n                    style.paddingRight = options.padding.right;\n                }\n\n                if(isPresent(options.padding.top))\n                {\n                    style.paddingTop = options.padding.top;\n                }\n\n                if(isPresent(options.padding.left))\n                {\n                    style.paddingLeft = options.padding.left;\n                }\n            }\n\n            if(options?.textStyling)\n            {\n                if(isPresent(options.textStyling.fontSize))\n                {\n                    style.fontSize = options.textStyling.fontSize;\n                }\n\n                if(isPresent(options.textStyling.fontWeight))\n                {\n                    style.fontWeight = options.textStyling.fontWeight.toString();\n                }\n            }\n        }\n    }\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {MatRadioButton, MatRadioGroup} from './radio';\n\n@NgModule({\n  imports: [MatCommonModule, CommonModule, MatRippleModule],\n  exports: [MatCommonModule, MatRadioGroup, MatRadioButton],\n  declarations: [MatRadioGroup, MatRadioButton],\n})\nexport class MatRadioModule {}\n","import {DynamicMetadataLoader} from '@anglr/dynamic';\nimport {LayoutEditorMetadataDescriptor} from '@anglr/dynamic/layout-editor';\nimport {RelationsEditorMetadataDescriptor} from '@anglr/dynamic/relations-editor';\n\nimport {MaterialRadioComponentOptions} from './radio.options';\n\n/**\n * Material radio layout metadata loader\n */\nexport const MaterialRadioLayoutMetadataLoader: DynamicMetadataLoader<LayoutEditorMetadataDescriptor<MaterialRadioComponentOptions>> = async () => new (await import('./metadata/radio.layoutMetadata')).MaterialRadioLayoutEditorMetadata();\n\n/**\n * Material radio relations metadata loader\n */\nexport const MaterialRadioRelationsMetadataLoader: DynamicMetadataLoader<RelationsEditorMetadataDescriptor> = async () => new (await import('./metadata/radio.relationsMetadata')).MaterialRadioRelationsEditorMetadata();","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  CanDisableRipple,\n  HasTabIndex,\n  mixinDisableRipple,\n  mixinTabIndex,\n  ThemePalette,\n} from '@angular/material/core';\nimport {FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {BooleanInput, coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {UniqueSelectionDispatcher} from '@angular/cdk/collections';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\n\n// Increasing integer for generating unique ids for radio components.\nlet nextUniqueId = 0;\n\n/** Change event object emitted by radio button and radio group. */\nexport class MatRadioChange {\n  constructor(\n    /** The radio button that emits the change event. */\n    public source: _MatRadioButtonBase,\n    /** The value of the radio button. */\n    public value: any,\n  ) {}\n}\n\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * @docs-private\n */\nexport const MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatRadioGroup),\n  multi: true,\n};\n\n/**\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_RADIO_GROUP = new InjectionToken<_MatRadioGroupBase<_MatRadioButtonBase>>(\n  'MatRadioGroup',\n);\n\nexport interface MatRadioDefaultOptions {\n  color: ThemePalette;\n}\n\nexport const MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken<MatRadioDefaultOptions>(\n  'mat-radio-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\nexport function MAT_RADIO_DEFAULT_OPTIONS_FACTORY(): MatRadioDefaultOptions {\n  return {\n    color: 'accent',\n  };\n}\n\n/**\n * Base class with all of the `MatRadioGroup` functionality.\n * @docs-private\n */\n@Directive()\nexport abstract class _MatRadioGroupBase<T extends _MatRadioButtonBase>\n  implements AfterContentInit, ControlValueAccessor\n{\n  /** Selected value for the radio group. */\n  private _value: any = null;\n\n  /** The HTML name attribute applied to radio buttons in this group. */\n  private _name: string = `mat-radio-group-${nextUniqueId++}`;\n\n  /** The currently selected radio button. Should match value. */\n  private _selected: T | null = null;\n\n  /** Whether the `value` has been set to its initial value. */\n  private _isInitialized: boolean = false;\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  private _labelPosition: 'before' | 'after' = 'after';\n\n  /** Whether the radio group is disabled. */\n  private _disabled: boolean = false;\n\n  /** Whether the radio group is required. */\n  private _required: boolean = false;\n\n  /** The method to be called in order to update ngModel */\n  _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  /**\n   * onTouch function registered via registerOnTouch (ControlValueAccessor).\n   * @docs-private\n   */\n  onTouched: () => any = () => {};\n\n  /**\n   * Event emitted when the group value changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * a radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** Child radio buttons. */\n  abstract _radios: QueryList<T>;\n\n  /** Theme color for all of the radio buttons in the group. */\n  @Input() color: ThemePalette;\n\n  /** Name of the radio button group. All radio buttons inside this group will use this name. */\n  @Input()\n  get name(): string {\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    this._updateRadioButtonNames();\n  }\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition;\n  }\n  set labelPosition(v) {\n    this._labelPosition = v === 'before' ? 'before' : 'after';\n    this._markRadiosForCheck();\n  }\n\n  /**\n   * Value for the radio-group. Should equal the value of the selected radio button if there is\n   * a corresponding radio button with a matching value. If there is not such a corresponding\n   * radio button, this value persists to be applied in case a new radio button is added with a\n   * matching value.\n   */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    if (this._value !== newValue) {\n      // Set this before proceeding to ensure no circular loop occurs with selection.\n      this._value = newValue;\n\n      this._updateSelectedRadioFromValue();\n      this._checkSelectedRadioButton();\n    }\n  }\n\n  _checkSelectedRadioButton() {\n    if (this._selected && !this._selected.checked) {\n      this._selected.checked = true;\n    }\n  }\n\n  /**\n   * The currently selected radio button. If set to a new radio button, the radio group value\n   * will be updated to match the new selected button.\n   */\n  @Input()\n  get selected() {\n    return this._selected;\n  }\n  set selected(selected: T | null) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n    this._checkSelectedRadioButton();\n  }\n\n  /** Whether the radio group is disabled */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  /** Whether the radio group is required */\n  @Input()\n  get required(): boolean {\n    return this._required;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  constructor(private _changeDetector: ChangeDetectorRef) {}\n\n  /**\n   * Initialize properties once content children are available.\n   * This allows us to propagate relevant attributes to associated buttons.\n   */\n  ngAfterContentInit() {\n    // Mark this component as initialized in AfterContentInit because the initial value can\n    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n    // NgModel occurs *after* the OnInit of the MatRadioGroup.\n    this._isInitialized = true;\n  }\n\n  /**\n   * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n   * radio buttons upon their blur.\n   */\n  _touch() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n\n  private _updateRadioButtonNames(): void {\n    if (this._radios) {\n      this._radios.forEach(radio => {\n        radio.name = this.name;\n        radio._markForCheck();\n      });\n    }\n  }\n\n  /** Updates the `selected` radio button from the internal _value state. */\n  private _updateSelectedRadioFromValue(): void {\n    // If the value already matches the selected radio, do nothing.\n    const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n\n    if (this._radios && !isAlreadySelected) {\n      this._selected = null;\n      this._radios.forEach(radio => {\n        radio.checked = this.value === radio.value;\n        if (radio.checked) {\n          this._selected = radio;\n        }\n      });\n    }\n  }\n\n  /** Dispatch change event with current selection and group value. */\n  _emitChangeEvent(): void {\n    if (this._isInitialized) {\n      this.change.emit(new MatRadioChange(this._selected!, this._value));\n    }\n  }\n\n  _markRadiosForCheck() {\n    if (this._radios) {\n      this._radios.forEach(radio => radio._markForCheck());\n    }\n  }\n\n  /**\n   * Sets the model value. Implemented as part of ControlValueAccessor.\n   * @param value\n   */\n  writeValue(value: any) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n\n  /**\n   * Registers a callback to be triggered when the model value changes.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  /**\n   * Registers a callback to be triggered when the control is touched.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnTouched(fn: any) {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n   * @param isDisabled Whether the control should be disabled.\n   */\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n    this._changeDetector.markForCheck();\n  }\n}\n\n// Boilerplate for applying mixins to MatRadioButton.\n/** @docs-private */\nabstract class MatRadioButtonBase {\n  // Since the disabled property is manually defined for the MatRadioButton and isn't set up in\n  // the mixin base class. To be able to use the tabindex mixin, a disabled property must be\n  // defined to properly work.\n  abstract disabled: boolean;\n  constructor(public _elementRef: ElementRef) {}\n}\n\nconst _MatRadioButtonMixinBase = mixinDisableRipple(mixinTabIndex(MatRadioButtonBase));\n\n/**\n * Base class with all of the `MatRadioButton` functionality.\n * @docs-private\n */\n@Directive()\nexport abstract class _MatRadioButtonBase\n  extends _MatRadioButtonMixinBase\n  implements OnInit, AfterViewInit, DoCheck, OnDestroy, CanDisableRipple, HasTabIndex\n{\n  private _uniqueId: string = `mat-radio-${++nextUniqueId}`;\n\n  /** The unique ID for the radio button. */\n  @Input() id: string = this._uniqueId;\n\n  /** Analog to HTML 'name' attribute used to group radios for unique selection. */\n  @Input() name: string;\n\n  /** Used to set the 'aria-label' attribute on the underlying input element. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** The 'aria-labelledby' attribute takes precedence as the element's text alternative. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** The 'aria-describedby' attribute is read after the element's label and field type. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  /** Whether this radio button is checked. */\n  @Input()\n  get checked(): boolean {\n    return this._checked;\n  }\n  set checked(value: BooleanInput) {\n    const newCheckedState = coerceBooleanProperty(value);\n    if (this._checked !== newCheckedState) {\n      this._checked = newCheckedState;\n      if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n        this.radioGroup.selected = this;\n      } else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n        // When unchecking the selected radio button, update the selected radio\n        // property on the group.\n        this.radioGroup.selected = null;\n      }\n\n      if (newCheckedState) {\n        // Notify all radio buttons with the same name to un-check.\n        this._radioDispatcher.notify(this.id, this.name);\n      }\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** The value of this radio button. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(value: any) {\n    if (this._value !== value) {\n      this._value = value;\n      if (this.radioGroup !== null) {\n        if (!this.checked) {\n          // Update checked when the value changed to match the radio group's value\n          this.checked = this.radioGroup.value === value;\n        }\n        if (this.checked) {\n          this.radioGroup.selected = this;\n        }\n      }\n    }\n  }\n\n  /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n  }\n  set labelPosition(value) {\n    this._labelPosition = value;\n  }\n  private _labelPosition: 'before' | 'after';\n\n  /** Whether the radio button is disabled. */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n  }\n  set disabled(value: BooleanInput) {\n    this._setDisabled(coerceBooleanProperty(value));\n  }\n\n  /** Whether the radio button is required. */\n  @Input()\n  get required(): boolean {\n    return this._required || (this.radioGroup && this.radioGroup.required);\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n\n  /** Theme color of the radio button. */\n  @Input()\n  get color(): ThemePalette {\n    // As per Material design specifications the selection control radio should use the accent color\n    // palette by default. https://material.io/guidelines/components/selection-controls.html\n    return (\n      this._color ||\n      (this.radioGroup && this.radioGroup.color) ||\n      (this._providerOverride && this._providerOverride.color) ||\n      'accent'\n    );\n  }\n  set color(newValue: ThemePalette) {\n    this._color = newValue;\n  }\n  private _color: ThemePalette;\n\n  /**\n   * Event emitted when the checked state of this radio button changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * the radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** The parent radio group. May or may not be present. */\n  radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>;\n\n  /** ID of the native input element inside `<mat-radio-button>` */\n  get inputId(): string {\n    return `${this.id || this._uniqueId}-input`;\n  }\n\n  /** Whether this radio is checked. */\n  private _checked: boolean = false;\n\n  /** Whether this radio is disabled. */\n  private _disabled: boolean;\n\n  /** Whether this radio is required. */\n  private _required: boolean;\n\n  /** Value assigned to this radio. */\n  private _value: any = null;\n\n  /** Unregister function for _radioDispatcher */\n  private _removeUniqueSelectionListener: () => void = () => {};\n\n  /** Previous value of the input's tabindex. */\n  private _previousTabIndex: number | undefined;\n\n  /** The native `<input type=radio>` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** Whether animations are disabled. */\n  _noopAnimations: boolean;\n\n  constructor(\n    radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>,\n    elementRef: ElementRef,\n    protected _changeDetector: ChangeDetectorRef,\n    private _focusMonitor: FocusMonitor,\n    private _radioDispatcher: UniqueSelectionDispatcher,\n    animationMode?: string,\n    private _providerOverride?: MatRadioDefaultOptions,\n    tabIndex?: string,\n  ) {\n    super(elementRef);\n\n    // Assertions. Ideally these should be stripped out by the compiler.\n    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n    this.radioGroup = radioGroup;\n    this._noopAnimations = animationMode === 'NoopAnimations';\n\n    if (tabIndex) {\n      this.tabIndex = coerceNumberProperty(tabIndex, 0);\n    }\n  }\n\n  /** Focuses the radio button. */\n  focus(options?: FocusOptions, origin?: FocusOrigin): void {\n    if (origin) {\n      this._focusMonitor.focusVia(this._inputElement, origin, options);\n    } else {\n      this._inputElement.nativeElement.focus(options);\n    }\n  }\n\n  /**\n   * Marks the radio button as needing checking for change detection.\n   * This method is exposed because the parent radio group will directly\n   * update bound properties of the radio button.\n   */\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update radio button's status\n    this._changeDetector.markForCheck();\n  }\n\n  ngOnInit() {\n    if (this.radioGroup) {\n      // If the radio is inside a radio group, determine if it should be checked\n      this.checked = this.radioGroup.value === this._value;\n\n      if (this.checked) {\n        this.radioGroup.selected = this;\n      }\n\n      // Copy name from parent radio group\n      this.name = this.radioGroup.name;\n    }\n\n    this._removeUniqueSelectionListener = this._radioDispatcher.listen((id, name) => {\n      if (id !== this.id && name === this.name) {\n        this.checked = false;\n      }\n    });\n  }\n\n  ngDoCheck(): void {\n    this._updateTabIndex();\n  }\n\n  ngAfterViewInit() {\n    this._updateTabIndex();\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin && this.radioGroup) {\n        this.radioGroup._touch();\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    this._removeUniqueSelectionListener();\n  }\n\n  /** Dispatch change event with current value. */\n  private _emitChangeEvent(): void {\n    this.change.emit(new MatRadioChange(this, this._value));\n  }\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  _onInputClick(event: Event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `radio-button` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n\n  /** Triggered when the radio button receives an interaction from the user. */\n  _onInputInteraction(event: Event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n\n    if (!this.checked && !this.disabled) {\n      const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n      this.checked = true;\n      this._emitChangeEvent();\n\n      if (this.radioGroup) {\n        this.radioGroup._controlValueAccessorChangeFn(this.value);\n        if (groupValueChanged) {\n          this.radioGroup._emitChangeEvent();\n        }\n      }\n    }\n  }\n\n  /** Sets the disabled state and marks for check if a change occurred. */\n  protected _setDisabled(value: boolean) {\n    if (this._disabled !== value) {\n      this._disabled = value;\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** Gets the tabindex for the underlying input element. */\n  private _updateTabIndex() {\n    const group = this.radioGroup;\n    let value: number;\n\n    // Implement a roving tabindex if the button is inside a group. For most cases this isn't\n    // necessary, because the browser handles the tab order for inputs inside a group automatically,\n    // but we need an explicitly higher tabindex for the selected button in order for things like\n    // the focus trap to pick it up correctly.\n    if (!group || !group.selected || this.disabled) {\n      value = this.tabIndex;\n    } else {\n      value = group.selected === this ? this.tabIndex : -1;\n    }\n\n    if (value !== this._previousTabIndex) {\n      // We have to set the tabindex directly on the DOM node, because it depends on\n      // the selected state which is prone to \"changed after checked errors\".\n      const input: HTMLInputElement | undefined = this._inputElement?.nativeElement;\n\n      if (input) {\n        input.setAttribute('tabindex', value + '');\n        this._previousTabIndex = value;\n      }\n    }\n  }\n}\n\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\n@Directive({\n  selector: 'mat-radio-group',\n  exportAs: 'matRadioGroup',\n  providers: [\n    MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\n    {provide: MAT_RADIO_GROUP, useExisting: MatRadioGroup},\n  ],\n  host: {\n    'role': 'radiogroup',\n    'class': 'mat-mdc-radio-group',\n  },\n})\nexport class MatRadioGroup extends _MatRadioGroupBase<MatRadioButton> {\n  /** Child radio buttons. */\n  @ContentChildren(forwardRef(() => MatRadioButton), {descendants: true})\n  _radios: QueryList<MatRadioButton>;\n}\n\n@Component({\n  selector: 'mat-radio-button',\n  templateUrl: 'radio.html',\n  styleUrls: ['radio.css'],\n  host: {\n    'class': 'mat-mdc-radio-button',\n    '[attr.id]': 'id',\n    '[class.mat-primary]': 'color === \"primary\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    '[class.mat-mdc-radio-checked]': 'checked',\n    '[class._mat-animation-noopable]': '_noopAnimations',\n    // Needs to be removed since it causes some a11y issues (see #21266).\n    '[attr.tabindex]': 'null',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[attr.aria-describedby]': 'null',\n    // Note: under normal conditions focus shouldn't land on this element, however it may be\n    // programmatically set, for example inside of a focus trap, in this case we want to forward\n    // the focus to the native element.\n    '(focus)': '_inputElement.nativeElement.focus()',\n  },\n  inputs: ['disableRipple', 'tabIndex'],\n  exportAs: 'matRadioButton',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatRadioButton extends _MatRadioButtonBase {\n  constructor(\n    @Optional() @Inject(MAT_RADIO_GROUP) radioGroup: MatRadioGroup,\n    elementRef: ElementRef,\n    _changeDetector: ChangeDetectorRef,\n    _focusMonitor: FocusMonitor,\n    _radioDispatcher: UniqueSelectionDispatcher,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional()\n    @Inject(MAT_RADIO_DEFAULT_OPTIONS)\n    _providerOverride?: MatRadioDefaultOptions,\n    @Attribute('tabindex') tabIndex?: string,\n  ) {\n    super(\n      radioGroup,\n      elementRef,\n      _changeDetector,\n      _focusMonitor,\n      _radioDispatcher,\n      animationMode,\n      _providerOverride,\n      tabIndex,\n    );\n  }\n}\n",null,"<div class=\"mdc-form-field\" #formField\n     [class.mdc-form-field--align-end]=\"labelPosition == 'before'\">\n  <div class=\"mdc-radio\" [class.mdc-radio--disabled]=\"disabled\">\n    <!-- Render this element first so the input is on top. -->\n    <div class=\"mat-mdc-radio-touch-target\" (click)=\"_onInputInteraction($event)\"></div>\n    <input #input class=\"mdc-radio__native-control\" type=\"radio\"\n           [id]=\"inputId\"\n           [checked]=\"checked\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [attr.value]=\"value\"\n           [required]=\"required\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-describedby]=\"ariaDescribedby\"\n           (change)=\"_onInputInteraction($event)\">\n    <div class=\"mdc-radio__background\">\n      <div class=\"mdc-radio__outer-circle\"></div>\n      <div class=\"mdc-radio__inner-circle\"></div>\n    </div>\n    <div mat-ripple class=\"mat-radio-ripple mat-mdc-focus-indicator\"\n         [matRippleTrigger]=\"formField\"\n         [matRippleDisabled]=\"_isRippleDisabled()\"\n         [matRippleCentered]=\"true\">\n      <div class=\"mat-ripple-element mat-radio-persistent-ripple\"></div>\n    </div>\n  </div>\n  <label [for]=\"inputId\">\n    <ng-content></ng-content>\n  </label>\n</div>\n","import {Component, ChangeDetectionStrategy} from '@angular/core';\nimport {ReactiveFormsModule} from '@angular/forms';\nimport {MatRadioModule} from '@angular/material/radio';\nimport {LayoutEditorMetadata} from '@anglr/dynamic/layout-editor';\nimport {CastPipesModule, HostDisplayBlockStyle} from '@anglr/common';\nimport {FormPipesModule} from '@anglr/common/forms';\nimport {FormComponent, FormComponentBase, FormComponentControlSAPipe} from '@anglr/dynamic/form';\nimport {RelationsEditorMetadata} from '@anglr/dynamic/relations-editor';\n\nimport {MaterialRadioLayoutMetadataLoader, MaterialRadioRelationsMetadataLoader} from './radio.metadata';\nimport {MaterialRadioComponentOptions} from './radio.options';\n\n/**\n * Component used for displaying material radio\n */\n@Component(\n{\n    selector: 'material-radio',\n    templateUrl: 'radio.component.html',\n    styles: [HostDisplayBlockStyle],\n    standalone: true,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    imports:\n    [\n        FormPipesModule,\n        CastPipesModule,\n        FormComponentControlSAPipe,\n        ReactiveFormsModule,\n        MatRadioModule,\n    ]\n})\n@RelationsEditorMetadata(MaterialRadioRelationsMetadataLoader)\n@LayoutEditorMetadata(MaterialRadioLayoutMetadataLoader)\nexport class MaterialRadioSAComponent extends FormComponentBase<MaterialRadioComponentOptions> implements FormComponent<MaterialRadioComponentOptions>\n{}",null,"import {ComponentStylingExtension} from '@anglr/dynamic/layout';\nimport {RelationsRegistrationExtension} from '@anglr/dynamic/relations';\n\nimport {MaterialRadioSAComponent} from './radio.component';\n\n\nexport default MaterialRadioSAComponent;\n\nexport const extensions = [ComponentStylingExtension, RelationsRegistrationExtension];","import {Subject} from 'rxjs';\n\nimport {defineAssignedProp, defineSkipInitProp} from '../../misc/utils';\nimport {RelationsChangeDetector, RelationsComponentManager} from '../../services';\nimport {RelationsWithInjector} from '../../services/relationsChangeDetector/relationsChangeDetector.interface';\n\n/**\n * Creates dynamic output for property\n * @param options - Options that allows configure dynamic output\n *\n * `skipInit` - Means that there will be no initial data transfer for this output\n * `sync` - Means that changes will be transfered synchronously, right away\n */\nexport function DynamicOutput(options?: {skipInit?: boolean; sync?: boolean}): PropertyDecorator\n{\n    return function(target: any, propertyKey: string|symbol)\n    {\n        const prop = propertyKey as string;\n\n        Object.defineProperty(target,\n                              `${prop}Change`,\n                              {\n                                  get: function()\n                                  {\n                                      if(!this[`${prop}Change`])\n                                      {\n                                          this[`${prop}Change`] = new Subject<void>();\n                                      }\n\n                                      return this[`${prop}Change`];\n                                  }\n                              });\n\n        Object.defineProperty(target,\n                              prop,\n                              {\n                                  get: function()\n                                  {\n                                      return this[`${prop}`];\n                                  },\n                                  set: function(value: any)\n                                  {\n                                      this[`${prop}`] = value;\n                                      defineAssignedProp(this, prop);\n\n                                      if(options?.sync)\n                                      {\n                                          this[`${prop}Change`].next();\n                                      }\n                                      else\n                                      {\n                                          const injector = (this as RelationsWithInjector).injector;\n\n                                          if(!injector)\n                                          {\n                                              return;\n                                          }\n\n                                          const componentManager = injector.get(RelationsComponentManager);\n                                          const changeDetector = injector.get(RelationsChangeDetector);\n                                          const id = componentManager.getId(this);\n\n                                          if(!id)\n                                          {\n                                              return;\n                                          }\n\n                                          changeDetector.markForCheck(\n                                          {\n                                              componentId: id,\n                                              outputName: prop,\n                                          });\n                                      }\n                                  }\n                              });\n\n        if(options?.skipInit)\n        {\n            defineSkipInitProp(target, prop);\n        }\n    };\n}","import {DynamicItemExtension, DynamicItemExtensionBase} from '@anglr/dynamic';\n\nimport {RelationsComponent} from '../../interfaces';\nimport {RelationsComponentManager, RelationsProcessor} from '../../services';\n\n/**\n * Extension that allows registration of component for relations\n */\nexport class RelationsRegistrationExtension extends DynamicItemExtensionBase<unknown, RelationsComponent> implements DynamicItemExtension<unknown, RelationsComponent>\n{\n    //######################### protected properties #########################\n\n    /**\n     * Instance of relations processor\n     */\n    protected relationsProcessor: RelationsProcessor|null = null;\n\n    /**\n     * Instance of component manager\n     */\n    protected componentManager: RelationsComponentManager|null = null;\n\n    //######################### public methods - overrides #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override async onInit(): Promise<void>\n    {\n        if(!this.injector || !this.metadata || !this.instance)\n        {\n            return;\n        }\n\n        this.relationsProcessor ??= this.injector.get(RelationsProcessor, null);\n        this.componentManager ??= this.injector.get(RelationsComponentManager, null);\n\n        if(!this.relationsProcessor || !this.componentManager)\n        {\n            return;\n        }\n\n        this.componentManager.registerComponent(this.metadata.id, this.instance);\n        await this.relationsProcessor.initialized;\n        this.relationsProcessor.updateRelations(this.metadata.id);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected override onDestroy(): void\n    {\n        if(!this.relationsProcessor || !this.componentManager || !this.metadata)\n        {\n            return;\n        }\n\n        this.relationsProcessor.destroyComponent(this.metadata.id);\n        this.componentManager.unregisterComponent(this.metadata.id);\n    }\n}","import {ElementRef, Injector} from '@angular/core';\nimport {PromiseOr} from '@jscrpt/common';\n\nimport {DynamicItem, DynamicItemExtension, DynamicItemMetadata} from '../interfaces';\n\n/**\n * Dynamic item extension base class\n */\nexport abstract class DynamicItemExtensionBase<TOptions = unknown, TInstance extends DynamicItem = any> implements DynamicItemExtension<TOptions, TInstance>\n{\n    //######################### protected fields #########################\n\n    /**\n     * Injector from extended component\n     */\n    protected injector?: Injector;\n\n    /**\n     * Element that could be extended\n     */\n    protected element?: ElementRef<HTMLElement>;\n\n    /**\n     * Options that stores extension and component data\n     */\n    protected options?: TOptions;\n\n    /**\n     * Instance of dynamic item that is being extended\n     */\n    protected instance?: TInstance;\n\n    /**\n     * Indication whether was extension initialized\n     */\n    protected initialized: boolean = false;\n\n    //######################### constructor #########################\n    constructor(protected metadata: DynamicItemMetadata)\n    {\n    }\n\n    //######################### public methods - implementation of DynamicItemExtension #########################\n\n    /**\n     * @inheritdoc\n     */\n    public async initialize(injector: Injector, element: ElementRef<HTMLElement>, instance: TInstance): Promise<void>\n    {\n        this.initialized = true;\n\n        this.injector = injector;\n        this.element = element;\n        this.instance = instance;\n\n        await this.onInit();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public async optionsChange(options: TOptions): Promise<void>\n    {\n        this.options = options;\n\n        if(!this.initialized)\n        {\n            return;\n        }\n\n        await this.onOptionsChange();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public destroy(): void\n    {\n        this.onDestroy();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Called on initialization of component\n     */\n    protected onInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on change of options of component\n     */\n    protected onOptionsChange(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on destruction of component\n     */\n    protected onDestroy(): void\n    {\n    }\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, OnDestroy} from '@angular/core';\n\n// Users of the Dispatcher never need to see this type, but TypeScript requires it to be exported.\nexport type UniqueSelectionDispatcherListener = (id: string, name: string) => void;\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\n@Injectable({providedIn: 'root'})\nexport class UniqueSelectionDispatcher implements OnDestroy {\n  private _listeners: UniqueSelectionDispatcherListener[] = [];\n\n  /**\n   * Notify other items that selection for the given name has been set.\n   * @param id ID of the item.\n   * @param name Name of the item.\n   */\n  notify(id: string, name: string) {\n    for (let listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n\n  /**\n   * Listen for future changes to item selection.\n   * @return Function used to deregister listener\n   */\n  listen(listener: UniqueSelectionDispatcherListener): () => void {\n    this._listeners.push(listener);\n    return () => {\n      this._listeners = this._listeners.filter((registered: UniqueSelectionDispatcherListener) => {\n        return listener !== registered;\n      });\n    };\n  }\n\n  ngOnDestroy() {\n    this._listeners = [];\n  }\n}\n"],"names":["AsFormControlPipe","constructor","_logger","transform","value","_valueHash","isBlank","FormControl","this","warn","LOGGER","FormComponentBase","LayoutComponentBase","oldValue","valueOutput","control","patchValue","required","_required","removeValidators","Validators","addValidators","disabled","_disabled","enable","disable","_changeDetector","_element","_injector","_parentControl","super","onOptionsSet","options","controlSubscription","unsubscribe","_getFormControl","controlName","FormComponentControlType","_registerValidations","valueChanges","subscribe","parentControl","defaultControlType","initValue","getFormControl","logger","name","getControlForType","FORM_COMPONENT_CONTROL","__decorate","DynamicOutput","InjectionToken","LayoutEditorMetadata","metadataLoader","DynamicClassMetadata","element","componentElement","extensionsOptions","changeDetector","injector","extensions","initialized","destroyed","ngOnDestroy","ext","destroy","onDestroy","ngOnInit","onInit","extension","initialize","afterInit","ngOnChanges","changes","nameof","optionsChange","onOptionsChange","isEmptyObject","onChanges","registerExtensions","invalidateVisuals","detectChanges","_changes","ComponentStylingExtension","DynamicItemExtensionBase","_applyStyling","style","nativeElement","isPresent","lastCssClass","cssClass","split","classList","remove","add","margin","bottom","marginBottom","right","marginRight","top","marginTop","left","marginLeft","padding","paddingBottom","paddingRight","paddingTop","paddingLeft","textStyling","fontSize","fontWeight","toString","MatRadioModule","MatCommonModule","CommonModule","MatRippleModule","MaterialRadioLayoutMetadataLoader","MaterialRadioLayoutEditorMetadata","MaterialRadioRelationsMetadataLoader","MaterialRadioRelationsEditorMetadata","nextUniqueId","MatRadioChange","source","MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","MatRadioGroup","multi","MAT_RADIO_GROUP","MAT_RADIO_DEFAULT_OPTIONS","providedIn","factory","color","_MatRadioGroupBase","_name","_updateRadioButtonNames","labelPosition","_labelPosition","v","_markRadiosForCheck","_value","newValue","_updateSelectedRadioFromValue","_checkSelectedRadioButton","_selected","checked","selected","coerceBooleanProperty","_isInitialized","_controlValueAccessorChangeFn","onTouched","change","EventEmitter","ngAfterContentInit","_touch","_radios","forEach","radio","_markForCheck","isAlreadySelected","_emitChangeEvent","emit","writeValue","markForCheck","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","_MatRadioButtonMixinBase","mixinDisableRipple","mixinTabIndex","_elementRef","_MatRadioButtonBase","_checked","newCheckedState","radioGroup","_radioDispatcher","notify","id","_setDisabled","_color","_providerOverride","inputId","_uniqueId","elementRef","_focusMonitor","animationMode","tabIndex","_removeUniqueSelectionListener","_noopAnimations","coerceNumberProperty","focus","origin","focusVia","_inputElement","listen","ngDoCheck","_updateTabIndex","ngAfterViewInit","monitor","focusOrigin","stopMonitoring","_isRippleDisabled","disableRipple","_onInputClick","event","stopPropagation","_onInputInteraction","groupValueChanged","group","_previousTabIndex","input","setAttribute","MatRadioButton","ANIMATION_MODULE_TYPE","i3","MaterialRadioSAComponent","FormPipesModule","CastPipesModule","ReactiveFormsModule","RelationsEditorMetadata","RelationsRegistrationExtension","target","propertyKey","prop","Object","defineProperty","get","Subject","set","defineAssignedProp","sync","next","injector","componentManager","RelationsComponentManager","RelationsChangeDetector","getId","componentId","outputName","skipInit","defineSkipInitProp","relationsProcessor","metadata","instance","RelationsProcessor","registerComponent","updateRelations","destroyComponent","unregisterComponent","UniqueSelectionDispatcher","_listeners","listener","push","filter","registered"],"sourceRoot":""}