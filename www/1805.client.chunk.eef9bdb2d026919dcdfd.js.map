{"version":3,"file":"1805.client.chunk.eef9bdb2d026919dcdfd.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../forms/src/modules/formPipes/pipes/asFormControl/asFormControl.pipe.ts","webpack://ng-universal-demo/../../../forms/src/misc/formModel/misc/validatorFactories.ts","webpack://ng-universal-demo/../../../forms/src/misc/formModel/misc/utils.ts","webpack://ng-universal-demo/../../../forms/src/services/formModelBuilder/formModelBuilder.service.ts","webpack://ng-universal-demo/../../../layout-editor/src/modules/propertiesControls/directives/propertiesControlRenderer/propertiesControlRenderer.directive.ts","webpack://ng-universal-demo/../../../layout-editor/src/modules/propertiesControls/modules/propertiesControls.module.ts","webpack://ng-universal-demo/../../../layout-editor/src/modules/propertyTypeControls/modules/propertyTypeControls.module.ts","webpack://ng-universal-demo/../../../layout-relations/src/dynamicItems/customComponent/misc/pipes/getControls/getControls.pipe.ts","webpack://ng-universal-demo/../../../layout-relations/src/pipes/getModel/getModel.pipe.ts","webpack://ng-universal-demo/../../../layout-relations/src/pipes/propertiesMetadata/propertiesMetadata.pipe.ts","webpack://ng-universal-demo/../../../layout-relations/src/dynamicItems/customComponent/misc/components/contentOptionsPropertiesControl/contentOptionsPropertiesControl.component.ts","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/layout-relations/src/dynamicItems/customComponent/misc/components/contentOptionsPropertiesControl/contentOptionsPropertiesControl.component.html","webpack://ng-universal-demo/../../../layout-relations/src/dynamicItems/customComponent/metadata/customComponent.model.ts","webpack://ng-universal-demo/../../../layout-relations/src/dynamicItems/customComponent/metadata/customComponent.layoutMetadata.ts","webpack://ng-universal-demo/../../../packages/common/src/pipes/keyvalue_pipe.ts"],"sourcesContent":["import {Inject, Optional, Pipe} from '@angular/core';\nimport {AbstractControl, FormControl} from '@angular/forms';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {isBlank} from '@jscrpt/common';\n\n/**\n * Tries to convert `AbstractControl` to `FormControl`\n */\n@Pipe({name: 'asFormControl'})\nexport class AsFormControlPipe\n{\n    //######################### constructors #########################\n    constructor(@Optional() @Inject(LOGGER) private _logger?: Logger)\n    {\n    }\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Allows casting of `AbstractControl` to `FormControl`\n     * @param value - `AbstractControl` to be cast to `FormControl`\n     * @param _valueHash - Parameter that can be used to change value, indicates that pipe input value has changed\n     */\n    public transform<TModel>(value: AbstractControl<TModel>|null|undefined, _valueHash?: any): FormControl<TModel>|null\n    {\n        if(isBlank(value))\n        {\n            return null;\n        }\n\n        if(value instanceof FormControl)\n        {\n            return value as FormControl<TModel>;\n        }\n\n        this._logger?.warn('Failed to cast AbstractControl to FormControl');\n\n        return null;\n    }\n}","import {AsyncValidatorFn, ValidatorFn} from '@angular/forms';\nimport {Dictionary} from '@jscrpt/common';\n\nimport {AsyncValidatorFnFactoryFn, ValidatorFnFactoryFn} from '../interfaces/validator.interface';\n\n/**\n * Class that represents ValidatorFn factory\n */\nexport class ValidatorFnFactory<TArg extends Dictionary<any> = any>\n{\n    //######################### constructor #########################\n    /**\n     * Creates instance of ValidatorFnFactory\n     * @param _factoryFn - Function used for creating ValidatorFn\n     * @param _args - Static arguments/parameters that can be passed to validator\n     */\n    constructor(private _factoryFn?: ValidatorFnFactoryFn<TArg>,\n                private _args?: TArg,)\n    {\n    }\n\n    //######################### public methods #########################\n\n    /**\n     * Gets validator function factory function\n     */\n    public valueOf(): ValidatorFnFactoryFn<TArg>\n    {\n        if(this._args)\n        {\n            return (args: TArg): ValidatorFn =>\n            {\n                args = \n                {\n                    ...this._args,\n                    args\n                };\n\n                return this._factoryFn(args);\n            };\n        }\n\n        return this._factoryFn;\n    }\n}\n\n/**\n * Class that represents AsyncValidatorFn factory\n */\nexport class AsyncValidatorFnFactory<TArg extends Dictionary<any> = any>\n{\n    //######################### constructor #########################\n    /**\n     * Creates instance of AsyncValidatorFnFactory\n     * @param _factoryFn - Function used for creating AsyncValidatorFn\n     * @param _args - Static arguments/parameters that can be passed to validator\n     */\n    constructor(private _factoryFn?: AsyncValidatorFnFactoryFn<TArg>,\n                private _args?: TArg,)\n    {\n    }\n\n    //######################### public methods #########################\n\n    /**\n     * Gets async validator function factory function\n     */\n    public valueOf(): AsyncValidatorFnFactoryFn<TArg>\n    {\n        if(this._args)\n        {\n            return (args: TArg): AsyncValidatorFn =>\n            {\n                args = \n                {\n                    ...this._args,\n                    args\n                };\n\n                return this._factoryFn(args);\n            };\n        }\n\n        return this._factoryFn;\n    }\n}","import {AbstractControl, FormArray, FormControl, FormGroup} from '@angular/forms';\nimport {Dictionary} from '@jscrpt/common';\n\nimport {FormModelGroup} from '../../types';\nimport {FormModelBuilderDefaultArgs} from '../interfaces/formModelBuilder.interface';\nimport {ModelDecoratorMetadata} from '../interfaces/modelDecoratorMetadata';\nimport {ModelPropertyDecoratorMetadata} from '../interfaces/modelPropertyDecoratorMetadata';\nimport {ɵDefaultPropertyMetadata} from './defaults';\nimport {AsyncValidatorFnFactory, ValidatorFnFactory} from './validatorFactories';\n\n/**\n * Builds form group from decorated model\n * @param model - Model that can be decorated for enhancing created form group with validation and so on\n * @param args - Object storing arguments from owning component for customization\n * @returns\n */\nfunction buildFormGroup<TModel, TArgs extends Dictionary<any> = any>(model: ModelDecoratorMetadata<TModel> & Dictionary<any>, args?: TArgs&FormModelBuilderDefaultArgs): FormGroup<FormModelGroup<TModel>>\n{\n    if(!model)\n    {\n        return new FormGroup<FormModelGroup<TModel>>({} as any);\n    }\n\n    const modelMetadata: Dictionary<any> = model.ɵControlsMetadata ?? {};\n    const groupValidators = model.ɵValidators ?? [];\n    const groupAsyncValidators = model.ɵAsyncValidators ?? [];\n    const groupArgs: Dictionary<any> = model.ɵArgs ?? {};\n    const properties = Object.keys(model);\n    const formGroup: FormGroup = new FormGroup({},\n                                               {\n                                                   validators: groupValidators?.map(validator => validator instanceof ValidatorFnFactory ? validator.valueOf()({...groupArgs, ...args}) : validator).filter(itm => !!itm),\n                                                   asyncValidators: groupAsyncValidators?.map(validator => validator instanceof AsyncValidatorFnFactory ? validator.valueOf()({...groupArgs, ...args}) : validator).filter(itm => !!itm)\n                                               });\n\n    for(const propertyName of properties)\n    {\n        const metadata: ModelPropertyDecoratorMetadata = modelMetadata[propertyName] ?? ɵDefaultPropertyMetadata;\n        const defaultValue = model[propertyName];\n\n        //Skip control creation if value is undefined\n        if(defaultValue === undefined)\n        {\n            continue;\n        }\n\n        const validators = metadata.validators.map(validator => validator instanceof ValidatorFnFactory ? validator.valueOf()({...metadata.args, ...args}) : validator).filter(itm => !!itm);\n        const asyncValidators = metadata.asyncValidators.map(validator => validator instanceof AsyncValidatorFnFactory ? validator.valueOf()({...metadata.args, ...args}) : validator).filter(itm => !!itm);\n\n        let control: AbstractControl;\n\n        switch(metadata.type)\n        {\n            case FormGroup:\n            {\n                control = buildFormGroup(defaultValue, args);\n\n                //TODO: think of setting metadata from property to model\n\n                break;\n            }\n            case FormArray:\n            {\n                //TODO - enhance FormArray child definition and finish it\n                control = new FormArray([],\n                                        {\n                                            validators: validators,\n                                            asyncValidators: asyncValidators,\n                                            ...metadata.controlOptions\n                                        });\n\n                if(defaultValue && Array.isArray(defaultValue))\n                {\n                    const formArray = control as FormArray;\n\n                    for(const val of defaultValue)\n                    {\n                        switch(metadata.childType)\n                        {\n                            case FormGroup:\n                            {\n                                formArray.push(buildFormGroup(val, args));\n\n                                break;\n                            }\n                            case FormArray:\n                            {\n                                break;\n                            }\n                            default:\n                            //case FormControl:\n                            {\n                                formArray.push(new FormControl(val,\n                                                               {\n                                                                   validators: validators,\n                                                                   asyncValidators: asyncValidators,\n                                                                   ...metadata.controlOptions\n                                                               }));\n\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                break;\n            }\n            default:\n            //case FormControl:\n            {\n                control = new FormControl(defaultValue,\n                                          {\n                                              validators: validators,\n                                              asyncValidators: asyncValidators,\n                                              ...metadata.controlOptions\n                                          });\n\n                break;\n            }\n        }\n\n        if(metadata.disabled)\n        {\n            control.disable();\n        }\n\n        formGroup.addControl(propertyName, control);\n    }\n\n    return formGroup;\n}\n\n/**\n * Builds form from decorated model, only for properties with non `undefined` value\n * @param model - Model that can be decorated for enhancing created form group with validation and so on\n * @param args - Object storing arguments from owning component for customization\n * @returns\n */\nexport function buildFormModel<TModel, TArgs extends Dictionary<any> = any>(model: TModel, args?: TArgs&FormModelBuilderDefaultArgs): FormGroup<FormModelGroup<TModel>>\n{\n    return buildFormGroup(model as any, args);\n}\n","import {Injectable, Injector} from '@angular/core';\nimport {FormGroup} from '@angular/forms';\nimport {Dictionary} from '@jscrpt/common';\n\nimport {buildFormModel} from '../../misc/formModel';\nimport {FormModelGroup} from '../../misc/types';\n\n/**\n * Instance of form model builder, that creates `FormGroup` from form model, automatically providing `Injector`\n */\n@Injectable()\nexport class FormModelBuilder\n{\n    //######################### constructor #########################\n    constructor(protected _injector: Injector)\n    {\n    }\n\n    //######################### public methods #########################\n\n    /**\n     * Builds form from decorated model, only for properties with non `undefined` value\n     * @param model - Model that can be decorated for enhancing created form group with validation and so on\n     * @param args - Object storing arguments from owning component for customization\n     */\n    public build<TModel, TArgs extends Dictionary<any> = any>(model: TModel, args?: TArgs): FormGroup<FormModelGroup<TModel>>\n    {\n        return buildFormModel<TModel, TArgs>(model,\n                                             {\n                                                 ...args,\n                                                 injector: this._injector,\n                                             });\n    }\n}","import {ComponentRef, Directive, Inject, Input, Optional, Type, ViewContainerRef} from '@angular/core';\nimport {FormGroup} from '@angular/forms';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {FormModelGroup} from '@anglr/common/forms';\nimport {Dictionary} from '@jscrpt/common';\n\nimport {PropertiesControl} from '../../../../interfaces';\nimport {LayoutEditorPropertyMetadata} from '../../../../misc/types';\nimport {LayoutPropertyTypeData} from '../../../../decorators';\n\n/**\n * Directive used for rendering properties control\n */\n@Directive(\n{\n    selector: '[propertiesControl]'\n})\nexport class PropertiesControlRendererDirective<TComponent extends PropertiesControl<TOptions> = any, TOptions = any>\n{\n    //######################### protected fields #########################\n\n    /**\n     * Created component reference\n     */\n    protected _componentRef: ComponentRef<TComponent>|null = null;\n\n    //######################### public properties - inputs #########################\n\n    /**\n     * Form group representing whole options\n     */\n    @Input()\n    public form: FormGroup<FormModelGroup<TOptions>>|undefined;\n\n    /**\n     * Properties metadata that are being rendered\n     */\n    @Input()\n    public propertiesMetadata: Dictionary<LayoutEditorPropertyMetadata&LayoutPropertyTypeData>|null = null;\n\n    /**\n     * Type that will be rendered\n     */\n    @Input('propertiesControl')\n    public type: Type<PropertiesControl>|undefined;\n\n    //######################### constructor #########################\n    constructor(protected _viewContainerRef: ViewContainerRef,\n                @Inject(LOGGER) @Optional() protected _logger?: Logger,)\n    {\n    }\n\n    //######################### public methods - implementation of OnChanges #########################\n\n    /**\n     * Called when input value changes\n     */\n    public async ngOnChanges(): Promise<void>\n    {\n        this._logger?.debug('PropertiesControlRendererDirective: rendering properties control {@type}', {type: this.type?.name});\n\n        this.ngOnDestroy();\n        this._viewContainerRef.clear();\n\n        // metadata are present\n        if(this.type)\n        {\n            const injector = this._viewContainerRef.injector;\n\n            this._componentRef = this._viewContainerRef.createComponent(this.type,\n                                                                        {\n                                                                            injector,\n                                                                        }) as ComponentRef<TComponent>;\n\n            if(this._componentRef)\n            {\n                const component = this._componentRef.instance;\n                component.propertiesMetadata = this.propertiesMetadata;\n                component.form = this.form;\n\n                await component.initialize();\n                component.invalidateVisuals();\n            }\n        }\n    }\n\n    //######################### public methods - implementation of OnDestroy #########################\n\n    /**\n     * Called when component is destroyed\n     */\n    public ngOnDestroy(): void\n    {\n        if(this._componentRef)\n        {\n            this._logger?.debug('PropertiesControlRendererDirective: destroying properties control {@type}', {type: this.type?.name});\n    \n            this._componentRef?.destroy();\n            this._componentRef = null;\n        }\n    }\n}","import {NgModule} from '@angular/core';\nimport {CommonModule} from '@angular/common';\nimport {CastPipesModule, TooltipModule} from '@anglr/common';\nimport {FormPipesModule} from '@anglr/common/forms';\n\nimport {ComponentStylingPropertiesControlComponent, DefaultGenericPropertiesControlComponent, MarginControlComponent, PaddingControlComponent} from '../components';\nimport {PropertyTypeControlsModule} from '../../propertyTypeControls';\nimport {PropertiesControlRendererDirective} from '../directives';\n\n/**\n * Module for properties controls components\n */\n@NgModule(\n{\n    imports:\n    [\n        CommonModule,\n        TooltipModule,\n        PropertyTypeControlsModule,\n        FormPipesModule,\n        CastPipesModule,\n    ],\n    declarations:\n    [\n        ComponentStylingPropertiesControlComponent,\n        DefaultGenericPropertiesControlComponent,\n        MarginControlComponent,\n        PaddingControlComponent,\n        PropertiesControlRendererDirective,\n    ],\n    exports:\n    [\n        ComponentStylingPropertiesControlComponent,\n        DefaultGenericPropertiesControlComponent,\n        MarginControlComponent,\n        PaddingControlComponent,\n        PropertiesControlRendererDirective,\n    ]\n})\nexport class PropertiesControlsModule\n{\n}","import {NgModule} from '@angular/core';\nimport {CommonModule} from '@angular/common';\nimport {ReactiveFormsModule} from '@angular/forms';\nimport {CastPipesModule} from '@anglr/common';\nimport {NumberInputModule} from '@anglr/common/forms';\n\nimport {InputBooleanComponent, InputNumberComponent, InputSizeComponent, InputStringComponent, SelectValueComponent, TextareaComponent} from '../components';\nimport {PropertyTypeControlRendererDirective} from '../directives';\n\n/**\n * Module containing built-in property type controls\n */\n@NgModule(\n{\n    imports:\n    [\n        CommonModule,\n        ReactiveFormsModule,\n        CastPipesModule,\n        NumberInputModule,\n    ],\n    declarations:\n    [\n        TextareaComponent,\n        InputStringComponent,\n        InputBooleanComponent,\n        InputNumberComponent,\n        InputSizeComponent,\n        SelectValueComponent,\n        PropertyTypeControlRendererDirective,\n    ],\n    exports:\n    [\n        TextareaComponent,\n        InputStringComponent,\n        InputBooleanComponent,\n        InputNumberComponent,\n        InputSizeComponent,\n        SelectValueComponent,\n        PropertyTypeControlRendererDirective,\n    ],\n})\nexport class PropertyTypeControlsModule\n{\n}","import {Pipe, PipeTransform, Type} from '@angular/core';\nimport {PropertiesControl} from '@anglr/dynamic/layout-editor';\n\nimport {ContentComponentData} from '../../../../../components';\n\n/**\n * Gets properties controls that are used for setting model value\n */\n@Pipe({name: 'getControls', standalone: true})\nexport class GetControlsSAPipe implements PipeTransform\n{\n    /**\n     * Gets properties controls that are used for setting model value\n     * @param value - Name of model class\n     * @param metadata - Metadata containing properties controls for model\n     */\n    public transform(value: string, metadata: ContentComponentData|undefined|null,): Type<PropertiesControl>[]\n    {\n        return metadata?.editorMetadata.metaInfo?.optionsMetadata?.propertiesMetadata?.find(itm => itm.modelType.name == value)?.propertiesControls ?? [];\n    }\n}","import {Pipe, PipeTransform} from '@angular/core';\nimport {LayoutPropertiesModelType} from '@anglr/dynamic/layout-editor';\n\nimport {ContentComponentData} from '../../components';\n\n/**\n * Gets properties model using its name\n */\n@Pipe({name: 'getModel', standalone: true})\nexport class GetModelSAPipe implements PipeTransform\n{\n    /**\n     * Gets properties model using its name\n     * @param value - Name of model class\n     * @param metadata - Metadata containing model\n     */\n    public transform(value: string, metadata: ContentComponentData|undefined|null,): LayoutPropertiesModelType|null\n    {\n        return metadata?.editorMetadata.metaInfo?.optionsMetadata?.propertiesMetadata?.find(itm => itm.modelType.name == value)?.modelType ?? null;\n    }\n}","import {Optional, Pipe, PipeTransform} from '@angular/core';\nimport {LayoutEditorPropertyMetadata, LayoutEditorPropertyMetadataExtractor, LayoutPropertiesModelType} from '@anglr/dynamic/layout-editor';\nimport {Dictionary} from '@jscrpt/common';\n\n/**\n * Gets properties metadata for for model type\n */\n@Pipe({name: 'propertiesMetadata', standalone: true,})\nexport class PropertiesMetadataSAPipe implements PipeTransform\n{\n    //######################### constructor #########################\n    constructor(@Optional() protected propertyExtractor?: LayoutEditorPropertyMetadataExtractor,)\n    {\n    }\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Gets properties metadata for for model type\n     * @param value - Type of properties model\n     * @param propertyExtractor - Extractor used for obtaining metadata for model\n     */\n    public transform(value: LayoutPropertiesModelType|null, propertyExtractor?: LayoutEditorPropertyMetadataExtractor): Dictionary<LayoutEditorPropertyMetadata>|null\n    {\n        if(!value)\n        {\n            return null;\n        }\n\n        this.propertyExtractor ??= propertyExtractor;\n\n        if(!this.propertyExtractor)\n        {\n            throw new Error('Please provide LayoutEditorPropertyMetadataExtractor for propertiesMetadata pipe!');\n        }\n\n        return this.propertyExtractor.extract(value);\n    }\n}","import {ChangeDetectionStrategy, Component, inject, Injector} from '@angular/core';\nimport {FormGroup} from '@angular/forms';\nimport {CommonModule} from '@angular/common';\nimport {FormModelBuilder} from '@anglr/common/forms';\nimport {PropertiesControl, PropertiesControlBase, PropertiesControlsModule} from '@anglr/dynamic/layout-editor';\nimport {LayoutComponentMetadata} from '@anglr/dynamic/layout';\nimport {Dictionary, extend} from '@jscrpt/common';\n\nimport {CustomComponentComponentOptions} from '../../../customComponent.options';\nimport {GetControlsSAPipe} from '../../pipes/getControls/getControls.pipe';\nimport {ContentComponentData} from '../../../../../components';\nimport {GetModelSAPipe, PropertiesMetadataSAPipe} from '../../../../../pipes';\nimport {getCustomComponentMeta} from '../../../../../misc/utils';\nimport {CustomComponentConfiguration, CustomComponentsRegister} from '../../../../../services';\n\n/**\n * Component used for displaying editation of content options\n */\n@Component(\n{\n    selector: 'content-options',\n    templateUrl: 'contentOptionsPropertiesControl.component.html',\n    standalone: true,\n    imports:\n    [\n        CommonModule,\n        PropertiesControlsModule,\n        GetControlsSAPipe,\n        GetModelSAPipe,\n        PropertiesMetadataSAPipe,\n    ],\n    providers:\n    [\n        FormModelBuilder,\n    ],\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ContentOptionsPropertiesControlSAComponent<TConfig extends CustomComponentConfiguration = CustomComponentConfiguration> extends PropertiesControlBase<CustomComponentComponentOptions> implements PropertiesControl<CustomComponentComponentOptions>\n{\n    //######################### protected properties #########################\n\n    /**\n     * Instance of injector for this component\n     */\n    protected injector: Injector = inject(Injector);\n\n    /**\n     * Form model builder\n     */\n    protected formModelBuilder: FormModelBuilder = inject(FormModelBuilder);\n\n    /**\n     * Instance of custom components register\n     */\n    protected customComponentsRegister: CustomComponentsRegister<TConfig> = inject(CustomComponentsRegister);\n\n    /**\n     * Metadata for each component in custom component\n     */\n    protected customComponentContentMetadata: Dictionary<ContentComponentData|undefined|null> = {};\n\n    /**\n     * Custom component layout metadata\n     */\n    protected customComponentMetadata: LayoutComponentMetadata|undefined|null;\n\n    /**\n     * Represents used properties\n     */\n    protected usedProperties: Dictionary<Dictionary<string[]>> = {};\n\n    /**\n     * Stores components and their form groups\n     */\n    protected usedComponentsForms: Dictionary<Dictionary<FormGroup>> = {};\n\n    //######################### protected methods - overrides #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override async _initialize(): Promise<void>\n    {\n        if(!this.form)\n        {\n            return;\n        }\n\n        const options: Partial<CustomComponentComponentOptions> = this.form.value;\n        \n        const name = options.name ?? '';\n        const result = (await getCustomComponentMeta(name, this.injector));\n\n        if(!result)\n        {\n            return;\n        }\n\n        this.customComponentContentMetadata = result.contentMetadata;\n        this.customComponentMetadata = result.metadata;\n\n        const configuration = this.customComponentsRegister.getConfigurationForComponent(name);\n\n        if(!configuration)\n        {\n            return;\n        }\n\n        this.usedProperties = configuration.configurableProperties ?? {};\n\n        for(const id in this.usedProperties)\n        {\n            if(!this.customComponentContentMetadata[id])\n            {\n                delete this.usedProperties[id];\n            }\n\n            //TODO: remove models that are not present in metadata, and also properties\n            // for(const modelName in this.usedProperties[id])\n            // {\n            //     if(!this.customComponentContentMetadata[id]?.editorMetadata.metaInfo?.optionsMetadata?.propertiesMetadata)\n            // }\n        }\n\n        this.initForms();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Initialize forms for properties\n     */\n    protected initForms(): void\n    {\n        this.usedComponentsForms = {};\n\n        for(const cmpId in this.usedProperties)\n        {\n            for(const modelName in this.usedProperties[cmpId])\n            {\n                const model = this.customComponentContentMetadata[cmpId]?.editorMetadata.metaInfo?.optionsMetadata?.propertiesMetadata.find(itm => itm.modelType.name == modelName)?.modelType;\n                const usedProperties = this.usedProperties[cmpId][modelName];\n\n                if(!model)\n                {\n                    continue;\n                }\n\n                const options = extend(true,\n                                       {},\n                                       this.customComponentContentMetadata[cmpId]?.editorMetadata.metaInfo?.defaultOptions,\n                                       this.customComponentContentMetadata[cmpId]?.metadata.options,\n                                       this.form?.controls.contentOptions.value[cmpId]);\n\n                this.usedComponentsForms[cmpId] ??= {};\n\n                const modelInstance = new model(options);\n\n                for(const property of Object.keys(modelInstance))\n                {\n                    //remove property if not used\n                    if(usedProperties.indexOf(property) < 0)\n                    {\n                        delete modelInstance[property];\n                    }\n                }\n\n                const form = this.usedComponentsForms[cmpId][modelName] = this.formModelBuilder\n                    .build(modelInstance);\n\n                console.log(form);\n\n                form.valueChanges.subscribe(value =>\n                {\n                    const currentOpts = this.form?.controls.contentOptions.value ?? {};\n                    currentOpts[cmpId] ??= {};\n\n                    extend(currentOpts[cmpId], value);\n\n                    this.form?.controls.contentOptions.patchValue(currentOpts);\n                });\n            }\n        }\n    }\n}\n",null,"import {LayoutComponentMetadata} from '@anglr/dynamic/layout';\nimport {Dictionary, mapValuesToThis} from '@jscrpt/common';\n\nimport {CustomComponentComponentOptions} from '../customComponent.options';\n\n/**\n * Custom component model for properties editor\n */\nexport class CustomComponentModel implements CustomComponentComponentOptions\n{\n    //######################### public properties #########################\n\n    /**\n     * @inheritdoc\n     */\n    public name: string = '';\n\n    /**\n     * @inheritdoc\n     */\n    public placeholderContainers: Dictionary<LayoutComponentMetadata>|undefined|null;\n\n    /**\n     * @inheritdoc\n     */\n    public contentOptions: Dictionary<unknown> = {};\n\n    //######################### constructor #########################\n    constructor(value: CustomComponentComponentOptions|undefined|null)\n    {\n        mapValuesToThis.bind(this)(value);\n    }\n}","import {ComponentStylingModel, ComponentStylingPropertiesControlComponent, LayoutEditorMetadataDescriptor, LayoutEditorMetadataInfo} from '@anglr/dynamic/layout-editor';\n\nimport {CustomComponentComponentOptions} from '../customComponent.options';\nimport {ContentOptionsPropertiesControlSAComponent} from '../misc';\nimport {CustomComponentModel} from './customComponent.model';\n\n/**\n * Custom component layout metadata\n */\nexport class CustomComponentLayoutEditorMetadata implements LayoutEditorMetadataDescriptor<CustomComponentComponentOptions>\n{\n    //######################### public properties - implementation of LayoutEditorMetadataDescriptor #########################\n\n    /**\n     * @inheritdoc\n     */\n    public metaInfo?: LayoutEditorMetadataInfo<CustomComponentComponentOptions> =\n    {\n        group: 'Components',\n        optionsMetadata:\n        {\n            propertiesMetadata:\n            [\n                {\n                    modelType: ComponentStylingModel,\n                    propertiesControls: \n                    [\n                        ComponentStylingPropertiesControlComponent,\n                    ],\n                },\n                {\n                    modelType: CustomComponentModel,\n                    propertiesControls: \n                    [\n                        ContentOptionsPropertiesControlSAComponent,\n                    ],\n                },\n            ]\n        },\n        defaultOptions:\n        {\n        }\n    };\n\n    //######################### constructor #########################\n    constructor()\n    {\n        Object.freeze(this);\n    }\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDiffers, Pipe, PipeTransform} from '@angular/core';\n\nfunction makeKeyValuePair<K, V>(key: K, value: V): KeyValue<K, V> {\n  return {key: key, value: value};\n}\n\n/**\n * A key value pair.\n * Usually used to represent the key value pairs from a Map or Object.\n *\n * @publicApi\n */\nexport interface KeyValue<K, V> {\n  key: K;\n  value: V;\n}\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Transforms Object or Map into an array of key value pairs.\n *\n * The output array will be ordered by keys.\n * By default the comparator will be by Unicode point value.\n * You can optionally pass a compareFn if your keys are complex types.\n *\n * @usageNotes\n * ### Examples\n *\n * This examples show how an Object or a Map can be iterated by ngFor with the use of this\n * keyvalue pipe.\n *\n * {@example common/pipes/ts/keyvalue_pipe.ts region='KeyValuePipe'}\n *\n * @publicApi\n */\n@Pipe({\n  name: 'keyvalue',\n  pure: false,\n  standalone: true,\n})\nexport class KeyValuePipe implements PipeTransform {\n  constructor(private readonly differs: KeyValueDiffers) {}\n\n  private differ!: KeyValueDiffer<any, any>;\n  private keyValues: Array<KeyValue<any, any>> = [];\n  private compareFn: (a: KeyValue<any, any>, b: KeyValue<any, any>) => number = defaultComparator;\n\n  /*\n   * NOTE: when the `input` value is a simple Record<K, V> object, the keys are extracted with\n   * Object.keys(). This means that even if the `input` type is Record<number, V> the keys are\n   * compared/returned as `string`s.\n   */\n  transform<K, V>(\n      input: ReadonlyMap<K, V>,\n      compareFn?: (a: KeyValue<K, V>, b: KeyValue<K, V>) => number): Array<KeyValue<K, V>>;\n  transform<K extends number, V>(\n      input: Record<K, V>, compareFn?: (a: KeyValue<string, V>, b: KeyValue<string, V>) => number):\n      Array<KeyValue<string, V>>;\n  transform<K extends string, V>(\n      input: Record<K, V>|ReadonlyMap<K, V>,\n      compareFn?: (a: KeyValue<K, V>, b: KeyValue<K, V>) => number): Array<KeyValue<K, V>>;\n  transform(\n      input: null|undefined,\n      compareFn?: (a: KeyValue<unknown, unknown>, b: KeyValue<unknown, unknown>) => number): null;\n  transform<K, V>(\n      input: ReadonlyMap<K, V>|null|undefined,\n      compareFn?: (a: KeyValue<K, V>, b: KeyValue<K, V>) => number): Array<KeyValue<K, V>>|null;\n  transform<K extends number, V>(\n      input: Record<K, V>|null|undefined,\n      compareFn?: (a: KeyValue<string, V>, b: KeyValue<string, V>) => number):\n      Array<KeyValue<string, V>>|null;\n  transform<K extends string, V>(\n      input: Record<K, V>|ReadonlyMap<K, V>|null|undefined,\n      compareFn?: (a: KeyValue<K, V>, b: KeyValue<K, V>) => number): Array<KeyValue<K, V>>|null;\n  transform<K, V>(\n      input: undefined|null|{[key: string]: V, [key: number]: V}|ReadonlyMap<K, V>,\n      compareFn: (a: KeyValue<K, V>, b: KeyValue<K, V>) => number = defaultComparator):\n      Array<KeyValue<K, V>>|null {\n    if (!input || (!(input instanceof Map) && typeof input !== 'object')) {\n      return null;\n    }\n\n    if (!this.differ) {\n      // make a differ for whatever type we've been passed in\n      this.differ = this.differs.find(input).create();\n    }\n\n    const differChanges: KeyValueChanges<K, V>|null = this.differ.diff(input as any);\n    const compareFnChanged = compareFn !== this.compareFn;\n\n    if (differChanges) {\n      this.keyValues = [];\n      differChanges.forEachItem((r: KeyValueChangeRecord<K, V>) => {\n        this.keyValues.push(makeKeyValuePair(r.key, r.currentValue!));\n      });\n    }\n    if (differChanges || compareFnChanged) {\n      this.keyValues.sort(compareFn);\n      this.compareFn = compareFn;\n    }\n    return this.keyValues;\n  }\n}\n\nexport function defaultComparator<K, V>(\n    keyValueA: KeyValue<K, V>, keyValueB: KeyValue<K, V>): number {\n  const a = keyValueA.key;\n  const b = keyValueB.key;\n  // if same exit with 0;\n  if (a === b) return 0;\n  // make sure that undefined are at the end of the sort.\n  if (a === undefined) return 1;\n  if (b === undefined) return -1;\n  // make sure that nulls are at the end of the sort.\n  if (a === null) return 1;\n  if (b === null) return -1;\n  if (typeof a == 'string' && typeof b == 'string') {\n    return a < b ? -1 : 1;\n  }\n  if (typeof a == 'number' && typeof b == 'number') {\n    return a - b;\n  }\n  if (typeof a == 'boolean' && typeof b == 'boolean') {\n    return a < b ? -1 : 1;\n  }\n  // `a` and `b` are of different types. Compare their string values.\n  const aString = String(a);\n  const bString = String(b);\n  return aString == bString ? 0 : aString < bString ? -1 : 1;\n}\n"],"names":["AsFormControlPipe","constructor","_logger","transform","value","_valueHash","isBlank","FormControl","this","warn","LOGGER","ValidatorFnFactory","_factoryFn","_args","valueOf","args","AsyncValidatorFnFactory","buildFormGroup","model","FormGroup","modelMetadata","ɵControlsMetadata","groupValidators","ɵValidators","groupAsyncValidators","ɵAsyncValidators","groupArgs","ɵArgs","properties","Object","keys","formGroup","validators","map","validator","filter","itm","asyncValidators","propertyName","metadata","ɵDefaultPropertyMetadata","defaultValue","undefined","control","type","FormArray","controlOptions","Array","isArray","formArray","val","childType","push","disabled","disable","addControl","buildFormModel","FormModelBuilder","_injector","build","injector","PropertiesControlRendererDirective","_viewContainerRef","_componentRef","propertiesMetadata","ngOnChanges","debug","name","ngOnDestroy","clear","createComponent","component","instance","form","initialize","invalidateVisuals","destroy","PropertiesControlsModule","CommonModule","TooltipModule","PropertyTypeControlsModule","FormPipesModule","CastPipesModule","ReactiveFormsModule","NumberInputModule","GetControlsSAPipe","editorMetadata","metaInfo","optionsMetadata","find","modelType","propertiesControls","GetModelSAPipe","PropertiesMetadataSAPipe","propertyExtractor","Error","extract","ContentOptionsPropertiesControlSAComponent","PropertiesControlBase","inject","Injector","formModelBuilder","customComponentsRegister","CustomComponentsRegister","customComponentContentMetadata","usedProperties","usedComponentsForms","_initialize","result","getCustomComponentMeta","contentMetadata","customComponentMetadata","configuration","getConfigurationForComponent","configurableProperties","id","initForms","cmpId","modelName","options","extend","defaultOptions","controls","contentOptions","modelInstance","property","indexOf","console","log","valueChanges","subscribe","currentOpts","patchValue","CustomComponentModel","mapValuesToThis","CustomComponentLayoutEditorMetadata","group","ComponentStylingModel","ComponentStylingPropertiesControlComponent","freeze","KeyValuePipe","differs","keyValues","compareFn","defaultComparator","input","Map","differ","create","differChanges","diff","compareFnChanged","forEachItem","r","key","currentValue","sort","keyValueA","keyValueB","a","b","aString","String","bString","i0"],"sourceRoot":""}