{"version":3,"file":"2554.client.chunk.d56efaad73db1f196162.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../forms/src/modules/formPipes/pipes/asFormControl/asFormControl.pipe.ts","webpack://ng-universal-demo/../../../form/src/components/formComponentBase/formComponentBase.ts","webpack://ng-universal-demo/../../../form/src/misc/tokens.ts","webpack://ng-universal-demo/../../../layout-editor/src/decorators/layoutEditorMetadata/layoutEditorMetadata.decorator.ts","webpack://ng-universal-demo/../../../layout/src/components/layoutComponentBase/layoutComponentBase.ts","webpack://ng-universal-demo/../../../layout/src/extensions/componentStyling/componentStyling.extension.ts","webpack://ng-universal-demo/../../../src/material/radio/radio-module.ts","webpack://ng-universal-demo/../../../material-components/src/dynamicItems/radio/radio.metadata.ts","webpack://ng-universal-demo/../../../src/material/radio/radio.ts","webpack://ng-universal-demo/../src/material/radio/radio.html","webpack://ng-universal-demo/../../../src/material/radio/radio.html","webpack://ng-universal-demo/../../../material-components/src/dynamicItems/radio/radio.component.ts","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/material-components/src/dynamicItems/radio/radio.component.html","webpack://ng-universal-demo/../../../material-components/src/dynamicItems/radio/type.ts","webpack://ng-universal-demo/../../../relations/src/decorators/dynamicOutput/dynamicOutput.decorator.ts","webpack://ng-universal-demo/../../../relations/src/extensions/relationsRegistration/relationsRegistration.extension.ts","webpack://ng-universal-demo/../../../src/misc/dynamicItemExtensionBase.ts","webpack://ng-universal-demo/../../../src/cdk/collections/unique-selection-dispatcher.ts"],"sourcesContent":["import {Inject, Optional, Pipe} from '@angular/core';\nimport {AbstractControl, FormControl} from '@angular/forms';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {isBlank} from '@jscrpt/common';\n\n/**\n * Tries to convert `AbstractControl` to `FormControl`\n */\n@Pipe({name: 'asFormControl'})\nexport class AsFormControlPipe\n{\n    //######################### constructors #########################\n    constructor(@Optional() @Inject(LOGGER) private _logger?: Logger)\n    {\n    }\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Allows casting of `AbstractControl` to `FormControl`\n     * @param value - `AbstractControl` to be cast to `FormControl`\n     * @param _valueHash - Parameter that can be used to change value, indicates that pipe input value has changed\n     */\n    public transform<TModel>(value: AbstractControl<TModel>|null|undefined, _valueHash?: any): FormControl<TModel>|null\n    {\n        if(isBlank(value))\n        {\n            return null;\n        }\n\n        if(value instanceof FormControl)\n        {\n            return value as FormControl<TModel>;\n        }\n\n        this._logger?.warn('Failed to cast AbstractControl to FormControl');\n\n        return null;\n    }\n}","import {ChangeDetectorRef, Directive, ElementRef, Inject, Injector, Input, Optional} from '@angular/core';\nimport {AbstractControl, FormControl, Validators} from '@angular/forms';\nimport {LayoutComponentBase} from '@anglr/dynamic/layout';\nimport {LOGGER, Logger} from '@anglr/common';\nimport {DynamicOutput} from '@anglr/dynamic/relations';\nimport {PromiseOr} from '@jscrpt/common';\nimport {Subscription} from 'rxjs';\n\nimport {FORM_COMPONENT_CONTROL} from '../../misc/tokens';\nimport {FormComponentOptions} from '../../misc/formComponentBase.options';\nimport {FormComponentControlType} from '../../misc/enums';\nimport {getControlForType, getFormControl} from '../../misc/utils';\n\n/**\n * Base component for form component\n */\n@Directive()\nexport abstract class FormComponentBase<TOptions extends FormComponentOptions, TValue = string> extends LayoutComponentBase<TOptions>\n{\n    //######################### private properties #########################\n\n    /**\n     * Indication whether form component is required\n     */\n    private _required: boolean|null|undefined;\n\n    /**\n     * Indication whether form component is disabled\n     */\n    private _disabled: boolean|null|undefined;\n\n    //######################### protected properties #########################\n\n    /**\n     * Form component control\n     */\n    protected control: AbstractControl = new FormControl();\n\n    /**\n     * Form component control subscriptions\n     */\n    protected controlSubscription: Subscription|null|undefined;\n\n    //######################### public properties - inputs #########################\n\n    /**\n     * Form component value\n     */\n    @Input()\n    public set value(value: TValue|null|undefined)\n    {\n        const oldValue = this.value;\n        this.valueOutput = value;\n\n        if (value !== oldValue)\n        {\n            this.control?.patchValue(value);\n        }\n    }\n    public get value(): TValue|null|undefined\n    {\n        return this.valueOutput;\n    }\n\n    /**\n     * Indication whether form component is required\n     */\n    @Input()\n    public set required(value: boolean|null|undefined)\n    {\n        this._required = value;\n\n        if (value === true)\n        {\n            this.control?.addValidators(Validators.required);\n            return;\n        }\n\n        this.control?.removeValidators(Validators.required);\n    }\n    public get required(): boolean|null|undefined\n    {\n        return this._required;\n    }\n\n    /**\n     * Indication whether form component is disabled\n     */\n    @Input()\n    public set disabled(value: boolean|null|undefined)\n    {\n        this._disabled = value;\n\n        if (value === true)\n        {\n            this.control?.disable();\n            return;\n        }\n\n        this.control?.enable();\n    }\n    public get disabled(): boolean|null|undefined\n    {\n        return this._disabled;\n    }\n\n    //######################### public properties - dynamicOutputs #########################\n\n    /**\n     * Form component value\n     */\n    @DynamicOutput()\n    public valueOutput: TValue|null|undefined;\n\n    //######################### constructor #########################\n\n    constructor(_changeDetector: ChangeDetectorRef,\n                _element: ElementRef<HTMLElement>,\n                _injector: Injector,\n                @Inject(FORM_COMPONENT_CONTROL) @Optional() protected _parentControl?: AbstractControl,\n                @Inject(LOGGER) @Optional() _logger?: Logger,)\n    {\n        super(_changeDetector, _element, _injector, _logger);\n    }\n\n    //######################### protected methods - _onOptionsSet implementation #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override onOptionsSet(): PromiseOr<void> \n    {\n        if(!this.options)\n        {\n            return;\n        }\n\n        this.controlSubscription?.unsubscribe();\n        this.controlSubscription = null;\n\n        this.control = this._getFormControl(this.options?.controlName, this._parentControl, FormComponentControlType.FormControl, this.value); \n        this._registerValidations();\n\n        this.controlSubscription = this.control\n            ?.valueChanges\n            ?.subscribe(value => \n            {\n                this.valueOutput = value;\n            });\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Registers component-specific validators\n     */\n    protected _registerValidations(): void\n    {}\n\n    //######################### private methods #########################\n\n    /**\n     * Gets form component control for control name\n     * @param controlName Form component control name\n     * @param parentControl Parent form control\n     * @param defaultControlType Default control type when parent does not exists or not contains control with specified name\n     * @param initValue Initial value for control\n     * @returns Specified type of control\n     */\n    private _getFormControl(controlName: string|null|undefined, parentControl: AbstractControl|undefined, defaultControlType: FormComponentControlType = FormComponentControlType.FormControl, initValue: TValue|null|undefined): AbstractControl\n    {\n        let control = getFormControl(controlName, parentControl, defaultControlType, initValue);\n\n        if (!control)\n        {\n            this.logger?.warn('FormComponentBase: Unable to find control with name {@name}', {name: controlName});\n\n            control = getControlForType(defaultControlType, initValue);\n        }\n\n        if (this.required)\n        {\n            control.addValidators(Validators.required);\n        }\n\n        if (this.disabled)\n        {\n            control.disable();\n        }\n\n        return control;\n    }\n}","import {InjectionToken} from '@angular/core';\nimport {AbstractControl} from '@angular/forms';\n\n/**\n * Injection token for form component control\n */\nexport const FORM_COMPONENT_CONTROL : InjectionToken<AbstractControl> = new InjectionToken<AbstractControl>('FORM_COMPONENT_CONTROL');","import {DynamicClassMetadata, DynamicMetadataLoader} from '@anglr/dynamic';\n\nimport {LayoutEditorMetadataDescriptor, LayoutEditorMetadataType} from '../../decorators';\n\n/**\n * Sets layout editor metadata to class on which is this decorator applied\n * @param metadataLoader - Layout editor metadata loader function used for obtaining metadata\n */\nexport function LayoutEditorMetadata(metadataLoader: DynamicMetadataLoader<LayoutEditorMetadataDescriptor>): ClassDecorator\n{\n    return DynamicClassMetadata<LayoutEditorMetadataDescriptor, LayoutEditorMetadataType>(metadataLoader, 'layoutEditorMetadata');\n}","import {ChangeDetectorRef, Directive, ElementRef, Inject, Injector, OnDestroy, Optional, SimpleChanges} from '@angular/core';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {DynamicItemExtension} from '@anglr/dynamic';\nimport {isEmptyObject, nameof, PromiseOr} from '@jscrpt/common';\n\nimport {LayoutComponent} from '../../interfaces';\n\n/**\n * Base component for layout component\n */\n@Directive()\nexport abstract class LayoutComponentBase<TOptions> implements LayoutComponent<TOptions>, OnDestroy\n{\n    //######################### protected fields #########################\n\n    /**\n     * Array of extensions that are registered for component\n     */\n    protected extensions: DynamicItemExtension<TOptions>[] = [];\n\n    /**\n     * Indication whether initialization was already done\n     */\n    protected initialized: boolean = false;\n\n    /**\n     * Indication whether was component destroyed\n     */\n    protected destroyed: boolean = false;\n\n    //######################### protected properties #########################\n\n    /**\n     * Gets element that is used within extension\n     */\n    protected get element(): ElementRef<HTMLElement>\n    {\n        return this.componentElement;\n    }\n\n    /**\n     * Gets options that are used within extension\n     */\n    protected get extensionsOptions(): any|undefined|null\n    {\n        return this.options;\n    }\n\n    //######################### public properties - implementation of LayoutComponent #########################\n\n    /**\n     * @inheritdoc\n     */\n    public options: TOptions|undefined|null;\n\n    //######################### constructor #########################\n    constructor(protected changeDetector: ChangeDetectorRef,\n                protected componentElement: ElementRef<HTMLElement>,\n                protected injector: Injector,\n                @Inject(LOGGER) @Optional() protected logger?: Logger,)\n    {\n    }\n\n    //######################### public methods - implementation of OnDestroy #########################\n    \n    /**\n     * Called when component is destroyed\n     */\n    public ngOnDestroy(): void\n    {\n        if(this.destroyed)\n        {\n            return;\n        }\n\n        this.destroyed = true;\n\n        for(const ext of this.extensions)\n        {\n            ext.destroy();\n        }\n\n        this.onDestroy();\n    }\n\n    //######################### public methods - implementation of LayoutComponent #########################\n\n    /**\n     * @inheritdoc\n     */\n    public async ngOnInit(): Promise<void>\n    {\n        if(this.initialized)\n        {\n            return;\n        }\n\n        this.initialized = true;\n        const extensionsOptions = this.extensionsOptions;\n        \n        await this.onInit();\n        await this.onOptionsSet();\n\n        if(extensionsOptions)\n        {\n            for(const extension of this.extensions)\n            {\n                await extension.initialize(this.injector, this.element, this);\n            }\n        }\n\n        await this.afterInit();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public async ngOnChanges(changes: SimpleChanges): Promise<void>\n    {\n        //options has changed\n        if(nameof<LayoutComponentBase<TOptions>>('options') in changes)\n        {\n            await this.onOptionsSet();\n\n            const extensionsOptions = this.extensionsOptions;\n\n            //set options in extensions\n            if(extensionsOptions)\n            {\n                for(const extension of this.extensions)\n                {\n                    await extension.optionsChange(extensionsOptions);\n                }\n            }\n\n            if(!this.initialized)\n            {\n                return;\n            }\n\n            await this.onOptionsChange();\n        }\n\n        delete changes[nameof<LayoutComponentBase<TOptions>>('options')];\n\n        if(!isEmptyObject(changes))\n        {\n            this.onChanges(changes);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public registerExtensions(extensions: DynamicItemExtension[]): void\n    {\n        this.extensions = extensions;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public invalidateVisuals(): void\n    {\n        this.changeDetector.detectChanges();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Called on initialzation of component, options are already set\n     */\n    protected onInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called right after initialization finished, including extesions\n     */\n    protected afterInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on change of options, after initialization\n     */\n    protected onOptionsChange(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Occurs when some property changes on component\n     * @param _changes - Changes that occured on component\n     */\n    protected onChanges(_changes: SimpleChanges): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called everytime options are set, after initialization and later\n     */\n    protected onOptionsSet(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called when component is being destroyed\n     */\n    protected onDestroy(): void\n    {\n    }\n}","import {DynamicItemExtension, DynamicItemExtensionBase} from '@anglr/dynamic';\nimport {isPresent} from '@jscrpt/common';\n\nimport {ComponentStylingOptions} from '../../interfaces';\n\n/**\n * Extension that applies common component styling to component\n */\nexport class ComponentStylingExtension extends DynamicItemExtensionBase<ComponentStylingOptions> implements DynamicItemExtension<ComponentStylingOptions>\n{\n    //######################### protected properties #########################\n\n    /**\n     * Value of last css class\n     */\n    protected lastCssClass: string|undefined|null;\n\n    //######################### public methods - overrides #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override onInit(): void\n    {\n        this._applyStyling();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected override onOptionsChange(): void\n    {\n        this._applyStyling();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Applies component styling to element\n     */\n    protected _applyStyling(): void\n    {\n        const options = this.options;\n        const style = this.element?.nativeElement.style;\n\n        if(this.element)\n        {\n            if(isPresent(this.lastCssClass))\n            {\n                for(const cssClass of this.lastCssClass.split(' '))\n                {\n                    if(cssClass)\n                    {\n                        this.element.nativeElement.classList.remove(cssClass);\n                    }\n                }\n            }\n\n            this.lastCssClass = options?.cssClass;\n\n            if(options?.cssClass)\n            {\n                for(const cssClass of options.cssClass.split(' '))\n                {\n                    if(cssClass)\n                    {\n                        this.element?.nativeElement.classList.add(cssClass);\n                    }\n                }\n            }\n        }\n\n        if(isPresent(style))\n        {\n            if(options?.margin)\n            {\n                if(isPresent(options.margin.bottom))\n                {\n                    style.marginBottom = options.margin.bottom;\n                }\n\n                if(isPresent(options.margin.right))\n                {\n                    style.marginRight = options.margin.right;\n                }\n\n                if(isPresent(options.margin.top))\n                {\n                    style.marginTop = options.margin.top;\n                }\n\n                if(isPresent(options.margin.left))\n                {\n                    style.marginLeft = options.margin.left;\n                }\n            }\n\n            if(options?.padding)\n            {\n                if(isPresent(options.padding.bottom))\n                {\n                    style.paddingBottom = options.padding.bottom;\n                }\n\n                if(isPresent(options.padding.right))\n                {\n                    style.paddingRight = options.padding.right;\n                }\n\n                if(isPresent(options.padding.top))\n                {\n                    style.paddingTop = options.padding.top;\n                }\n\n                if(isPresent(options.padding.left))\n                {\n                    style.paddingLeft = options.padding.left;\n                }\n            }\n\n            if(options?.textStyling)\n            {\n                if(isPresent(options.textStyling.fontSize))\n                {\n                    style.fontSize = options.textStyling.fontSize;\n                }\n\n                if(isPresent(options.textStyling.fontWeight))\n                {\n                    style.fontWeight = options.textStyling.fontWeight.toString();\n                }\n            }\n        }\n    }\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {MatRadioButton, MatRadioGroup} from './radio';\n\n@NgModule({\n  imports: [MatRippleModule, MatCommonModule],\n  exports: [MatRadioGroup, MatRadioButton, MatCommonModule],\n  declarations: [MatRadioGroup, MatRadioButton],\n})\nexport class MatRadioModule {}\n","import {DynamicMetadataLoader} from '@anglr/dynamic';\nimport {LayoutEditorMetadataDescriptor} from '@anglr/dynamic/layout-editor';\nimport {RelationsEditorMetadataDescriptor} from '@anglr/dynamic/relations-editor';\n\nimport {MaterialRadioComponentOptions} from './radio.options';\n\n/**\n * Material radio layout metadata loader\n */\nexport const MaterialRadioLayoutMetadataLoader: DynamicMetadataLoader<LayoutEditorMetadataDescriptor<MaterialRadioComponentOptions>> = async () => new (await import('./metadata/radio.layoutMetadata')).MaterialRadioLayoutEditorMetadata();\n\n/**\n * Material radio relations metadata loader\n */\nexport const MaterialRadioRelationsMetadataLoader: DynamicMetadataLoader<RelationsEditorMetadataDescriptor> = async () => new (await import('./metadata/radio.relationsMetadata')).MaterialRadioRelationsEditorMetadata();","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {BooleanInput, coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {UniqueSelectionDispatcher} from '@angular/cdk/collections';\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {\n  CanDisableRipple,\n  HasTabIndex,\n  mixinDisableRipple,\n  mixinTabIndex,\n  ThemePalette,\n} from '@angular/material/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\n\nexport interface MatRadioDefaultOptions {\n  color: ThemePalette;\n}\n\nexport const MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken<MatRadioDefaultOptions>(\n  'mat-radio-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\nexport function MAT_RADIO_DEFAULT_OPTIONS_FACTORY(): MatRadioDefaultOptions {\n  return {\n    color: 'accent',\n  };\n}\n\n// Increasing integer for generating unique ids for radio components.\nlet nextUniqueId = 0;\n\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * @docs-private\n */\nexport const MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatRadioGroup),\n  multi: true,\n};\n\n/** Change event object emitted by MatRadio and MatRadioGroup. */\nexport class MatRadioChange {\n  constructor(\n    /** The MatRadioButton that emits the change event. */\n    public source: _MatRadioButtonBase,\n    /** The value of the MatRadioButton. */\n    public value: any,\n  ) {}\n}\n\n/**\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_RADIO_GROUP = new InjectionToken<_MatRadioGroupBase<_MatRadioButtonBase>>(\n  'MatRadioGroup',\n);\n\n/**\n * Base class with all of the `MatRadioGroup` functionality.\n * @docs-private\n */\n@Directive()\nexport abstract class _MatRadioGroupBase<T extends _MatRadioButtonBase>\n  implements AfterContentInit, ControlValueAccessor\n{\n  /** Selected value for the radio group. */\n  private _value: any = null;\n\n  /** The HTML name attribute applied to radio buttons in this group. */\n  private _name: string = `mat-radio-group-${nextUniqueId++}`;\n\n  /** The currently selected radio button. Should match value. */\n  private _selected: T | null = null;\n\n  /** Whether the `value` has been set to its initial value. */\n  private _isInitialized: boolean = false;\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  private _labelPosition: 'before' | 'after' = 'after';\n\n  /** Whether the radio group is disabled. */\n  private _disabled: boolean = false;\n\n  /** Whether the radio group is required. */\n  private _required: boolean = false;\n\n  /** The method to be called in order to update ngModel */\n  _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  /**\n   * onTouch function registered via registerOnTouch (ControlValueAccessor).\n   * @docs-private\n   */\n  onTouched: () => any = () => {};\n\n  /**\n   * Event emitted when the group value changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * a radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** Child radio buttons. */\n  abstract _radios: QueryList<T>;\n\n  /** Theme color for all of the radio buttons in the group. */\n  @Input() color: ThemePalette;\n\n  /** Name of the radio button group. All radio buttons inside this group will use this name. */\n  @Input()\n  get name(): string {\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    this._updateRadioButtonNames();\n  }\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition;\n  }\n  set labelPosition(v) {\n    this._labelPosition = v === 'before' ? 'before' : 'after';\n    this._markRadiosForCheck();\n  }\n\n  /**\n   * Value for the radio-group. Should equal the value of the selected radio button if there is\n   * a corresponding radio button with a matching value. If there is not such a corresponding\n   * radio button, this value persists to be applied in case a new radio button is added with a\n   * matching value.\n   */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    if (this._value !== newValue) {\n      // Set this before proceeding to ensure no circular loop occurs with selection.\n      this._value = newValue;\n\n      this._updateSelectedRadioFromValue();\n      this._checkSelectedRadioButton();\n    }\n  }\n\n  _checkSelectedRadioButton() {\n    if (this._selected && !this._selected.checked) {\n      this._selected.checked = true;\n    }\n  }\n\n  /**\n   * The currently selected radio button. If set to a new radio button, the radio group value\n   * will be updated to match the new selected button.\n   */\n  @Input()\n  get selected() {\n    return this._selected;\n  }\n  set selected(selected: T | null) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n    this._checkSelectedRadioButton();\n  }\n\n  /** Whether the radio group is disabled */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  /** Whether the radio group is required */\n  @Input()\n  get required(): boolean {\n    return this._required;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n\n  constructor(private _changeDetector: ChangeDetectorRef) {}\n\n  /**\n   * Initialize properties once content children are available.\n   * This allows us to propagate relevant attributes to associated buttons.\n   */\n  ngAfterContentInit() {\n    // Mark this component as initialized in AfterContentInit because the initial value can\n    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n    // NgModel occurs *after* the OnInit of the MatRadioGroup.\n    this._isInitialized = true;\n  }\n\n  /**\n   * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n   * radio buttons upon their blur.\n   */\n  _touch() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n\n  private _updateRadioButtonNames(): void {\n    if (this._radios) {\n      this._radios.forEach(radio => {\n        radio.name = this.name;\n        radio._markForCheck();\n      });\n    }\n  }\n\n  /** Updates the `selected` radio button from the internal _value state. */\n  private _updateSelectedRadioFromValue(): void {\n    // If the value already matches the selected radio, do nothing.\n    const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n\n    if (this._radios && !isAlreadySelected) {\n      this._selected = null;\n      this._radios.forEach(radio => {\n        radio.checked = this.value === radio.value;\n        if (radio.checked) {\n          this._selected = radio;\n        }\n      });\n    }\n  }\n\n  /** Dispatch change event with current selection and group value. */\n  _emitChangeEvent(): void {\n    if (this._isInitialized) {\n      this.change.emit(new MatRadioChange(this._selected!, this._value));\n    }\n  }\n\n  _markRadiosForCheck() {\n    if (this._radios) {\n      this._radios.forEach(radio => radio._markForCheck());\n    }\n  }\n\n  /**\n   * Sets the model value. Implemented as part of ControlValueAccessor.\n   * @param value\n   */\n  writeValue(value: any) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n\n  /**\n   * Registers a callback to be triggered when the model value changes.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  /**\n   * Registers a callback to be triggered when the control is touched.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnTouched(fn: any) {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n   * @param isDisabled Whether the control should be disabled.\n   */\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n    this._changeDetector.markForCheck();\n  }\n}\n\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\n@Directive({\n  selector: 'mat-radio-group',\n  exportAs: 'matRadioGroup',\n  providers: [\n    MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\n    {provide: MAT_RADIO_GROUP, useExisting: MatRadioGroup},\n  ],\n  host: {\n    'role': 'radiogroup',\n    'class': 'mat-radio-group',\n  },\n})\nexport class MatRadioGroup extends _MatRadioGroupBase<MatRadioButton> {\n  @ContentChildren(forwardRef(() => MatRadioButton), {descendants: true})\n  _radios: QueryList<MatRadioButton>;\n}\n\n// Boilerplate for applying mixins to MatRadioButton.\n/** @docs-private */\nabstract class MatRadioButtonBase {\n  // Since the disabled property is manually defined for the MatRadioButton and isn't set up in\n  // the mixin base class. To be able to use the tabindex mixin, a disabled property must be\n  // defined to properly work.\n  abstract disabled: boolean;\n  constructor(public _elementRef: ElementRef) {}\n}\n\nconst _MatRadioButtonMixinBase = mixinDisableRipple(mixinTabIndex(MatRadioButtonBase));\n\n/**\n * Base class with all of the `MatRadioButton` functionality.\n * @docs-private\n */\n@Directive()\nexport abstract class _MatRadioButtonBase\n  extends _MatRadioButtonMixinBase\n  implements OnInit, AfterViewInit, DoCheck, OnDestroy, CanDisableRipple, HasTabIndex\n{\n  private _uniqueId: string = `mat-radio-${++nextUniqueId}`;\n\n  /** The unique ID for the radio button. */\n  @Input() id: string = this._uniqueId;\n\n  /** Analog to HTML 'name' attribute used to group radios for unique selection. */\n  @Input() name: string;\n\n  /** Used to set the 'aria-label' attribute on the underlying input element. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** The 'aria-labelledby' attribute takes precedence as the element's text alternative. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** The 'aria-describedby' attribute is read after the element's label and field type. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  /** Whether this radio button is checked. */\n  @Input()\n  get checked(): boolean {\n    return this._checked;\n  }\n  set checked(value: BooleanInput) {\n    const newCheckedState = coerceBooleanProperty(value);\n    if (this._checked !== newCheckedState) {\n      this._checked = newCheckedState;\n      if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n        this.radioGroup.selected = this;\n      } else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n        // When unchecking the selected radio button, update the selected radio\n        // property on the group.\n        this.radioGroup.selected = null;\n      }\n\n      if (newCheckedState) {\n        // Notify all radio buttons with the same name to un-check.\n        this._radioDispatcher.notify(this.id, this.name);\n      }\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** The value of this radio button. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(value: any) {\n    if (this._value !== value) {\n      this._value = value;\n      if (this.radioGroup !== null) {\n        if (!this.checked) {\n          // Update checked when the value changed to match the radio group's value\n          this.checked = this.radioGroup.value === value;\n        }\n        if (this.checked) {\n          this.radioGroup.selected = this;\n        }\n      }\n    }\n  }\n\n  /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n  }\n  set labelPosition(value) {\n    this._labelPosition = value;\n  }\n  private _labelPosition: 'before' | 'after';\n\n  /** Whether the radio button is disabled. */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n  }\n  set disabled(value: BooleanInput) {\n    this._setDisabled(coerceBooleanProperty(value));\n  }\n\n  /** Whether the radio button is required. */\n  @Input()\n  get required(): boolean {\n    return this._required || (this.radioGroup && this.radioGroup.required);\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n\n  /** Theme color of the radio button. */\n  @Input()\n  get color(): ThemePalette {\n    // As per Material design specifications the selection control radio should use the accent color\n    // palette by default. https://material.io/guidelines/components/selection-controls.html\n    return (\n      this._color ||\n      (this.radioGroup && this.radioGroup.color) ||\n      (this._providerOverride && this._providerOverride.color) ||\n      'accent'\n    );\n  }\n  set color(newValue: ThemePalette) {\n    this._color = newValue;\n  }\n  private _color: ThemePalette;\n\n  /**\n   * Event emitted when the checked state of this radio button changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * the radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** The parent radio group. May or may not be present. */\n  radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>;\n\n  /** ID of the native input element inside `<mat-radio-button>` */\n  get inputId(): string {\n    return `${this.id || this._uniqueId}-input`;\n  }\n\n  /** Whether this radio is checked. */\n  private _checked: boolean = false;\n\n  /** Whether this radio is disabled. */\n  private _disabled: boolean;\n\n  /** Whether this radio is required. */\n  private _required: boolean;\n\n  /** Value assigned to this radio. */\n  private _value: any = null;\n\n  /** Unregister function for _radioDispatcher */\n  private _removeUniqueSelectionListener: () => void = () => {};\n\n  /** Previous value of the input's tabindex. */\n  private _previousTabIndex: number | undefined;\n\n  /** The native `<input type=radio>` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** Whether animations are disabled. */\n  _noopAnimations: boolean;\n\n  constructor(\n    radioGroup: _MatRadioGroupBase<_MatRadioButtonBase>,\n    elementRef: ElementRef,\n    protected _changeDetector: ChangeDetectorRef,\n    private _focusMonitor: FocusMonitor,\n    private _radioDispatcher: UniqueSelectionDispatcher,\n    animationMode?: string,\n    private _providerOverride?: MatRadioDefaultOptions,\n    tabIndex?: string,\n  ) {\n    super(elementRef);\n\n    // Assertions. Ideally these should be stripped out by the compiler.\n    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n    this.radioGroup = radioGroup;\n    this._noopAnimations = animationMode === 'NoopAnimations';\n\n    if (tabIndex) {\n      this.tabIndex = coerceNumberProperty(tabIndex, 0);\n    }\n\n    this._removeUniqueSelectionListener = _radioDispatcher.listen((id: string, name: string) => {\n      if (id !== this.id && name === this.name) {\n        this.checked = false;\n      }\n    });\n  }\n\n  /** Focuses the radio button. */\n  focus(options?: FocusOptions, origin?: FocusOrigin): void {\n    if (origin) {\n      this._focusMonitor.focusVia(this._inputElement, origin, options);\n    } else {\n      this._inputElement.nativeElement.focus(options);\n    }\n  }\n\n  /**\n   * Marks the radio button as needing checking for change detection.\n   * This method is exposed because the parent radio group will directly\n   * update bound properties of the radio button.\n   */\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update radio button's status\n    this._changeDetector.markForCheck();\n  }\n\n  ngOnInit() {\n    if (this.radioGroup) {\n      // If the radio is inside a radio group, determine if it should be checked\n      this.checked = this.radioGroup.value === this._value;\n\n      if (this.checked) {\n        this.radioGroup.selected = this;\n      }\n\n      // Copy name from parent radio group\n      this.name = this.radioGroup.name;\n    }\n  }\n\n  ngDoCheck(): void {\n    this._updateTabIndex();\n  }\n\n  ngAfterViewInit() {\n    this._updateTabIndex();\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin && this.radioGroup) {\n        this.radioGroup._touch();\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    this._removeUniqueSelectionListener();\n  }\n\n  /** Dispatch change event with current value. */\n  private _emitChangeEvent(): void {\n    this.change.emit(new MatRadioChange(this, this._value));\n  }\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  _onInputClick(event: Event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `radio-button` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n\n  /** Triggered when the radio button receives an interaction from the user. */\n  _onInputInteraction(event: Event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n\n    if (!this.checked && !this.disabled) {\n      const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n      this.checked = true;\n      this._emitChangeEvent();\n\n      if (this.radioGroup) {\n        this.radioGroup._controlValueAccessorChangeFn(this.value);\n        if (groupValueChanged) {\n          this.radioGroup._emitChangeEvent();\n        }\n      }\n    }\n  }\n\n  /** Sets the disabled state and marks for check if a change occurred. */\n  protected _setDisabled(value: boolean) {\n    if (this._disabled !== value) {\n      this._disabled = value;\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** Gets the tabindex for the underlying input element. */\n  private _updateTabIndex() {\n    const group = this.radioGroup;\n    let value: number;\n\n    // Implement a roving tabindex if the button is inside a group. For most cases this isn't\n    // necessary, because the browser handles the tab order for inputs inside a group automatically,\n    // but we need an explicitly higher tabindex for the selected button in order for things like\n    // the focus trap to pick it up correctly.\n    if (!group || !group.selected || this.disabled) {\n      value = this.tabIndex;\n    } else {\n      value = group.selected === this ? this.tabIndex : -1;\n    }\n\n    if (value !== this._previousTabIndex) {\n      // We have to set the tabindex directly on the DOM node, because it depends on\n      // the selected state which is prone to \"changed after checked errors\".\n      const input: HTMLInputElement | undefined = this._inputElement?.nativeElement;\n\n      if (input) {\n        input.setAttribute('tabindex', value + '');\n        this._previousTabIndex = value;\n      }\n    }\n  }\n}\n\n/**\n * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\n */\n@Component({\n  selector: 'mat-radio-button',\n  templateUrl: 'radio.html',\n  styleUrls: ['radio.css'],\n  inputs: ['disableRipple', 'tabIndex'],\n  encapsulation: ViewEncapsulation.None,\n  exportAs: 'matRadioButton',\n  host: {\n    'class': 'mat-radio-button',\n    '[class.mat-radio-checked]': 'checked',\n    '[class.mat-radio-disabled]': 'disabled',\n    '[class._mat-animation-noopable]': '_noopAnimations',\n    '[class.mat-primary]': 'color === \"primary\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    // Needs to be removed since it causes some a11y issues (see #21266).\n    '[attr.tabindex]': 'null',\n    '[attr.id]': 'id',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[attr.aria-describedby]': 'null',\n    // Note: under normal conditions focus shouldn't land on this element, however it may be\n    // programmatically set, for example inside of a focus trap, in this case we want to forward\n    // the focus to the native element.\n    '(focus)': '_inputElement.nativeElement.focus()',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatRadioButton extends _MatRadioButtonBase {\n  constructor(\n    @Optional() @Inject(MAT_RADIO_GROUP) radioGroup: MatRadioGroup,\n    elementRef: ElementRef,\n    changeDetector: ChangeDetectorRef,\n    focusMonitor: FocusMonitor,\n    radioDispatcher: UniqueSelectionDispatcher,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional()\n    @Inject(MAT_RADIO_DEFAULT_OPTIONS)\n    providerOverride?: MatRadioDefaultOptions,\n    @Attribute('tabindex') tabIndex?: string,\n  ) {\n    super(\n      radioGroup,\n      elementRef,\n      changeDetector,\n      focusMonitor,\n      radioDispatcher,\n      animationMode,\n      providerOverride,\n      tabIndex,\n    );\n  }\n}\n",null,"<!-- TODO(jelbourn): render the radio on either side of the content -->\n<!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. -->\n<label [attr.for]=\"inputId\" class=\"mat-radio-label\" #label>\n  <!-- The actual 'radio' part of the control. -->\n  <span class=\"mat-radio-container\">\n    <span class=\"mat-radio-outer-circle\"></span>\n    <span class=\"mat-radio-inner-circle\"></span>\n    <input #input class=\"mat-radio-input\" type=\"radio\"\n        [id]=\"inputId\"\n        [checked]=\"checked\"\n        [disabled]=\"disabled\"\n        [attr.name]=\"name\"\n        [attr.value]=\"value\"\n        [required]=\"required\"\n        [attr.aria-label]=\"ariaLabel\"\n        [attr.aria-labelledby]=\"ariaLabelledby\"\n        [attr.aria-describedby]=\"ariaDescribedby\"\n        (change)=\"_onInputInteraction($event)\"\n        (click)=\"_onInputClick($event)\">\n\n    <!-- The ripple comes after the input so that we can target it with a CSS\n         sibling selector when the input is focused. -->\n    <span mat-ripple class=\"mat-radio-ripple mat-focus-indicator\"\n         [matRippleTrigger]=\"label\"\n         [matRippleDisabled]=\"_isRippleDisabled()\"\n         [matRippleCentered]=\"true\"\n         [matRippleRadius]=\"20\"\n         [matRippleAnimation]=\"{enterDuration: _noopAnimations ? 0 : 150}\">\n\n      <span class=\"mat-ripple-element mat-radio-persistent-ripple\"></span>\n    </span>\n  </span>\n\n  <!-- The label content for radio control. -->\n  <span class=\"mat-radio-label-content\" [class.mat-radio-label-before]=\"labelPosition == 'before'\">\n    <!-- Add an invisible span so JAWS can read the label -->\n    <span style=\"display:none\">&nbsp;</span>\n    <ng-content></ng-content>\n  </span>\n</label>\n","import {Component, ChangeDetectionStrategy} from '@angular/core';\nimport {ReactiveFormsModule} from '@angular/forms';\nimport {MatRadioModule} from '@angular/material/radio';\nimport {LayoutEditorMetadata} from '@anglr/dynamic/layout-editor';\nimport {CastPipesModule, HostDisplayBlockStyle} from '@anglr/common';\nimport {FormPipesModule} from '@anglr/common/forms';\nimport {FormComponent, FormComponentBase, FormComponentControlSAPipe} from '@anglr/dynamic/form';\nimport {RelationsEditorMetadata} from '@anglr/dynamic/relations-editor';\n\nimport {MaterialRadioLayoutMetadataLoader, MaterialRadioRelationsMetadataLoader} from './radio.metadata';\nimport {MaterialRadioComponentOptions} from './radio.options';\n\n/**\n * Component used for displaying material radio\n */\n@Component(\n{\n    selector: 'material-radio',\n    templateUrl: 'radio.component.html',\n    styles: [HostDisplayBlockStyle],\n    standalone: true,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    imports:\n    [\n        FormPipesModule,\n        CastPipesModule,\n        FormComponentControlSAPipe,\n        ReactiveFormsModule,\n        MatRadioModule,\n    ]\n})\n@RelationsEditorMetadata(MaterialRadioRelationsMetadataLoader)\n@LayoutEditorMetadata(MaterialRadioLayoutMetadataLoader)\nexport class MaterialRadioSAComponent extends FormComponentBase<MaterialRadioComponentOptions> implements FormComponent<MaterialRadioComponentOptions>\n{}",null,"import {ComponentStylingExtension} from '@anglr/dynamic/layout';\nimport {RelationsRegistrationExtension} from '@anglr/dynamic/relations';\n\nimport {MaterialRadioSAComponent} from './radio.component';\n\n\nexport default MaterialRadioSAComponent;\n\nexport const extensions = [ComponentStylingExtension, RelationsRegistrationExtension];","import {Subject} from 'rxjs';\n\n/**\n * Creates dynamic output for property\n */\nexport function DynamicOutput(): PropertyDecorator\n{\n    return function(target: any, propertyKey: string|symbol)\n    {\n        const prop = propertyKey as string;\n\n        Object.defineProperty(target,\n                              `${prop}Change`,\n                              {\n                                  get: function()\n                                  {\n                                      if(!this[`ɵ${prop}Change`])\n                                      {\n                                          this[`ɵ${prop}Change`] = new Subject<void>();\n                                      }\n\n                                      return this[`ɵ${prop}Change`];\n                                  }\n                              });\n\n        Object.defineProperty(target,\n                              prop,\n                              {\n                                  get: function()\n                                  {\n                                      return this[`ɵ${prop}`];\n                                  },\n                                  set: function(value:any)\n                                  {\n                                      this[`ɵ${prop}`] = value;\n                                      this[`${prop}Change`].next();\n                                  }\n                              });\n    };\n}","import {DynamicItemExtension, DynamicItemExtensionBase} from '@anglr/dynamic';\n\nimport {RelationsComponent} from '../../interfaces';\nimport {RelationsComponentManager, RelationsProcessor} from '../../services';\n\n/**\n * Extension that allows registration of component for relations\n */\nexport class RelationsRegistrationExtension extends DynamicItemExtensionBase<unknown, RelationsComponent> implements DynamicItemExtension<unknown, RelationsComponent>\n{\n    //######################### protected properties #########################\n\n    /**\n     * Instance of relations processor\n     */\n    protected relationsProcessor: RelationsProcessor|null = null;\n\n    /**\n     * Instance of component manager\n     */\n    protected componentManager: RelationsComponentManager|null = null;\n\n    //######################### public methods - overrides #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override async onInit(): Promise<void>\n    {\n        if(!this.injector || !this.metadata || !this.instance)\n        {\n            return;\n        }\n\n        this.relationsProcessor ??= this.injector.get(RelationsProcessor, null);\n        this.componentManager ??= this.injector.get(RelationsComponentManager, null);\n\n        if(!this.relationsProcessor || !this.componentManager)\n        {\n            return;\n        }\n\n        this.componentManager.registerComponent(this.metadata.id, this.instance);\n        await this.relationsProcessor.initialized;\n        this.relationsProcessor.updateRelations(this.metadata.id);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected override onDestroy(): void\n    {\n        if(!this.relationsProcessor || !this.componentManager || !this.metadata)\n        {\n            return;\n        }\n\n        this.relationsProcessor.destroyComponent(this.metadata.id);\n        this.componentManager.unregisterComponent(this.metadata.id);\n    }\n}","import {ElementRef, Injector} from '@angular/core';\nimport {PromiseOr} from '@jscrpt/common';\n\nimport {DynamicItem, DynamicItemExtension, DynamicItemMetadata} from '../interfaces';\n\n/**\n * Dynamic item extension base class\n */\nexport abstract class DynamicItemExtensionBase<TOptions = unknown, TInstance extends DynamicItem = any> implements DynamicItemExtension<TOptions, TInstance>\n{\n    //######################### protected fields #########################\n\n    /**\n     * Injector from extended component\n     */\n    protected injector?: Injector;\n\n    /**\n     * Element that could be extended\n     */\n    protected element?: ElementRef<HTMLElement>;\n\n    /**\n     * Options that stores extension and component data\n     */\n    protected options?: TOptions;\n\n    /**\n     * Instance of dynamic item that is being extended\n     */\n    protected instance?: TInstance;\n\n    /**\n     * Indication whether was extension initialized\n     */\n    protected initialized: boolean = false;\n\n    //######################### constructor #########################\n    constructor(protected metadata: DynamicItemMetadata)\n    {\n    }\n\n    //######################### public methods - implementation of DynamicItemExtension #########################\n\n    /**\n     * @inheritdoc\n     */\n    public async initialize(injector: Injector, element: ElementRef<HTMLElement>, instance: TInstance): Promise<void>\n    {\n        this.initialized = true;\n\n        this.injector = injector;\n        this.element = element;\n        this.instance = instance;\n\n        await this.onInit();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public async optionsChange(options: TOptions): Promise<void>\n    {\n        this.options = options;\n\n        if(!this.initialized)\n        {\n            return;\n        }\n\n        await this.onOptionsChange();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public destroy(): void\n    {\n        this.onDestroy();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Called on initialization of component\n     */\n    protected onInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on change of options of component\n     */\n    protected onOptionsChange(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on destruction of component\n     */\n    protected onDestroy(): void\n    {\n    }\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, OnDestroy} from '@angular/core';\n\n// Users of the Dispatcher never need to see this type, but TypeScript requires it to be exported.\nexport type UniqueSelectionDispatcherListener = (id: string, name: string) => void;\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\n@Injectable({providedIn: 'root'})\nexport class UniqueSelectionDispatcher implements OnDestroy {\n  private _listeners: UniqueSelectionDispatcherListener[] = [];\n\n  /**\n   * Notify other items that selection for the given name has been set.\n   * @param id ID of the item.\n   * @param name Name of the item.\n   */\n  notify(id: string, name: string) {\n    for (let listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n\n  /**\n   * Listen for future changes to item selection.\n   * @return Function used to deregister listener\n   */\n  listen(listener: UniqueSelectionDispatcherListener): () => void {\n    this._listeners.push(listener);\n    return () => {\n      this._listeners = this._listeners.filter((registered: UniqueSelectionDispatcherListener) => {\n        return listener !== registered;\n      });\n    };\n  }\n\n  ngOnDestroy() {\n    this._listeners = [];\n  }\n}\n"],"names":["AsFormControlPipe","constructor","_logger","transform","value","_valueHash","isBlank","FormControl","this","warn","LOGGER","FormComponentBase","LayoutComponentBase","_changeDetector","_element","_injector","_parentControl","super","control","oldValue","valueOutput","patchValue","required","_required","removeValidators","Validators","addValidators","disabled","_disabled","enable","disable","onOptionsSet","options","controlSubscription","unsubscribe","_getFormControl","controlName","FormComponentControlType","_registerValidations","valueChanges","subscribe","parentControl","defaultControlType","initValue","getFormControl","logger","name","getControlForType","i0","FORM_COMPONENT_CONTROL","__decorate","DynamicOutput","InjectionToken","LayoutEditorMetadata","metadataLoader","DynamicClassMetadata","changeDetector","componentElement","injector","extensions","initialized","destroyed","element","extensionsOptions","ngOnDestroy","ext","destroy","onDestroy","ngOnInit","onInit","extension","initialize","afterInit","ngOnChanges","changes","nameof","optionsChange","onOptionsChange","isEmptyObject","onChanges","registerExtensions","invalidateVisuals","detectChanges","_changes","ComponentStylingExtension","DynamicItemExtensionBase","_applyStyling","style","nativeElement","isPresent","lastCssClass","cssClass","split","classList","remove","add","margin","bottom","marginBottom","right","marginRight","top","marginTop","left","marginLeft","padding","paddingBottom","paddingRight","paddingTop","paddingLeft","textStyling","fontSize","fontWeight","toString","MatRadioModule","MatRippleModule","MatCommonModule","MaterialRadioLayoutMetadataLoader","MaterialRadioLayoutEditorMetadata","MaterialRadioRelationsMetadataLoader","MaterialRadioRelationsEditorMetadata","MAT_RADIO_DEFAULT_OPTIONS","providedIn","factory","color","nextUniqueId","MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","MatRadioGroup","multi","MatRadioChange","source","MAT_RADIO_GROUP","_MatRadioGroupBase","_value","_name","_selected","_isInitialized","_labelPosition","_controlValueAccessorChangeFn","onTouched","change","EventEmitter","_updateRadioButtonNames","labelPosition","v","_markRadiosForCheck","newValue","_updateSelectedRadioFromValue","_checkSelectedRadioButton","checked","selected","coerceBooleanProperty","ngAfterContentInit","_touch","_radios","forEach","radio","_markForCheck","isAlreadySelected","_emitChangeEvent","emit","writeValue","markForCheck","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","MatRadioButton","_MatRadioButtonMixinBase","mixinDisableRipple","mixinTabIndex","_elementRef","_MatRadioButtonBase","radioGroup","elementRef","_focusMonitor","_radioDispatcher","animationMode","_providerOverride","tabIndex","_uniqueId","id","_checked","_removeUniqueSelectionListener","_noopAnimations","coerceNumberProperty","listen","newCheckedState","notify","_setDisabled","_color","inputId","focus","origin","focusVia","_inputElement","ngDoCheck","_updateTabIndex","ngAfterViewInit","monitor","focusOrigin","stopMonitoring","_isRippleDisabled","disableRipple","_onInputClick","event","stopPropagation","_onInputInteraction","groupValueChanged","group","_previousTabIndex","input","setAttribute","focusMonitor","radioDispatcher","providerOverride","ANIMATION_MODULE_TYPE","i3","MaterialRadioSAComponent","FormPipesModule","i1","CastPipesModule","i2","ReactiveFormsModule","i4","RelationsEditorMetadata","RelationsRegistrationExtension","target","propertyKey","prop","Object","defineProperty","get","Subject","set","next","relationsProcessor","componentManager","metadata","instance","RelationsProcessor","RelationsComponentManager","registerComponent","updateRelations","destroyComponent","unregisterComponent","UniqueSelectionDispatcher","_listeners","listener","push","filter","registered"],"sourceRoot":""}