{"version":3,"file":"8357.client.chunk.e9108f4b4f2b4063a168.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../src/cdk/a11y/key-manager/list-key-manager.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/class_map_interpolation.ts","webpack://ng-universal-demo/../../../src/material/core/selection/pseudo-checkbox/pseudo-checkbox-module.ts","webpack://ng-universal-demo/../../../src/material/core/option/index.ts","webpack://ng-universal-demo/../../../src/cdk/a11y/key-manager/activedescendant-key-manager.ts","webpack://ng-universal-demo/../../../src/cdk/collections/selection-model.ts","webpack://ng-universal-demo/../../../src/material/core/option/option-parent.ts","webpack://ng-universal-demo/../../../src/material/core/option/optgroup.ts","webpack://ng-universal-demo/../src/material/core/option/optgroup.html","webpack://ng-universal-demo/../../../src/material/core/selection/pseudo-checkbox/pseudo-checkbox.ts","webpack://ng-universal-demo/../src/material/core/option/option.html","webpack://ng-universal-demo/../../../src/material/core/option/option.ts","webpack://ng-universal-demo/../../../src/material/core/option/option.html","webpack://ng-universal-demo/../../../src/material/select/select-animations.ts","webpack://ng-universal-demo/../../../src/cdk/a11y/live-announcer/live-announcer-tokens.ts","webpack://ng-universal-demo/../../../src/cdk/a11y/live-announcer/live-announcer.ts","webpack://ng-universal-demo/../src/material/select/select.html","webpack://ng-universal-demo/../../../src/material/select/select.ts","webpack://ng-universal-demo/../../../src/material/select/select.html","webpack://ng-universal-demo/../../../src/material/select/select-module.ts","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/es2020/material-components/src/dynamicItems/select/select.metadata.js","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/es2020/material-components/src/dynamicItems/select/select.component.js","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/es2020/material-components/src/dynamicItems/select/type.js"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {QueryList} from '@angular/core';\nimport {Subject, Subscription} from 'rxjs';\nimport {\n  UP_ARROW,\n  DOWN_ARROW,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  TAB,\n  A,\n  Z,\n  ZERO,\n  NINE,\n  hasModifierKey,\n  HOME,\n  END,\n} from '@angular/cdk/keycodes';\nimport {debounceTime, filter, map, tap} from 'rxjs/operators';\n\n/** This interface is for items that can be passed to a ListKeyManager. */\nexport interface ListKeyManagerOption {\n  /** Whether the option is disabled. */\n  disabled?: boolean;\n\n  /** Gets the label for this option. */\n  getLabel?(): string;\n}\n\n/** Modifier keys handled by the ListKeyManager. */\nexport type ListKeyManagerModifierKey = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends ListKeyManagerOption> {\n  private _activeItemIndex = -1;\n  private _activeItem: T | null = null;\n  private _wrap = false;\n  private readonly _letterKeyStream = new Subject<string>();\n  private _typeaheadSubscription = Subscription.EMPTY;\n  private _vertical = true;\n  private _horizontal: 'ltr' | 'rtl' | null;\n  private _allowedModifierKeys: ListKeyManagerModifierKey[] = [];\n  private _homeAndEnd = false;\n\n  /**\n   * Predicate function that can be used to check whether an item should be skipped\n   * by the key manager. By default, disabled items are skipped.\n   */\n  private _skipPredicateFn = (item: T) => item.disabled;\n\n  // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n  private _pressedLetters: string[] = [];\n\n  constructor(private _items: QueryList<T> | T[]) {\n    // We allow for the items to be an array because, in some cases, the consumer may\n    // not have access to a QueryList of the items they want to manage (e.g. when the\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (_items instanceof QueryList) {\n      _items.changes.subscribe((newItems: QueryList<T>) => {\n        if (this._activeItem) {\n          const itemArray = newItems.toArray();\n          const newIndex = itemArray.indexOf(this._activeItem);\n\n          if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n            this._activeItemIndex = newIndex;\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Stream that emits any time the TAB key is pressed, so components can react\n   * when focus is shifted off of the list.\n   */\n  readonly tabOut = new Subject<void>();\n\n  /** Stream that emits whenever the active item of the list manager changes. */\n  readonly change = new Subject<number>();\n\n  /**\n   * Sets the predicate function that determines which items should be skipped by the\n   * list key manager.\n   * @param predicate Function that determines whether the given item should be skipped.\n   */\n  skipPredicate(predicate: (item: T) => boolean): this {\n    this._skipPredicateFn = predicate;\n    return this;\n  }\n\n  /**\n   * Configures wrapping mode, which determines whether the active item will wrap to\n   * the other end of list when there are no more items in the given direction.\n   * @param shouldWrap Whether the list should wrap when reaching the end.\n   */\n  withWrap(shouldWrap = true): this {\n    this._wrap = shouldWrap;\n    return this;\n  }\n\n  /**\n   * Configures whether the key manager should be able to move the selection vertically.\n   * @param enabled Whether vertical selection should be enabled.\n   */\n  withVerticalOrientation(enabled: boolean = true): this {\n    this._vertical = enabled;\n    return this;\n  }\n\n  /**\n   * Configures the key manager to move the selection horizontally.\n   * Passing in `null` will disable horizontal movement.\n   * @param direction Direction in which the selection can be moved.\n   */\n  withHorizontalOrientation(direction: 'ltr' | 'rtl' | null): this {\n    this._horizontal = direction;\n    return this;\n  }\n\n  /**\n   * Modifier keys which are allowed to be held down and whose default actions will be prevented\n   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n   */\n  withAllowedModifierKeys(keys: ListKeyManagerModifierKey[]): this {\n    this._allowedModifierKeys = keys;\n    return this;\n  }\n\n  /**\n   * Turns on typeahead mode which allows users to set the active item by typing.\n   * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n   */\n  withTypeAhead(debounceInterval: number = 200): this {\n    if (\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n      this._items.length &&\n      this._items.some(item => typeof item.getLabel !== 'function')\n    ) {\n      throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n    }\n\n    this._typeaheadSubscription.unsubscribe();\n\n    // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n    // and convert those letters back into a string. Afterwards find the first item that starts\n    // with that string and select it.\n    this._typeaheadSubscription = this._letterKeyStream\n      .pipe(\n        tap(letter => this._pressedLetters.push(letter)),\n        debounceTime(debounceInterval),\n        filter(() => this._pressedLetters.length > 0),\n        map(() => this._pressedLetters.join('')),\n      )\n      .subscribe(inputString => {\n        const items = this._getItemsArray();\n\n        // Start at 1 because we want to start searching at the item immediately\n        // following the current active item.\n        for (let i = 1; i < items.length + 1; i++) {\n          const index = (this._activeItemIndex + i) % items.length;\n          const item = items[index];\n\n          if (\n            !this._skipPredicateFn(item) &&\n            item.getLabel!().toUpperCase().trim().indexOf(inputString) === 0\n          ) {\n            this.setActiveItem(index);\n            break;\n          }\n        }\n\n        this._pressedLetters = [];\n      });\n\n    return this;\n  }\n\n  /**\n   * Configures the key manager to activate the first and last items\n   * respectively when the Home or End key is pressed.\n   * @param enabled Whether pressing the Home or End key activates the first/last item.\n   */\n  withHomeAndEnd(enabled: boolean = true): this {\n    this._homeAndEnd = enabled;\n    return this;\n  }\n\n  /**\n   * Sets the active item to the item at the index specified.\n   * @param index The index of the item to be set as active.\n   */\n  setActiveItem(index: number): void;\n\n  /**\n   * Sets the active item to the specified item.\n   * @param item The item to be set as active.\n   */\n  setActiveItem(item: T): void;\n\n  setActiveItem(item: any): void {\n    const previousActiveItem = this._activeItem;\n\n    this.updateActiveItem(item);\n\n    if (this._activeItem !== previousActiveItem) {\n      this.change.next(this._activeItemIndex);\n    }\n  }\n\n  /**\n   * Sets the active item depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const modifiers: ListKeyManagerModifierKey[] = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n    const isModifierAllowed = modifiers.every(modifier => {\n      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n    });\n\n    switch (keyCode) {\n      case TAB:\n        this.tabOut.next();\n        return;\n\n      case DOWN_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case UP_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case RIGHT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case LEFT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case HOME:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setFirstItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case END:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setLastItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      default:\n        if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n          // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n          // otherwise fall back to resolving alphanumeric characters via the keyCode.\n          if (event.key && event.key.length === 1) {\n            this._letterKeyStream.next(event.key.toLocaleUpperCase());\n          } else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n            this._letterKeyStream.next(String.fromCharCode(keyCode));\n          }\n        }\n\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n\n    this._pressedLetters = [];\n    event.preventDefault();\n  }\n\n  /** Index of the currently active item. */\n  get activeItemIndex(): number | null {\n    return this._activeItemIndex;\n  }\n\n  /** The active item. */\n  get activeItem(): T | null {\n    return this._activeItem;\n  }\n\n  /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n  isTyping(): boolean {\n    return this._pressedLetters.length > 0;\n  }\n\n  /** Sets the active item to the first enabled item in the list. */\n  setFirstItemActive(): void {\n    this._setActiveItemByIndex(0, 1);\n  }\n\n  /** Sets the active item to the last enabled item in the list. */\n  setLastItemActive(): void {\n    this._setActiveItemByIndex(this._items.length - 1, -1);\n  }\n\n  /** Sets the active item to the next enabled item in the list. */\n  setNextItemActive(): void {\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n\n  /** Sets the active item to a previous enabled item in the list. */\n  setPreviousItemActive(): void {\n    this._activeItemIndex < 0 && this._wrap\n      ? this.setLastItemActive()\n      : this._setActiveItemByDelta(-1);\n  }\n\n  /**\n   * Allows setting the active without any other effects.\n   * @param index Index of the item to be set as active.\n   */\n  updateActiveItem(index: number): void;\n\n  /**\n   * Allows setting the active item without any other effects.\n   * @param item Item to be set as active.\n   */\n  updateActiveItem(item: T): void;\n\n  updateActiveItem(item: any): void {\n    const itemArray = this._getItemsArray();\n    const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n    const activeItem = itemArray[index];\n\n    // Explicitly check for `null` and `undefined` because other falsy values are valid.\n    this._activeItem = activeItem == null ? null : activeItem;\n    this._activeItemIndex = index;\n  }\n\n  /**\n   * This method sets the active item, given a list of items and the delta between the\n   * currently active item and the new active item. It will calculate differently\n   * depending on whether wrap mode is turned on.\n   */\n  private _setActiveItemByDelta(delta: -1 | 1): void {\n    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n  }\n\n  /**\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n   * down the list until it finds an item that is not disabled, and it will wrap if it\n   * encounters either end of the list.\n   */\n  private _setActiveInWrapMode(delta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    for (let i = 1; i <= items.length; i++) {\n      const index = (this._activeItemIndex + delta * i + items.length) % items.length;\n      const item = items[index];\n\n      if (!this._skipPredicateFn(item)) {\n        this.setActiveItem(index);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Sets the active item properly given the default mode. In other words, it will\n   * continue to move down the list until it finds an item that is not disabled. If\n   * it encounters either end of the list, it will stop and not wrap.\n   */\n  private _setActiveInDefaultMode(delta: -1 | 1): void {\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n  }\n\n  /**\n   * Sets the active item to the first enabled item starting at the index specified. If the\n   * item is disabled, it will move in the fallbackDelta direction until it either\n   * finds an enabled item or encounters the end of the list.\n   */\n  private _setActiveItemByIndex(index: number, fallbackDelta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    if (!items[index]) {\n      return;\n    }\n\n    while (this._skipPredicateFn(items[index])) {\n      index += fallbackDelta;\n\n      if (!items[index]) {\n        return;\n      }\n    }\n\n    this.setActiveItem(index);\n  }\n\n  /** Returns the items as an array. */\n  private _getItemsArray(): T[] {\n    return this._items instanceof QueryList ? this._items.toArray() : this._items;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {keyValueArraySet} from '../../util/array_utils';\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingMap, classStringParser} from './styling';\n\n\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatPseudoCheckbox} from './pseudo-checkbox';\nimport {MatCommonModule} from '../../common-behaviors/common-module';\n\n@NgModule({\n  imports: [MatCommonModule],\n  exports: [MatPseudoCheckbox],\n  declarations: [MatPseudoCheckbox],\n})\nexport class MatPseudoCheckboxModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CommonModule} from '@angular/common';\nimport {MatRippleModule} from '../ripple/index';\nimport {MatPseudoCheckboxModule} from '../selection/index';\nimport {MatCommonModule} from '../common-behaviors/common-module';\nimport {MatOption} from './option';\nimport {MatOptgroup} from './optgroup';\n\n@NgModule({\n  imports: [MatRippleModule, CommonModule, MatCommonModule, MatPseudoCheckboxModule],\n  exports: [MatOption, MatOptgroup],\n  declarations: [MatOption, MatOptgroup],\n})\nexport class MatOptionModule {}\n\nexport * from './option';\nexport * from './optgroup';\nexport * from './option-parent';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ListKeyManager, ListKeyManagerOption} from './list-key-manager';\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n */\nexport interface Highlightable extends ListKeyManagerOption {\n  /** Applies the styles for an active item to this item. */\n  setActiveStyles(): void;\n\n  /** Applies the styles for an inactive item to this item. */\n  setInactiveStyles(): void;\n}\n\nexport class ActiveDescendantKeyManager<T> extends ListKeyManager<Highlightable & T> {\n  /**\n   * Sets the active item to the item at the specified index and adds the\n   * active styles to the newly active item. Also removes active styles\n   * from the previously active item.\n   * @param index Index of the item to be set as active.\n   */\n  override setActiveItem(index: number): void;\n\n  /**\n   * Sets the active item to the item to the specified one and adds the\n   * active styles to the it. Also removes active styles from the\n   * previously active item.\n   * @param item Item to be set as active.\n   */\n  override setActiveItem(item: T): void;\n\n  override setActiveItem(index: any): void {\n    if (this.activeItem) {\n      this.activeItem.setInactiveStyles();\n    }\n    super.setActiveItem(index);\n    if (this.activeItem) {\n      this.activeItem.setActiveStyles();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Subject} from 'rxjs';\n\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nexport class SelectionModel<T> {\n  /** Currently-selected values. */\n  private _selection = new Set<T>();\n\n  /** Keeps track of the deselected options that haven't been emitted by the change event. */\n  private _deselectedToEmit: T[] = [];\n\n  /** Keeps track of the selected options that haven't been emitted by the change event. */\n  private _selectedToEmit: T[] = [];\n\n  /** Cache for the array value of the selected items. */\n  private _selected: T[] | null;\n\n  /** Selected values. */\n  get selected(): T[] {\n    if (!this._selected) {\n      this._selected = Array.from(this._selection.values());\n    }\n\n    return this._selected;\n  }\n\n  /** Event emitted when the value has changed. */\n  readonly changed = new Subject<SelectionChange<T>>();\n\n  constructor(\n    private _multiple = false,\n    initiallySelectedValues?: T[],\n    private _emitChanges = true,\n    public compareWith?: (o1: T, o2: T) => boolean,\n  ) {\n    if (initiallySelectedValues && initiallySelectedValues.length) {\n      if (_multiple) {\n        initiallySelectedValues.forEach(value => this._markSelected(value));\n      } else {\n        this._markSelected(initiallySelectedValues[0]);\n      }\n\n      // Clear the array in order to avoid firing the change event for preselected values.\n      this._selectedToEmit.length = 0;\n    }\n  }\n\n  /**\n   * Selects a value or an array of values.\n   * @param values The values to select\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  select(...values: T[]): boolean | void {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._markSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n\n  /**\n   * Deselects a value or an array of values.\n   * @param values The values to deselect\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  deselect(...values: T[]): boolean | void {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._unmarkSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n\n  /**\n   * Sets the selected values\n   * @param values The new selected values\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  setSelection(...values: T[]): boolean | void {\n    this._verifyValueAssignment(values);\n    const oldValues = this.selected;\n    const newSelectedSet = new Set(values);\n    values.forEach(value => this._markSelected(value));\n    oldValues\n      .filter(value => !newSelectedSet.has(value))\n      .forEach(value => this._unmarkSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n\n  /**\n   * Toggles a value between selected and deselected.\n   * @param value The value to toggle\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  toggle(value: T): boolean | void {\n    return this.isSelected(value) ? this.deselect(value) : this.select(value);\n  }\n\n  /**\n   * Clears all of the selected values.\n   * @param flushEvent Whether to flush the changes in an event.\n   *   If false, the changes to the selection will be flushed along with the next event.\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  clear(flushEvent = true): boolean | void {\n    this._unmarkAll();\n    const changed = this._hasQueuedChanges();\n    if (flushEvent) {\n      this._emitChangeEvent();\n    }\n    return changed;\n  }\n\n  /**\n   * Determines whether a value is selected.\n   */\n  isSelected(value: T): boolean {\n    if (this.compareWith) {\n      for (const otherValue of this._selection) {\n        if (this.compareWith(otherValue, value)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return this._selection.has(value);\n  }\n\n  /**\n   * Determines whether the model does not have a value.\n   */\n  isEmpty(): boolean {\n    return this._selection.size === 0;\n  }\n\n  /**\n   * Determines whether the model has a value.\n   */\n  hasValue(): boolean {\n    return !this.isEmpty();\n  }\n\n  /**\n   * Sorts the selected values based on a predicate function.\n   */\n  sort(predicate?: (a: T, b: T) => number): void {\n    if (this._multiple && this.selected) {\n      this._selected!.sort(predicate);\n    }\n  }\n\n  /**\n   * Gets whether multiple values can be selected.\n   */\n  isMultipleSelection() {\n    return this._multiple;\n  }\n\n  /** Emits a change event and clears the records of selected and deselected values. */\n  private _emitChangeEvent() {\n    // Clear the selected values so they can be re-cached.\n    this._selected = null;\n\n    if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n      this.changed.next({\n        source: this,\n        added: this._selectedToEmit,\n        removed: this._deselectedToEmit,\n      });\n\n      this._deselectedToEmit = [];\n      this._selectedToEmit = [];\n    }\n  }\n\n  /** Selects a value. */\n  private _markSelected(value: T) {\n    if (!this.isSelected(value)) {\n      if (!this._multiple) {\n        this._unmarkAll();\n      }\n\n      if (!this.isSelected(value)) {\n        this._selection.add(value);\n      }\n\n      if (this._emitChanges) {\n        this._selectedToEmit.push(value);\n      }\n    }\n  }\n\n  /** Deselects a value. */\n  private _unmarkSelected(value: T) {\n    if (this.isSelected(value)) {\n      this._selection.delete(value);\n\n      if (this._emitChanges) {\n        this._deselectedToEmit.push(value);\n      }\n    }\n  }\n\n  /** Clears out the selected values. */\n  private _unmarkAll() {\n    if (!this.isEmpty()) {\n      this._selection.forEach(value => this._unmarkSelected(value));\n    }\n  }\n\n  /**\n   * Verifies the value assignment and throws an error if the specified value array is\n   * including multiple values while the selection model is not supporting multiple values.\n   */\n  private _verifyValueAssignment(values: T[]) {\n    if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMultipleValuesInSingleSelectionError();\n    }\n  }\n\n  /** Whether there are queued up change to be emitted. */\n  private _hasQueuedChanges() {\n    return !!(this._deselectedToEmit.length || this._selectedToEmit.length);\n  }\n}\n\n/**\n * Event emitted when the value of a MatSelectionModel has changed.\n * @docs-private\n */\nexport interface SelectionChange<T> {\n  /** Model that dispatched the event. */\n  source: SelectionModel<T>;\n  /** Options that were added to the model. */\n  added: T[];\n  /** Options that were removed from the model. */\n  removed: T[];\n}\n\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nexport function getMultipleValuesInSingleSelectionError() {\n  return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * Describes a parent component that manages a list of options.\n * Contains properties that the options can inherit.\n * @docs-private\n */\nexport interface MatOptionParentComponent {\n  disableRipple?: boolean;\n  multiple?: boolean;\n  inertGroups?: boolean;\n}\n\n/**\n * Injection token used to provide the parent component to options.\n */\nexport const MAT_OPTION_PARENT_COMPONENT = new InjectionToken<MatOptionParentComponent>(\n  'MAT_OPTION_PARENT_COMPONENT',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  InjectionToken,\n  Input,\n  ViewEncapsulation,\n  Directive,\n  Inject,\n  Optional,\n} from '@angular/core';\nimport {CanDisable, mixinDisabled} from '../common-behaviors/disabled';\nimport {MatOptionParentComponent, MAT_OPTION_PARENT_COMPONENT} from './option-parent';\n\n// Notes on the accessibility pattern used for `mat-optgroup`.\n// The option group has two different \"modes\": regular and inert. The regular mode uses the\n// recommended a11y pattern which has `role=\"group\"` on the group element with `aria-labelledby`\n// pointing to the label. This works for `mat-select`, but it seems to hit a bug for autocomplete\n// under VoiceOver where the group doesn't get read out at all. The bug appears to be that if\n// there's __any__ a11y-related attribute on the group (e.g. `role` or `aria-labelledby`),\n// VoiceOver on Safari won't read it out.\n// We've introduced the `inert` mode as a workaround. Under this mode, all a11y attributes are\n// removed from the group, and we get the screen reader to read out the group label by mirroring it\n// inside an invisible element in the option. This is sub-optimal, because the screen reader will\n// repeat the group label on each navigation, whereas the default pattern only reads the group when\n// the user enters a new group. The following alternate approaches were considered:\n// 1. Reading out the group label using the `LiveAnnouncer` solves the problem, but we can't control\n//    when the text will be read out so sometimes it comes in too late or never if the user\n//    navigates quickly.\n// 2. `<mat-option aria-describedby=\"groupLabel\"` - This works on Safari, but VoiceOver in Chrome\n//    won't read out the description at all.\n// 3. `<mat-option aria-labelledby=\"optionLabel groupLabel\"` - This works on Chrome, but Safari\n//     doesn't read out the text at all. Furthermore, on\n\n// Boilerplate for applying mixins to MatOptgroup.\n/** @docs-private */\nconst _MatOptgroupMixinBase = mixinDisabled(class {});\n\n// Counter for unique group ids.\nlet _uniqueOptgroupIdCounter = 0;\n\n@Directive()\nexport class _MatOptgroupBase extends _MatOptgroupMixinBase implements CanDisable {\n  /** Label for the option group. */\n  @Input() label: string;\n\n  /** Unique id for the underlying label. */\n  _labelId: string = `mat-optgroup-label-${_uniqueOptgroupIdCounter++}`;\n\n  /** Whether the group is in inert a11y mode. */\n  _inert: boolean;\n\n  constructor(@Inject(MAT_OPTION_PARENT_COMPONENT) @Optional() parent?: MatOptionParentComponent) {\n    super();\n    this._inert = parent?.inertGroups ?? false;\n  }\n}\n\n/**\n * Injection token that can be used to reference instances of `MatOptgroup`. It serves as\n * alternative token to the actual `MatOptgroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_OPTGROUP = new InjectionToken<MatOptgroup>('MatOptgroup');\n\n/**\n * Component that is used to group instances of `mat-option`.\n */\n@Component({\n  selector: 'mat-optgroup',\n  exportAs: 'matOptgroup',\n  templateUrl: 'optgroup.html',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  inputs: ['disabled'],\n  styleUrls: ['optgroup.css'],\n  host: {\n    'class': 'mat-optgroup',\n    '[attr.role]': '_inert ? null : \"group\"',\n    '[attr.aria-disabled]': '_inert ? null : disabled.toString()',\n    '[attr.aria-labelledby]': '_inert ? null : _labelId',\n    '[class.mat-optgroup-disabled]': 'disabled',\n  },\n  providers: [{provide: MAT_OPTGROUP, useExisting: MatOptgroup}],\n})\nexport class MatOptgroup extends _MatOptgroupBase {}\n",null,"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  Component,\n  ViewEncapsulation,\n  Input,\n  ChangeDetectionStrategy,\n  Inject,\n  Optional,\n} from '@angular/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\n\n/**\n * Possible states for a pseudo checkbox.\n * @docs-private\n */\nexport type MatPseudoCheckboxState = 'unchecked' | 'checked' | 'indeterminate';\n\n/**\n * Component that shows a simplified checkbox without including any kind of \"real\" checkbox.\n * Meant to be used when the checkbox is purely decorative and a large number of them will be\n * included, such as for the options in a multi-select. Uses no SVGs or complex animations.\n * Note that theming is meant to be handled by the parent element, e.g.\n * `mat-primary .mat-pseudo-checkbox`.\n *\n * Note that this component will be completely invisible to screen-reader users. This is *not*\n * interchangeable with `<mat-checkbox>` and should *not* be used if the user would directly\n * interact with the checkbox. The pseudo-checkbox should only be used as an implementation detail\n * of more complex components that appropriately handle selected / checked state.\n * @docs-private\n */\n@Component({\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  selector: 'mat-pseudo-checkbox',\n  styleUrls: ['pseudo-checkbox.css'],\n  template: '',\n  host: {\n    'class': 'mat-pseudo-checkbox',\n    '[class.mat-pseudo-checkbox-indeterminate]': 'state === \"indeterminate\"',\n    '[class.mat-pseudo-checkbox-checked]': 'state === \"checked\"',\n    '[class.mat-pseudo-checkbox-disabled]': 'disabled',\n    '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n  },\n})\nexport class MatPseudoCheckbox {\n  /** Display state of the checkbox. */\n  @Input() state: MatPseudoCheckboxState = 'unchecked';\n\n  /** Whether the checkbox is disabled. */\n  @Input() disabled: boolean = false;\n\n  constructor(@Optional() @Inject(ANIMATION_MODULE_TYPE) public _animationMode?: string) {}\n}\n",null,"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {ENTER, SPACE, hasModifierKey} from '@angular/cdk/keycodes';\nimport {\n  AfterViewChecked,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  OnDestroy,\n  Optional,\n  Output,\n  QueryList,\n  ViewEncapsulation,\n  Directive,\n} from '@angular/core';\nimport {FocusOptions, FocusableOption, FocusOrigin} from '@angular/cdk/a11y';\nimport {Subject} from 'rxjs';\nimport {MatOptgroup, _MatOptgroupBase, MAT_OPTGROUP} from './optgroup';\nimport {MatOptionParentComponent, MAT_OPTION_PARENT_COMPONENT} from './option-parent';\n\n/**\n * Option IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueIdCounter = 0;\n\n/** Event object emitted by MatOption when selected or deselected. */\nexport class MatOptionSelectionChange<T = any> {\n  constructor(\n    /** Reference to the option that emitted the event. */\n    public source: _MatOptionBase<T>,\n    /** Whether the change in the option's value was a result of a user action. */\n    public isUserInput = false,\n  ) {}\n}\n\n@Directive()\nexport class _MatOptionBase<T = any> implements FocusableOption, AfterViewChecked, OnDestroy {\n  private _selected = false;\n  private _active = false;\n  private _disabled = false;\n  private _mostRecentViewValue = '';\n\n  /** Whether the wrapping component is in multiple selection mode. */\n  get multiple() {\n    return this._parent && this._parent.multiple;\n  }\n\n  /** Whether or not the option is currently selected. */\n  get selected(): boolean {\n    return this._selected;\n  }\n\n  /** The form value of the option. */\n  @Input() value: T;\n\n  /** The unique ID of the option. */\n  @Input() id: string = `mat-option-${_uniqueIdCounter++}`;\n\n  /** Whether the option is disabled. */\n  @Input()\n  get disabled(): boolean {\n    return (this.group && this.group.disabled) || this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n  }\n\n  /** Whether ripples for the option are disabled. */\n  get disableRipple(): boolean {\n    return !!(this._parent && this._parent.disableRipple);\n  }\n\n  /** Event emitted when the option is selected or deselected. */\n  // tslint:disable-next-line:no-output-on-prefix\n  @Output() readonly onSelectionChange = new EventEmitter<MatOptionSelectionChange<T>>();\n\n  /** Emits when the state of the option changes and any parents have to be notified. */\n  readonly _stateChanges = new Subject<void>();\n\n  constructor(\n    private _element: ElementRef<HTMLElement>,\n    private _changeDetectorRef: ChangeDetectorRef,\n    private _parent: MatOptionParentComponent,\n    readonly group: _MatOptgroupBase,\n  ) {}\n\n  /**\n   * Whether or not the option is currently active and ready to be selected.\n   * An active option displays styles as if it is focused, but the\n   * focus is actually retained somewhere else. This comes in handy\n   * for components like autocomplete where focus must remain on the input.\n   */\n  get active(): boolean {\n    return this._active;\n  }\n\n  /**\n   * The displayed value of the option. It is necessary to show the selected option in the\n   * select's trigger.\n   */\n  get viewValue(): string {\n    // TODO(kara): Add input property alternative for node envs.\n    return (this._getHostElement().textContent || '').trim();\n  }\n\n  /** Selects the option. */\n  select(): void {\n    if (!this._selected) {\n      this._selected = true;\n      this._changeDetectorRef.markForCheck();\n      this._emitSelectionChangeEvent();\n    }\n  }\n\n  /** Deselects the option. */\n  deselect(): void {\n    if (this._selected) {\n      this._selected = false;\n      this._changeDetectorRef.markForCheck();\n      this._emitSelectionChangeEvent();\n    }\n  }\n\n  /** Sets focus onto this option. */\n  focus(_origin?: FocusOrigin, options?: FocusOptions): void {\n    // Note that we aren't using `_origin`, but we need to keep it because some internal consumers\n    // use `MatOption` in a `FocusKeyManager` and we need it to match `FocusableOption`.\n    const element = this._getHostElement();\n\n    if (typeof element.focus === 'function') {\n      element.focus(options);\n    }\n  }\n\n  /**\n   * This method sets display styles on the option to make it appear\n   * active. This is used by the ActiveDescendantKeyManager so key\n   * events will display the proper options as active on arrow key events.\n   */\n  setActiveStyles(): void {\n    if (!this._active) {\n      this._active = true;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /**\n   * This method removes display styles on the option that made it appear\n   * active. This is used by the ActiveDescendantKeyManager so key\n   * events will display the proper options as active on arrow key events.\n   */\n  setInactiveStyles(): void {\n    if (this._active) {\n      this._active = false;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /** Gets the label to be used when determining whether the option should be focused. */\n  getLabel(): string {\n    return this.viewValue;\n  }\n\n  /** Ensures the option is selected when activated from the keyboard. */\n  _handleKeydown(event: KeyboardEvent): void {\n    if ((event.keyCode === ENTER || event.keyCode === SPACE) && !hasModifierKey(event)) {\n      this._selectViaInteraction();\n\n      // Prevent the page from scrolling down and form submits.\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * `Selects the option while indicating the selection came from the user. Used to\n   * determine if the select's view -> model callback should be invoked.`\n   */\n  _selectViaInteraction(): void {\n    if (!this.disabled) {\n      this._selected = this.multiple ? !this._selected : true;\n      this._changeDetectorRef.markForCheck();\n      this._emitSelectionChangeEvent(true);\n    }\n  }\n\n  /**\n   * Gets the `aria-selected` value for the option. We explicitly omit the `aria-selected`\n   * attribute from single-selection, unselected options. Including the `aria-selected=\"false\"`\n   * attributes adds a significant amount of noise to screen-reader users without providing useful\n   * information.\n   */\n  _getAriaSelected(): boolean | null {\n    return this.selected || (this.multiple ? false : null);\n  }\n\n  /** Returns the correct tabindex for the option depending on disabled state. */\n  _getTabIndex(): string {\n    return this.disabled ? '-1' : '0';\n  }\n\n  /** Gets the host DOM element. */\n  _getHostElement(): HTMLElement {\n    return this._element.nativeElement;\n  }\n\n  ngAfterViewChecked() {\n    // Since parent components could be using the option's label to display the selected values\n    // (e.g. `mat-select`) and they don't have a way of knowing if the option's label has changed\n    // we have to check for changes in the DOM ourselves and dispatch an event. These checks are\n    // relatively cheap, however we still limit them only to selected options in order to avoid\n    // hitting the DOM too often.\n    if (this._selected) {\n      const viewValue = this.viewValue;\n\n      if (viewValue !== this._mostRecentViewValue) {\n        this._mostRecentViewValue = viewValue;\n        this._stateChanges.next();\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._stateChanges.complete();\n  }\n\n  /** Emits the selection change event. */\n  private _emitSelectionChangeEvent(isUserInput = false): void {\n    this.onSelectionChange.emit(new MatOptionSelectionChange<T>(this, isUserInput));\n  }\n}\n\n/**\n * Single option inside of a `<mat-select>` element.\n */\n@Component({\n  selector: 'mat-option',\n  exportAs: 'matOption',\n  host: {\n    'role': 'option',\n    '[attr.tabindex]': '_getTabIndex()',\n    '[class.mat-selected]': 'selected',\n    '[class.mat-option-multiple]': 'multiple',\n    '[class.mat-active]': 'active',\n    '[id]': 'id',\n    '[attr.aria-selected]': '_getAriaSelected()',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '[class.mat-option-disabled]': 'disabled',\n    '(click)': '_selectViaInteraction()',\n    '(keydown)': '_handleKeydown($event)',\n    'class': 'mat-option mat-focus-indicator',\n  },\n  styleUrls: ['option.css'],\n  templateUrl: 'option.html',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatOption<T = any> extends _MatOptionBase<T> {\n  constructor(\n    element: ElementRef<HTMLElement>,\n    changeDetectorRef: ChangeDetectorRef,\n    @Optional() @Inject(MAT_OPTION_PARENT_COMPONENT) parent: MatOptionParentComponent,\n    @Optional() @Inject(MAT_OPTGROUP) group: MatOptgroup,\n  ) {\n    super(element, changeDetectorRef, parent, group);\n  }\n}\n\n/**\n * Counts the amount of option group labels that precede the specified option.\n * @param optionIndex Index of the option at which to start counting.\n * @param options Flat list of all of the options.\n * @param optionGroups Flat list of all of the option groups.\n * @docs-private\n */\nexport function _countGroupLabelsBeforeOption(\n  optionIndex: number,\n  options: QueryList<MatOption>,\n  optionGroups: QueryList<MatOptgroup>,\n): number {\n  if (optionGroups.length) {\n    let optionsArray = options.toArray();\n    let groups = optionGroups.toArray();\n    let groupCounter = 0;\n\n    for (let i = 0; i < optionIndex + 1; i++) {\n      if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {\n        groupCounter++;\n      }\n    }\n\n    return groupCounter;\n  }\n\n  return 0;\n}\n\n/**\n * Determines the position to which to scroll a panel in order for an option to be into view.\n * @param optionOffset Offset of the option from the top of the panel.\n * @param optionHeight Height of the options.\n * @param currentScrollPosition Current scroll position of the panel.\n * @param panelHeight Height of the panel.\n * @docs-private\n */\nexport function _getOptionScrollPosition(\n  optionOffset: number,\n  optionHeight: number,\n  currentScrollPosition: number,\n  panelHeight: number,\n): number {\n  if (optionOffset < currentScrollPosition) {\n    return optionOffset;\n  }\n\n  if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {\n    return Math.max(0, optionOffset - panelHeight + optionHeight);\n  }\n\n  return currentScrollPosition;\n}\n","<mat-pseudo-checkbox *ngIf=\"multiple\" class=\"mat-option-pseudo-checkbox\"\n    [state]=\"selected ? 'checked' : 'unchecked'\" [disabled]=\"disabled\"></mat-pseudo-checkbox>\n\n<span class=\"mat-option-text\"><ng-content></ng-content></span>\n\n<!-- See a11y notes inside optgroup.ts for context behind this element. -->\n<span class=\"cdk-visually-hidden\" *ngIf=\"group && group._inert\">({{ group.label }})</span>\n\n<div class=\"mat-option-ripple\" mat-ripple\n     [matRippleTrigger]=\"_getHostElement()\"\n     [matRippleDisabled]=\"disabled || disableRipple\">\n</div>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  animate,\n  animateChild,\n  AnimationTriggerMetadata,\n  query,\n  state,\n  style,\n  transition,\n  trigger,\n} from '@angular/animations';\n\n/**\n * The following are all the animations for the mat-select component, with each\n * const containing the metadata for one animation.\n *\n * The values below match the implementation of the AngularJS Material mat-select animation.\n * @docs-private\n */\nexport const matSelectAnimations: {\n  readonly transformPanelWrap: AnimationTriggerMetadata;\n  readonly transformPanel: AnimationTriggerMetadata;\n} = {\n  /**\n   * This animation ensures the select's overlay panel animation (transformPanel) is called when\n   * closing the select.\n   * This is needed due to https://github.com/angular/angular/issues/23302\n   */\n  transformPanelWrap: trigger('transformPanelWrap', [\n    transition('* => void', query('@transformPanel', [animateChild()], {optional: true})),\n  ]),\n\n  /**\n   * This animation transforms the select's overlay panel on and off the page.\n   *\n   * When the panel is attached to the DOM, it expands its width by the amount of padding, scales it\n   * up to 100% on the Y axis, fades in its border, and translates slightly up and to the\n   * side to ensure the option text correctly overlaps the trigger text.\n   *\n   * When the panel is removed from the DOM, it simply fades out linearly.\n   */\n  transformPanel: trigger('transformPanel', [\n    state(\n      'void',\n      style({\n        transform: 'scaleY(0.8)',\n        minWidth: '100%',\n        opacity: 0,\n      }),\n    ),\n    state(\n      'showing',\n      style({\n        opacity: 1,\n        minWidth: 'calc(100% + 32px)', // 32px = 2 * 16px padding\n        transform: 'scaleY(1)',\n      }),\n    ),\n    state(\n      'showing-multiple',\n      style({\n        opacity: 1,\n        minWidth: 'calc(100% + 64px)', // 64px = 48px padding on the left + 16px padding on the right\n        transform: 'scaleY(1)',\n      }),\n    ),\n    transition('void => *', animate('120ms cubic-bezier(0, 0, 0.2, 1)')),\n    transition('* => void', animate('100ms 25ms linear', style({opacity: 0}))),\n  ]),\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n// The tokens for the live announcer are defined in a separate file from LiveAnnouncer\n// as a workaround for https://github.com/angular/angular/issues/22559\n\n/** Possible politeness levels. */\nexport type AriaLivePoliteness = 'off' | 'polite' | 'assertive';\n\nexport const LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken<HTMLElement | null>(\n  'liveAnnouncerElement',\n  {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n  },\n);\n\n/** @docs-private */\nexport function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY(): null {\n  return null;\n}\n\n/** Object that can be used to configure the default options for the LiveAnnouncer. */\nexport interface LiveAnnouncerDefaultOptions {\n  /** Default politeness for the announcements. */\n  politeness?: AriaLivePoliteness;\n\n  /** Default duration for the announcement messages. */\n  duration?: number;\n}\n\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nexport const LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken<LiveAnnouncerDefaultOptions>(\n  'LIVE_ANNOUNCER_DEFAULT_OPTIONS',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ContentObserver} from '@angular/cdk/observers';\nimport {DOCUMENT} from '@angular/common';\nimport {\n  Directive,\n  ElementRef,\n  Inject,\n  Injectable,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n} from '@angular/core';\nimport {Subscription} from 'rxjs';\nimport {\n  AriaLivePoliteness,\n  LiveAnnouncerDefaultOptions,\n  LIVE_ANNOUNCER_ELEMENT_TOKEN,\n  LIVE_ANNOUNCER_DEFAULT_OPTIONS,\n} from './live-announcer-tokens';\n\n@Injectable({providedIn: 'root'})\nexport class LiveAnnouncer implements OnDestroy {\n  private _liveElement: HTMLElement;\n  private _document: Document;\n  private _previousTimeout: number;\n  private _currentPromise: Promise<void> | undefined;\n  private _currentResolve: (() => void) | undefined;\n\n  constructor(\n    @Optional() @Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN) elementToken: any,\n    private _ngZone: NgZone,\n    @Inject(DOCUMENT) _document: any,\n    @Optional()\n    @Inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS)\n    private _defaultOptions?: LiveAnnouncerDefaultOptions,\n  ) {\n    // We inject the live element and document as `any` because the constructor signature cannot\n    // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n    // a class decorator causes TypeScript to preserve the constructor signature types.\n    this._document = _document;\n    this._liveElement = elementToken || this._createLiveElement();\n  }\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string): Promise<void>;\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @param politeness The politeness of the announcer element.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string, politeness?: AriaLivePoliteness): Promise<void>;\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @param duration Time in milliseconds after which to clear out the announcer element. Note\n   *   that this takes effect after the message has been added to the DOM, which can be up to\n   *   100ms after `announce` has been called.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string, duration?: number): Promise<void>;\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @param politeness The politeness of the announcer element.\n   * @param duration Time in milliseconds after which to clear out the announcer element. Note\n   *   that this takes effect after the message has been added to the DOM, which can be up to\n   *   100ms after `announce` has been called.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string, politeness?: AriaLivePoliteness, duration?: number): Promise<void>;\n\n  announce(message: string, ...args: any[]): Promise<void> {\n    const defaultOptions = this._defaultOptions;\n    let politeness: AriaLivePoliteness | undefined;\n    let duration: number | undefined;\n\n    if (args.length === 1 && typeof args[0] === 'number') {\n      duration = args[0];\n    } else {\n      [politeness, duration] = args;\n    }\n\n    this.clear();\n    clearTimeout(this._previousTimeout);\n\n    if (!politeness) {\n      politeness =\n        defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : 'polite';\n    }\n\n    if (duration == null && defaultOptions) {\n      duration = defaultOptions.duration;\n    }\n\n    // TODO: ensure changing the politeness works on all environments we support.\n    this._liveElement.setAttribute('aria-live', politeness);\n\n    // This 100ms timeout is necessary for some browser + screen-reader combinations:\n    // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n    // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n    //   second time without clearing and then using a non-zero delay.\n    // (using JAWS 17 at time of this writing).\n    return this._ngZone.runOutsideAngular(() => {\n      if (!this._currentPromise) {\n        this._currentPromise = new Promise(resolve => (this._currentResolve = resolve));\n      }\n\n      clearTimeout(this._previousTimeout);\n      this._previousTimeout = setTimeout(() => {\n        this._liveElement.textContent = message;\n\n        if (typeof duration === 'number') {\n          this._previousTimeout = setTimeout(() => this.clear(), duration);\n        }\n\n        this._currentResolve!();\n        this._currentPromise = this._currentResolve = undefined;\n      }, 100);\n\n      return this._currentPromise;\n    });\n  }\n\n  /**\n   * Clears the current text from the announcer element. Can be used to prevent\n   * screen readers from reading the text out again while the user is going\n   * through the page landmarks.\n   */\n  clear() {\n    if (this._liveElement) {\n      this._liveElement.textContent = '';\n    }\n  }\n\n  ngOnDestroy() {\n    clearTimeout(this._previousTimeout);\n    this._liveElement?.remove();\n    this._liveElement = null!;\n    this._currentResolve?.();\n    this._currentPromise = this._currentResolve = undefined;\n  }\n\n  private _createLiveElement(): HTMLElement {\n    const elementClass = 'cdk-live-announcer-element';\n    const previousElements = this._document.getElementsByClassName(elementClass);\n    const liveEl = this._document.createElement('div');\n\n    // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n    for (let i = 0; i < previousElements.length; i++) {\n      previousElements[i].remove();\n    }\n\n    liveEl.classList.add(elementClass);\n    liveEl.classList.add('cdk-visually-hidden');\n\n    liveEl.setAttribute('aria-atomic', 'true');\n    liveEl.setAttribute('aria-live', 'polite');\n\n    this._document.body.appendChild(liveEl);\n\n    return liveEl;\n  }\n}\n\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\n@Directive({\n  selector: '[cdkAriaLive]',\n  exportAs: 'cdkAriaLive',\n})\nexport class CdkAriaLive implements OnDestroy {\n  /** The aria-live politeness level to use when announcing messages. */\n  @Input('cdkAriaLive')\n  get politeness(): AriaLivePoliteness {\n    return this._politeness;\n  }\n  set politeness(value: AriaLivePoliteness) {\n    this._politeness = value === 'off' || value === 'assertive' ? value : 'polite';\n    if (this._politeness === 'off') {\n      if (this._subscription) {\n        this._subscription.unsubscribe();\n        this._subscription = null;\n      }\n    } else if (!this._subscription) {\n      this._subscription = this._ngZone.runOutsideAngular(() => {\n        return this._contentObserver.observe(this._elementRef).subscribe(() => {\n          // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n          const elementText = this._elementRef.nativeElement.textContent;\n\n          // The `MutationObserver` fires also for attribute\n          // changes which we don't want to announce.\n          if (elementText !== this._previousAnnouncedText) {\n            this._liveAnnouncer.announce(elementText, this._politeness, this.duration);\n            this._previousAnnouncedText = elementText;\n          }\n        });\n      });\n    }\n  }\n  private _politeness: AriaLivePoliteness = 'polite';\n\n  /** Time in milliseconds after which to clear out the announcer element. */\n  @Input('cdkAriaLiveDuration') duration: number;\n\n  private _previousAnnouncedText?: string;\n  private _subscription: Subscription | null;\n\n  constructor(\n    private _elementRef: ElementRef,\n    private _liveAnnouncer: LiveAnnouncer,\n    private _contentObserver: ContentObserver,\n    private _ngZone: NgZone,\n  ) {}\n\n  ngOnDestroy() {\n    if (this._subscription) {\n      this._subscription.unsubscribe();\n    }\n  }\n}\n",null,"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ActiveDescendantKeyManager, LiveAnnouncer} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  BooleanInput,\n  coerceBooleanProperty,\n  coerceNumberProperty,\n  NumberInput,\n} from '@angular/cdk/coercion';\nimport {SelectionModel} from '@angular/cdk/collections';\nimport {\n  A,\n  DOWN_ARROW,\n  ENTER,\n  hasModifierKey,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  SPACE,\n  UP_ARROW,\n} from '@angular/cdk/keycodes';\nimport {\n  CdkConnectedOverlay,\n  ConnectedPosition,\n  Overlay,\n  ScrollStrategy,\n} from '@angular/cdk/overlay';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {\n  AfterContentInit,\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  Self,\n  SimpleChanges,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  AbstractControl,\n  ControlValueAccessor,\n  FormGroupDirective,\n  NgControl,\n  NgForm,\n  Validators,\n} from '@angular/forms';\nimport {\n  _countGroupLabelsBeforeOption,\n  _getOptionScrollPosition,\n  CanDisable,\n  CanDisableRipple,\n  CanUpdateErrorState,\n  ErrorStateMatcher,\n  HasTabIndex,\n  MAT_OPTGROUP,\n  MAT_OPTION_PARENT_COMPONENT,\n  MatOptgroup,\n  MatOption,\n  MatOptionSelectionChange,\n  mixinDisabled,\n  mixinDisableRipple,\n  mixinErrorState,\n  mixinTabIndex,\n  _MatOptionBase,\n} from '@angular/material/core';\nimport {MAT_FORM_FIELD, MatFormField, MatFormFieldControl} from '@angular/material/form-field';\nimport {defer, merge, Observable, Subject} from 'rxjs';\nimport {\n  distinctUntilChanged,\n  filter,\n  map,\n  startWith,\n  switchMap,\n  take,\n  takeUntil,\n} from 'rxjs/operators';\nimport {matSelectAnimations} from './select-animations';\nimport {\n  getMatSelectDynamicMultipleError,\n  getMatSelectNonArrayValueError,\n  getMatSelectNonFunctionValueError,\n} from './select-errors';\n\nlet nextUniqueId = 0;\n\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the alignment of the selected option over\n * the trigger element.\n */\n\n/** The max height of the select's overlay panel. */\nexport const SELECT_PANEL_MAX_HEIGHT = 256;\n\n/** The panel's padding on the x-axis. */\nexport const SELECT_PANEL_PADDING_X = 16;\n\n/** The panel's x axis padding if it is indented (e.g. there is an option group). */\nexport const SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_PADDING_X * 2;\n\n/** The height of the select items in `em` units. */\nexport const SELECT_ITEM_HEIGHT_EM = 3;\n\n// TODO(josephperrott): Revert to a constant after 2018 spec updates are fully merged.\n/**\n * Distance between the panel edge and the option text in\n * multi-selection mode.\n *\n * Calculated as:\n * (SELECT_PANEL_PADDING_X * 1.5) + 16 = 40\n * The padding is multiplied by 1.5 because the checkbox's margin is half the padding.\n * The checkbox width is 16px.\n */\nexport const SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_PANEL_PADDING_X * 1.5 + 16;\n\n/**\n * The select panel will only \"fit\" inside the viewport if it is positioned at\n * this value or more away from the viewport boundary.\n */\nexport const SELECT_PANEL_VIEWPORT_PADDING = 8;\n\n/** Injection token that determines the scroll handling while a select is open. */\nexport const MAT_SELECT_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-select-scroll-strategy',\n);\n\n/** @docs-private */\nexport function MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(\n  overlay: Overlay,\n): () => ScrollStrategy {\n  return () => overlay.scrollStrategies.reposition();\n}\n\n/** Object that can be used to configure the default options for the select module. */\nexport interface MatSelectConfig {\n  /** Whether option centering should be disabled. */\n  disableOptionCentering?: boolean;\n\n  /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n  typeaheadDebounceInterval?: number;\n\n  /** Class or list of classes to be applied to the menu's overlay panel. */\n  overlayPanelClass?: string | string[];\n}\n\n/** Injection token that can be used to provide the default options the select module. */\nexport const MAT_SELECT_CONFIG = new InjectionToken<MatSelectConfig>('MAT_SELECT_CONFIG');\n\n/** @docs-private */\nexport const MAT_SELECT_SCROLL_STRATEGY_PROVIDER = {\n  provide: MAT_SELECT_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n\n/** Change event object that is emitted when the select value has changed. */\nexport class MatSelectChange {\n  constructor(\n    /** Reference to the select that emitted the change event. */\n    public source: MatSelect,\n    /** Current value of the select that emitted the event. */\n    public value: any,\n  ) {}\n}\n\n// Boilerplate for applying mixins to MatSelect.\n/** @docs-private */\nconst _MatSelectMixinBase = mixinDisableRipple(\n  mixinTabIndex(\n    mixinDisabled(\n      mixinErrorState(\n        class {\n          /**\n           * Emits whenever the component state changes and should cause the parent\n           * form-field to update. Implemented as part of `MatFormFieldControl`.\n           * @docs-private\n           */\n          readonly stateChanges = new Subject<void>();\n\n          constructor(\n            public _elementRef: ElementRef,\n            public _defaultErrorStateMatcher: ErrorStateMatcher,\n            public _parentForm: NgForm,\n            public _parentFormGroup: FormGroupDirective,\n            /**\n             * Form control bound to the component.\n             * Implemented as part of `MatFormFieldControl`.\n             * @docs-private\n             */\n            public ngControl: NgControl,\n          ) {}\n        },\n      ),\n    ),\n  ),\n);\n\n/**\n * Injection token that can be used to reference instances of `MatSelectTrigger`. It serves as\n * alternative token to the actual `MatSelectTrigger` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_SELECT_TRIGGER = new InjectionToken<MatSelectTrigger>('MatSelectTrigger');\n\n/**\n * Allows the user to customize the trigger that is displayed when the select has a value.\n */\n@Directive({\n  selector: 'mat-select-trigger',\n  providers: [{provide: MAT_SELECT_TRIGGER, useExisting: MatSelectTrigger}],\n})\nexport class MatSelectTrigger {}\n\n/** Base class with all of the `MatSelect` functionality. */\n@Directive()\nexport abstract class _MatSelectBase<C>\n  extends _MatSelectMixinBase\n  implements\n    AfterContentInit,\n    OnChanges,\n    OnDestroy,\n    OnInit,\n    DoCheck,\n    ControlValueAccessor,\n    CanDisable,\n    HasTabIndex,\n    MatFormFieldControl<any>,\n    CanUpdateErrorState,\n    CanDisableRipple\n{\n  /** All of the defined select options. */\n  abstract options: QueryList<_MatOptionBase>;\n\n  // TODO(crisbeto): this is only necessary for the non-MDC select, but it's technically a\n  // public API so we have to keep it. It should be deprecated and removed eventually.\n  /** All of the defined groups of options. */\n  abstract optionGroups: QueryList<MatOptgroup>;\n\n  /** User-supplied override of the trigger element. */\n  abstract customTrigger: {};\n\n  /**\n   * This position config ensures that the top \"start\" corner of the overlay\n   * is aligned with with the top \"start\" of the origin by default (overlapping\n   * the trigger completely). If the panel cannot fit below the trigger, it\n   * will fall back to a position above the trigger.\n   */\n  abstract _positions: ConnectedPosition[];\n\n  /** Scrolls a particular option into the view. */\n  protected abstract _scrollOptionIntoView(index: number): void;\n\n  /** Called when the panel has been opened and the overlay has settled on its final position. */\n  protected abstract _positioningSettled(): void;\n\n  /** Creates a change event object that should be emitted by the select. */\n  protected abstract _getChangeEvent(value: any): C;\n\n  /** Factory function used to create a scroll strategy for this select. */\n  private _scrollStrategyFactory: () => ScrollStrategy;\n\n  /** Whether or not the overlay panel is open. */\n  private _panelOpen = false;\n\n  /** Comparison function to specify which option is displayed. Defaults to object equality. */\n  private _compareWith = (o1: any, o2: any) => o1 === o2;\n\n  /** Unique id for this input. */\n  private _uid = `mat-select-${nextUniqueId++}`;\n\n  /** Current `aria-labelledby` value for the select trigger. */\n  private _triggerAriaLabelledBy: string | null = null;\n\n  /**\n   * Keeps track of the previous form control assigned to the select.\n   * Used to detect if it has changed.\n   */\n  private _previousControl: AbstractControl | null | undefined;\n\n  /** Emits whenever the component is destroyed. */\n  protected readonly _destroy = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /** Deals with the selection logic. */\n  _selectionModel: SelectionModel<MatOption>;\n\n  /** Manages keyboard events for options in the panel. */\n  _keyManager: ActiveDescendantKeyManager<MatOption>;\n\n  /** `View -> model callback called when value changes` */\n  _onChange: (value: any) => void = () => {};\n\n  /** `View -> model callback called when select has been touched` */\n  _onTouched = () => {};\n\n  /** ID for the DOM node containing the select's value. */\n  _valueId = `mat-select-value-${nextUniqueId++}`;\n\n  /** Emits when the panel element is finished transforming in. */\n  readonly _panelDoneAnimatingStream = new Subject<string>();\n\n  /** Strategy that will be used to handle scrolling while the select panel is open. */\n  _scrollStrategy: ScrollStrategy;\n\n  _overlayPanelClass: string | string[] = this._defaultOptions?.overlayPanelClass || '';\n\n  /** Whether the select is focused. */\n  get focused(): boolean {\n    return this._focused || this._panelOpen;\n  }\n  private _focused = false;\n\n  /** A name for this control that can be used by `mat-form-field`. */\n  controlType = 'mat-select';\n\n  /** Trigger that opens the select. */\n  @ViewChild('trigger') trigger: ElementRef;\n\n  /** Panel containing the select options. */\n  @ViewChild('panel') panel: ElementRef;\n\n  /** Overlay pane containing the options. */\n  @ViewChild(CdkConnectedOverlay)\n  protected _overlayDir: CdkConnectedOverlay;\n\n  /** Classes to be passed to the select panel. Supports the same syntax as `ngClass`. */\n  @Input() panelClass: string | string[] | Set<string> | {[key: string]: any};\n\n  /** Placeholder to be shown if no value has been selected. */\n  @Input()\n  get placeholder(): string {\n    return this._placeholder;\n  }\n  set placeholder(value: string) {\n    this._placeholder = value;\n    this.stateChanges.next();\n  }\n  private _placeholder: string;\n\n  /** Whether the component is required. */\n  @Input()\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n    this.stateChanges.next();\n  }\n  private _required: boolean | undefined;\n\n  /** Whether the user should be allowed to select multiple options. */\n  @Input()\n  get multiple(): boolean {\n    return this._multiple;\n  }\n  set multiple(value: BooleanInput) {\n    if (this._selectionModel && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatSelectDynamicMultipleError();\n    }\n\n    this._multiple = coerceBooleanProperty(value);\n  }\n  private _multiple: boolean = false;\n\n  /** Whether to center the active option over the trigger. */\n  @Input()\n  get disableOptionCentering(): boolean {\n    return this._disableOptionCentering;\n  }\n  set disableOptionCentering(value: BooleanInput) {\n    this._disableOptionCentering = coerceBooleanProperty(value);\n  }\n  private _disableOptionCentering = this._defaultOptions?.disableOptionCentering ?? false;\n\n  /**\n   * Function to compare the option values with the selected values. The first argument\n   * is a value from an option. The second is a value from the selection. A boolean\n   * should be returned.\n   */\n  @Input()\n  get compareWith() {\n    return this._compareWith;\n  }\n  set compareWith(fn: (o1: any, o2: any) => boolean) {\n    if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatSelectNonFunctionValueError();\n    }\n    this._compareWith = fn;\n    if (this._selectionModel) {\n      // A different comparator means the selection could change.\n      this._initializeSelection();\n    }\n  }\n\n  /** Value of the select control. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    const hasAssigned = this._assignValue(newValue);\n\n    if (hasAssigned) {\n      this._onChange(newValue);\n    }\n  }\n  private _value: any;\n\n  /** Aria label of the select. */\n  @Input('aria-label') ariaLabel: string = '';\n\n  /** Input that can be used to specify the `aria-labelledby` attribute. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** Object used to control when error messages are shown. */\n  @Input() override errorStateMatcher: ErrorStateMatcher;\n\n  /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n  @Input()\n  get typeaheadDebounceInterval(): number {\n    return this._typeaheadDebounceInterval;\n  }\n  set typeaheadDebounceInterval(value: NumberInput) {\n    this._typeaheadDebounceInterval = coerceNumberProperty(value);\n  }\n  private _typeaheadDebounceInterval: number;\n\n  /**\n   * Function used to sort the values in a select in multiple mode.\n   * Follows the same logic as `Array.prototype.sort`.\n   */\n  @Input() sortComparator: (a: MatOption, b: MatOption, options: MatOption[]) => number;\n\n  /** Unique id of the element. */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n    this.stateChanges.next();\n  }\n  private _id: string;\n\n  /** Combined stream of all of the child options' change events. */\n  readonly optionSelectionChanges: Observable<MatOptionSelectionChange> = defer(() => {\n    const options = this.options;\n\n    if (options) {\n      return options.changes.pipe(\n        startWith(options),\n        switchMap(() => merge(...options.map(option => option.onSelectionChange))),\n      );\n    }\n\n    return this._ngZone.onStable.pipe(\n      take(1),\n      switchMap(() => this.optionSelectionChanges),\n    );\n  }) as Observable<MatOptionSelectionChange>;\n\n  /** Event emitted when the select panel has been toggled. */\n  @Output() readonly openedChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  /** Event emitted when the select has been opened. */\n  @Output('opened') readonly _openedStream: Observable<void> = this.openedChange.pipe(\n    filter(o => o),\n    map(() => {}),\n  );\n\n  /** Event emitted when the select has been closed. */\n  @Output('closed') readonly _closedStream: Observable<void> = this.openedChange.pipe(\n    filter(o => !o),\n    map(() => {}),\n  );\n\n  /** Event emitted when the selected value has been changed by the user. */\n  @Output() readonly selectionChange: EventEmitter<C> = new EventEmitter<C>();\n\n  /**\n   * Event that emits whenever the raw value of the select changes. This is here primarily\n   * to facilitate the two-way binding for the `value` input.\n   * @docs-private\n   */\n  @Output() readonly valueChange: EventEmitter<any> = new EventEmitter<any>();\n\n  constructor(\n    protected _viewportRuler: ViewportRuler,\n    protected _changeDetectorRef: ChangeDetectorRef,\n    protected _ngZone: NgZone,\n    _defaultErrorStateMatcher: ErrorStateMatcher,\n    elementRef: ElementRef,\n    @Optional() private _dir: Directionality,\n    @Optional() _parentForm: NgForm,\n    @Optional() _parentFormGroup: FormGroupDirective,\n    @Optional() @Inject(MAT_FORM_FIELD) protected _parentFormField: MatFormField,\n    @Self() @Optional() ngControl: NgControl,\n    @Attribute('tabindex') tabIndex: string,\n    @Inject(MAT_SELECT_SCROLL_STRATEGY) scrollStrategyFactory: any,\n    private _liveAnnouncer: LiveAnnouncer,\n    @Optional() @Inject(MAT_SELECT_CONFIG) private _defaultOptions?: MatSelectConfig,\n  ) {\n    super(elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n\n    if (this.ngControl) {\n      // Note: we provide the value accessor through here, instead of\n      // the `providers` to avoid running into a circular import.\n      this.ngControl.valueAccessor = this;\n    }\n\n    // Note that we only want to set this when the defaults pass it in, otherwise it should\n    // stay as `undefined` so that it falls back to the default in the key manager.\n    if (_defaultOptions?.typeaheadDebounceInterval != null) {\n      this._typeaheadDebounceInterval = _defaultOptions.typeaheadDebounceInterval;\n    }\n\n    this._scrollStrategyFactory = scrollStrategyFactory;\n    this._scrollStrategy = this._scrollStrategyFactory();\n    this.tabIndex = parseInt(tabIndex) || 0;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n  }\n\n  ngOnInit() {\n    this._selectionModel = new SelectionModel<MatOption>(this.multiple);\n    this.stateChanges.next();\n\n    // We need `distinctUntilChanged` here, because some browsers will\n    // fire the animation end event twice for the same animation. See:\n    // https://github.com/angular/angular/issues/24084\n    this._panelDoneAnimatingStream\n      .pipe(distinctUntilChanged(), takeUntil(this._destroy))\n      .subscribe(() => this._panelDoneAnimating(this.panelOpen));\n  }\n\n  ngAfterContentInit() {\n    this._initKeyManager();\n\n    this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe(event => {\n      event.added.forEach(option => option.select());\n      event.removed.forEach(option => option.deselect());\n    });\n\n    this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {\n      this._resetOptions();\n      this._initializeSelection();\n    });\n  }\n\n  ngDoCheck() {\n    const newAriaLabelledby = this._getTriggerAriaLabelledby();\n    const ngControl = this.ngControl;\n\n    // We have to manage setting the `aria-labelledby` ourselves, because part of its value\n    // is computed as a result of a content query which can cause this binding to trigger a\n    // \"changed after checked\" error.\n    if (newAriaLabelledby !== this._triggerAriaLabelledBy) {\n      const element: HTMLElement = this._elementRef.nativeElement;\n      this._triggerAriaLabelledBy = newAriaLabelledby;\n      if (newAriaLabelledby) {\n        element.setAttribute('aria-labelledby', newAriaLabelledby);\n      } else {\n        element.removeAttribute('aria-labelledby');\n      }\n    }\n\n    if (ngControl) {\n      // The disabled state might go out of sync if the form group is swapped out. See #17860.\n      if (this._previousControl !== ngControl.control) {\n        if (\n          this._previousControl !== undefined &&\n          ngControl.disabled !== null &&\n          ngControl.disabled !== this.disabled\n        ) {\n          this.disabled = ngControl.disabled;\n        }\n\n        this._previousControl = ngControl.control;\n      }\n\n      this.updateErrorState();\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    // Updating the disabled state is handled by `mixinDisabled`, but we need to additionally let\n    // the parent form field know to run change detection when the disabled state changes.\n    if (changes['disabled'] || changes['userAriaDescribedBy']) {\n      this.stateChanges.next();\n    }\n\n    if (changes['typeaheadDebounceInterval'] && this._keyManager) {\n      this._keyManager.withTypeAhead(this._typeaheadDebounceInterval);\n    }\n  }\n\n  ngOnDestroy() {\n    this._destroy.next();\n    this._destroy.complete();\n    this.stateChanges.complete();\n  }\n\n  /** Toggles the overlay panel open or closed. */\n  toggle(): void {\n    this.panelOpen ? this.close() : this.open();\n  }\n\n  /** Opens the overlay panel. */\n  open(): void {\n    if (this._canOpen()) {\n      this._panelOpen = true;\n      this._keyManager.withHorizontalOrientation(null);\n      this._highlightCorrectOption();\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /** Closes the overlay panel and focuses the host element. */\n  close(): void {\n    if (this._panelOpen) {\n      this._panelOpen = false;\n      this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');\n      this._changeDetectorRef.markForCheck();\n      this._onTouched();\n    }\n  }\n\n  /**\n   * Sets the select's value. Part of the ControlValueAccessor interface\n   * required to integrate with Angular's core forms API.\n   *\n   * @param value New value to be written to the model.\n   */\n  writeValue(value: any): void {\n    this._assignValue(value);\n  }\n\n  /**\n   * Saves a callback function to be invoked when the select's value\n   * changes from user input. Part of the ControlValueAccessor interface\n   * required to integrate with Angular's core forms API.\n   *\n   * @param fn Callback to be triggered when the value changes.\n   */\n  registerOnChange(fn: (value: any) => void): void {\n    this._onChange = fn;\n  }\n\n  /**\n   * Saves a callback function to be invoked when the select is blurred\n   * by the user. Part of the ControlValueAccessor interface required\n   * to integrate with Angular's core forms API.\n   *\n   * @param fn Callback to be triggered when the component has been touched.\n   */\n  registerOnTouched(fn: () => {}): void {\n    this._onTouched = fn;\n  }\n\n  /**\n   * Disables the select. Part of the ControlValueAccessor interface required\n   * to integrate with Angular's core forms API.\n   *\n   * @param isDisabled Sets whether the component is disabled.\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n    this._changeDetectorRef.markForCheck();\n    this.stateChanges.next();\n  }\n\n  /** Whether or not the overlay panel is open. */\n  get panelOpen(): boolean {\n    return this._panelOpen;\n  }\n\n  /** The currently selected option. */\n  get selected(): MatOption | MatOption[] {\n    return this.multiple ? this._selectionModel?.selected || [] : this._selectionModel?.selected[0];\n  }\n\n  /** The value displayed in the trigger. */\n  get triggerValue(): string {\n    if (this.empty) {\n      return '';\n    }\n\n    if (this._multiple) {\n      const selectedOptions = this._selectionModel.selected.map(option => option.viewValue);\n\n      if (this._isRtl()) {\n        selectedOptions.reverse();\n      }\n\n      // TODO(crisbeto): delimiter should be configurable for proper localization.\n      return selectedOptions.join(', ');\n    }\n\n    return this._selectionModel.selected[0].viewValue;\n  }\n\n  /** Whether the element is in RTL mode. */\n  _isRtl(): boolean {\n    return this._dir ? this._dir.value === 'rtl' : false;\n  }\n\n  /** Handles all keydown events on the select. */\n  _handleKeydown(event: KeyboardEvent): void {\n    if (!this.disabled) {\n      this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);\n    }\n  }\n\n  /** Handles keyboard events while the select is closed. */\n  private _handleClosedKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const isArrowKey =\n      keyCode === DOWN_ARROW ||\n      keyCode === UP_ARROW ||\n      keyCode === LEFT_ARROW ||\n      keyCode === RIGHT_ARROW;\n    const isOpenKey = keyCode === ENTER || keyCode === SPACE;\n    const manager = this._keyManager;\n\n    // Open the select on ALT + arrow key to match the native <select>\n    if (\n      (!manager.isTyping() && isOpenKey && !hasModifierKey(event)) ||\n      ((this.multiple || event.altKey) && isArrowKey)\n    ) {\n      event.preventDefault(); // prevents the page from scrolling down when pressing space\n      this.open();\n    } else if (!this.multiple) {\n      const previouslySelectedOption = this.selected;\n      manager.onKeydown(event);\n      const selectedOption = this.selected;\n\n      // Since the value has changed, we need to announce it ourselves.\n      if (selectedOption && previouslySelectedOption !== selectedOption) {\n        // We set a duration on the live announcement, because we want the live element to be\n        // cleared after a while so that users can't navigate to it using the arrow keys.\n        this._liveAnnouncer.announce((selectedOption as MatOption).viewValue, 10000);\n      }\n    }\n  }\n\n  /** Handles keyboard events when the selected is open. */\n  private _handleOpenKeydown(event: KeyboardEvent): void {\n    const manager = this._keyManager;\n    const keyCode = event.keyCode;\n    const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;\n    const isTyping = manager.isTyping();\n\n    if (isArrowKey && event.altKey) {\n      // Close the select on ALT + arrow key to match the native <select>\n      event.preventDefault();\n      this.close();\n      // Don't do anything in this case if the user is typing,\n      // because the typing sequence can include the space key.\n    } else if (\n      !isTyping &&\n      (keyCode === ENTER || keyCode === SPACE) &&\n      manager.activeItem &&\n      !hasModifierKey(event)\n    ) {\n      event.preventDefault();\n      manager.activeItem._selectViaInteraction();\n    } else if (!isTyping && this._multiple && keyCode === A && event.ctrlKey) {\n      event.preventDefault();\n      const hasDeselectedOptions = this.options.some(opt => !opt.disabled && !opt.selected);\n\n      this.options.forEach(option => {\n        if (!option.disabled) {\n          hasDeselectedOptions ? option.select() : option.deselect();\n        }\n      });\n    } else {\n      const previouslyFocusedIndex = manager.activeItemIndex;\n\n      manager.onKeydown(event);\n\n      if (\n        this._multiple &&\n        isArrowKey &&\n        event.shiftKey &&\n        manager.activeItem &&\n        manager.activeItemIndex !== previouslyFocusedIndex\n      ) {\n        manager.activeItem._selectViaInteraction();\n      }\n    }\n  }\n\n  _onFocus() {\n    if (!this.disabled) {\n      this._focused = true;\n      this.stateChanges.next();\n    }\n  }\n\n  /**\n   * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n   * \"blur\" to the panel when it opens, causing a false positive.\n   */\n  _onBlur() {\n    this._focused = false;\n\n    if (!this.disabled && !this.panelOpen) {\n      this._onTouched();\n      this._changeDetectorRef.markForCheck();\n      this.stateChanges.next();\n    }\n  }\n\n  /**\n   * Callback that is invoked when the overlay panel has been attached.\n   */\n  _onAttached(): void {\n    this._overlayDir.positionChange.pipe(take(1)).subscribe(() => {\n      this._changeDetectorRef.detectChanges();\n      this._positioningSettled();\n    });\n  }\n\n  /** Returns the theme to be used on the panel. */\n  _getPanelTheme(): string {\n    return this._parentFormField ? `mat-${this._parentFormField.color}` : '';\n  }\n\n  /** Whether the select has a value. */\n  get empty(): boolean {\n    return !this._selectionModel || this._selectionModel.isEmpty();\n  }\n\n  private _initializeSelection(): void {\n    // Defer setting the value in order to avoid the \"Expression\n    // has changed after it was checked\" errors from Angular.\n    Promise.resolve().then(() => {\n      if (this.ngControl) {\n        this._value = this.ngControl.value;\n      }\n\n      this._setSelectionByValue(this._value);\n      this.stateChanges.next();\n    });\n  }\n\n  /**\n   * Sets the selected option based on a value. If no option can be\n   * found with the designated value, the select trigger is cleared.\n   */\n  private _setSelectionByValue(value: any | any[]): void {\n    this._selectionModel.selected.forEach(option => option.setInactiveStyles());\n    this._selectionModel.clear();\n\n    if (this.multiple && value) {\n      if (!Array.isArray(value) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatSelectNonArrayValueError();\n      }\n\n      value.forEach((currentValue: any) => this._selectOptionByValue(currentValue));\n      this._sortValues();\n    } else {\n      const correspondingOption = this._selectOptionByValue(value);\n\n      // Shift focus to the active item. Note that we shouldn't do this in multiple\n      // mode, because we don't know what option the user interacted with last.\n      if (correspondingOption) {\n        this._keyManager.updateActiveItem(correspondingOption);\n      } else if (!this.panelOpen) {\n        // Otherwise reset the highlighted option. Note that we only want to do this while\n        // closed, because doing it while open can shift the user's focus unnecessarily.\n        this._keyManager.updateActiveItem(-1);\n      }\n    }\n\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Finds and selects and option based on its value.\n   * @returns Option that has the corresponding value.\n   */\n  private _selectOptionByValue(value: any): MatOption | undefined {\n    const correspondingOption = this.options.find((option: MatOption) => {\n      // Skip options that are already in the model. This allows us to handle cases\n      // where the same primitive value is selected multiple times.\n      if (this._selectionModel.isSelected(option)) {\n        return false;\n      }\n\n      try {\n        // Treat null as a special reset value.\n        return option.value != null && this._compareWith(option.value, value);\n      } catch (error) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          // Notify developers of errors in their comparator.\n          console.warn(error);\n        }\n        return false;\n      }\n    });\n\n    if (correspondingOption) {\n      this._selectionModel.select(correspondingOption);\n    }\n\n    return correspondingOption;\n  }\n\n  /** Assigns a specific value to the select. Returns whether the value has changed. */\n  private _assignValue(newValue: any | any[]): boolean {\n    // Always re-assign an array, because it might have been mutated.\n    if (newValue !== this._value || (this._multiple && Array.isArray(newValue))) {\n      if (this.options) {\n        this._setSelectionByValue(newValue);\n      }\n\n      this._value = newValue;\n      return true;\n    }\n    return false;\n  }\n\n  /** Sets up a key manager to listen to keyboard events on the overlay panel. */\n  private _initKeyManager() {\n    this._keyManager = new ActiveDescendantKeyManager<MatOption>(this.options)\n      .withTypeAhead(this._typeaheadDebounceInterval)\n      .withVerticalOrientation()\n      .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')\n      .withHomeAndEnd()\n      .withAllowedModifierKeys(['shiftKey']);\n\n    this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe(() => {\n      if (this.panelOpen) {\n        // Select the active item when tabbing away. This is consistent with how the native\n        // select behaves. Note that we only want to do this in single selection mode.\n        if (!this.multiple && this._keyManager.activeItem) {\n          this._keyManager.activeItem._selectViaInteraction();\n        }\n\n        // Restore focus to the trigger before closing. Ensures that the focus\n        // position won't be lost if the user got focus into the overlay.\n        this.focus();\n        this.close();\n      }\n    });\n\n    this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe(() => {\n      if (this._panelOpen && this.panel) {\n        this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n      } else if (!this._panelOpen && !this.multiple && this._keyManager.activeItem) {\n        this._keyManager.activeItem._selectViaInteraction();\n      }\n    });\n  }\n\n  /** Drops current option subscriptions and IDs and resets from scratch. */\n  private _resetOptions(): void {\n    const changedOrDestroyed = merge(this.options.changes, this._destroy);\n\n    this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe(event => {\n      this._onSelect(event.source, event.isUserInput);\n\n      if (event.isUserInput && !this.multiple && this._panelOpen) {\n        this.close();\n        this.focus();\n      }\n    });\n\n    // Listen to changes in the internal state of the options and react accordingly.\n    // Handles cases like the labels of the selected options changing.\n    merge(...this.options.map(option => option._stateChanges))\n      .pipe(takeUntil(changedOrDestroyed))\n      .subscribe(() => {\n        this._changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n      });\n  }\n\n  /** Invoked when an option is clicked. */\n  private _onSelect(option: MatOption, isUserInput: boolean): void {\n    const wasSelected = this._selectionModel.isSelected(option);\n\n    if (option.value == null && !this._multiple) {\n      option.deselect();\n      this._selectionModel.clear();\n\n      if (this.value != null) {\n        this._propagateChanges(option.value);\n      }\n    } else {\n      if (wasSelected !== option.selected) {\n        option.selected\n          ? this._selectionModel.select(option)\n          : this._selectionModel.deselect(option);\n      }\n\n      if (isUserInput) {\n        this._keyManager.setActiveItem(option);\n      }\n\n      if (this.multiple) {\n        this._sortValues();\n\n        if (isUserInput) {\n          // In case the user selected the option with their mouse, we\n          // want to restore focus back to the trigger, in order to\n          // prevent the select keyboard controls from clashing with\n          // the ones from `mat-option`.\n          this.focus();\n        }\n      }\n    }\n\n    if (wasSelected !== this._selectionModel.isSelected(option)) {\n      this._propagateChanges();\n    }\n\n    this.stateChanges.next();\n  }\n\n  /** Sorts the selected values in the selected based on their order in the panel. */\n  private _sortValues() {\n    if (this.multiple) {\n      const options = this.options.toArray();\n\n      this._selectionModel.sort((a, b) => {\n        return this.sortComparator\n          ? this.sortComparator(a, b, options)\n          : options.indexOf(a) - options.indexOf(b);\n      });\n      this.stateChanges.next();\n    }\n  }\n\n  /** Emits change event to set the model value. */\n  private _propagateChanges(fallbackValue?: any): void {\n    let valueToEmit: any = null;\n\n    if (this.multiple) {\n      valueToEmit = (this.selected as MatOption[]).map(option => option.value);\n    } else {\n      valueToEmit = this.selected ? (this.selected as MatOption).value : fallbackValue;\n    }\n\n    this._value = valueToEmit;\n    this.valueChange.emit(valueToEmit);\n    this._onChange(valueToEmit);\n    this.selectionChange.emit(this._getChangeEvent(valueToEmit));\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Highlights the selected item. If no option is selected, it will highlight\n   * the first item instead.\n   */\n  private _highlightCorrectOption(): void {\n    if (this._keyManager) {\n      if (this.empty) {\n        this._keyManager.setFirstItemActive();\n      } else {\n        this._keyManager.setActiveItem(this._selectionModel.selected[0]);\n      }\n    }\n  }\n\n  /** Whether the panel is allowed to open. */\n  protected _canOpen(): boolean {\n    return !this._panelOpen && !this.disabled && this.options?.length > 0;\n  }\n\n  /** Focuses the select element. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Gets the aria-labelledby for the select panel. */\n  _getPanelAriaLabelledby(): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    const labelId = this._parentFormField?.getLabelId();\n    const labelExpression = labelId ? labelId + ' ' : '';\n    return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n  }\n\n  /** Determines the `aria-activedescendant` to be set on the host. */\n  _getAriaActiveDescendant(): string | null {\n    if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {\n      return this._keyManager.activeItem.id;\n    }\n\n    return null;\n  }\n\n  /** Gets the aria-labelledby of the select component trigger. */\n  private _getTriggerAriaLabelledby(): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    const labelId = this._parentFormField?.getLabelId();\n    let value = (labelId ? labelId + ' ' : '') + this._valueId;\n\n    if (this.ariaLabelledby) {\n      value += ' ' + this.ariaLabelledby;\n    }\n\n    return value;\n  }\n\n  /** Called when the overlay panel is done animating. */\n  protected _panelDoneAnimating(isOpen: boolean) {\n    this.openedChange.emit(isOpen);\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    this.focus();\n    this.open();\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    return this._panelOpen || !this.empty || (this._focused && !!this._placeholder);\n  }\n}\n\n@Component({\n  selector: 'mat-select',\n  exportAs: 'matSelect',\n  templateUrl: 'select.html',\n  styleUrls: ['select.css'],\n  inputs: ['disabled', 'disableRipple', 'tabIndex'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    'role': 'combobox',\n    'aria-autocomplete': 'none',\n    // TODO(crisbeto): the value for aria-haspopup should be `listbox`, but currently it's difficult\n    // to sync into Google, because of an outdated automated a11y check which flags it as an invalid\n    // value. At some point we should try to switch it back to being `listbox`.\n    'aria-haspopup': 'true',\n    'class': 'mat-select',\n    '[attr.id]': 'id',\n    '[attr.tabindex]': 'tabIndex',\n    '[attr.aria-controls]': 'panelOpen ? id + \"-panel\" : null',\n    '[attr.aria-expanded]': 'panelOpen',\n    '[attr.aria-label]': 'ariaLabel || null',\n    '[attr.aria-required]': 'required.toString()',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '[attr.aria-invalid]': 'errorState',\n    '[attr.aria-activedescendant]': '_getAriaActiveDescendant()',\n    '[class.mat-select-disabled]': 'disabled',\n    '[class.mat-select-invalid]': 'errorState',\n    '[class.mat-select-required]': 'required',\n    '[class.mat-select-empty]': 'empty',\n    '[class.mat-select-multiple]': 'multiple',\n    '(keydown)': '_handleKeydown($event)',\n    '(focus)': '_onFocus()',\n    '(blur)': '_onBlur()',\n  },\n  animations: [matSelectAnimations.transformPanelWrap, matSelectAnimations.transformPanel],\n  providers: [\n    {provide: MatFormFieldControl, useExisting: MatSelect},\n    {provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatSelect},\n  ],\n})\nexport class MatSelect extends _MatSelectBase<MatSelectChange> implements OnInit {\n  /** The scroll position of the overlay panel, calculated to center the selected option. */\n  private _scrollTop = 0;\n\n  /** The last measured value for the trigger's client bounding rect. */\n  _triggerRect: ClientRect;\n\n  /** The cached font-size of the trigger element. */\n  _triggerFontSize = 0;\n\n  /** The value of the select panel's transform-origin property. */\n  _transformOrigin: string = 'top';\n\n  /**\n   * The y-offset of the overlay panel in relation to the trigger's top start corner.\n   * This must be adjusted to align the selected option text over the trigger text.\n   * when the panel opens. Will change based on the y-position of the selected option.\n   */\n  _offsetY = 0;\n\n  @ContentChildren(MatOption, {descendants: true}) options: QueryList<MatOption>;\n\n  @ContentChildren(MAT_OPTGROUP, {descendants: true}) optionGroups: QueryList<MatOptgroup>;\n\n  @ContentChild(MAT_SELECT_TRIGGER) customTrigger: MatSelectTrigger;\n\n  _positions: ConnectedPosition[] = [\n    {\n      originX: 'start',\n      originY: 'top',\n      overlayX: 'start',\n      overlayY: 'top',\n    },\n    {\n      originX: 'start',\n      originY: 'bottom',\n      overlayX: 'start',\n      overlayY: 'bottom',\n    },\n  ];\n\n  /**\n   * Calculates the scroll position of the select's overlay panel.\n   *\n   * Attempts to center the selected option in the panel. If the option is\n   * too high or too low in the panel to be scrolled to the center, it clamps the\n   * scroll position to the min or max scroll positions respectively.\n   */\n  _calculateOverlayScroll(selectedIndex: number, scrollBuffer: number, maxScroll: number): number {\n    const itemHeight = this._getItemHeight();\n    const optionOffsetFromScrollTop = itemHeight * selectedIndex;\n    const halfOptionHeight = itemHeight / 2;\n\n    // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the\n    // scroll container, then subtracts the scroll buffer to scroll the option down to\n    // the center of the overlay panel. Half the option height must be re-added to the\n    // scrollTop so the option is centered based on its middle, not its top edge.\n    const optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;\n    return Math.min(Math.max(0, optimalScrollPosition), maxScroll);\n  }\n\n  override ngOnInit() {\n    super.ngOnInit();\n    this._viewportRuler\n      .change()\n      .pipe(takeUntil(this._destroy))\n      .subscribe(() => {\n        if (this.panelOpen) {\n          this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();\n          this._changeDetectorRef.markForCheck();\n        }\n      });\n  }\n\n  override open(): void {\n    if (super._canOpen()) {\n      super.open();\n      this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();\n      // Note: The computed font-size will be a string pixel value (e.g. \"16px\").\n      // `parseInt` ignores the trailing 'px' and converts this to a number.\n      this._triggerFontSize = parseInt(\n        getComputedStyle(this.trigger.nativeElement).fontSize || '0',\n      );\n      this._calculateOverlayPosition();\n\n      // Set the font size on the panel element once it exists.\n      this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n        if (\n          this._triggerFontSize &&\n          this._overlayDir.overlayRef &&\n          this._overlayDir.overlayRef.overlayElement\n        ) {\n          this._overlayDir.overlayRef.overlayElement.style.fontSize = `${this._triggerFontSize}px`;\n        }\n      });\n    }\n  }\n\n  /** Scrolls the active option into view. */\n  protected _scrollOptionIntoView(index: number): void {\n    const labelCount = _countGroupLabelsBeforeOption(index, this.options, this.optionGroups);\n    const itemHeight = this._getItemHeight();\n\n    if (index === 0 && labelCount === 1) {\n      // If we've got one group label before the option and we're at the top option,\n      // scroll the list to the top. This is better UX than scrolling the list to the\n      // top of the option, because it allows the user to read the top group's label.\n      this.panel.nativeElement.scrollTop = 0;\n    } else {\n      this.panel.nativeElement.scrollTop = _getOptionScrollPosition(\n        (index + labelCount) * itemHeight,\n        itemHeight,\n        this.panel.nativeElement.scrollTop,\n        SELECT_PANEL_MAX_HEIGHT,\n      );\n    }\n  }\n\n  protected _positioningSettled() {\n    this._calculateOverlayOffsetX();\n    this.panel.nativeElement.scrollTop = this._scrollTop;\n  }\n\n  protected override _panelDoneAnimating(isOpen: boolean) {\n    if (this.panelOpen) {\n      this._scrollTop = 0;\n    } else {\n      this._overlayDir.offsetX = 0;\n      this._changeDetectorRef.markForCheck();\n    }\n\n    super._panelDoneAnimating(isOpen);\n  }\n\n  protected _getChangeEvent(value: any) {\n    return new MatSelectChange(this, value);\n  }\n\n  /**\n   * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.\n   * This must be adjusted to align the selected option text over the trigger text when\n   * the panel opens. Will change based on LTR or RTL text direction. Note that the offset\n   * can't be calculated until the panel has been attached, because we need to know the\n   * content width in order to constrain the panel within the viewport.\n   */\n  private _calculateOverlayOffsetX(): void {\n    const overlayRect = this._overlayDir.overlayRef.overlayElement.getBoundingClientRect();\n    const viewportSize = this._viewportRuler.getViewportSize();\n    const isRtl = this._isRtl();\n    const paddingWidth = this.multiple\n      ? SELECT_MULTIPLE_PANEL_PADDING_X + SELECT_PANEL_PADDING_X\n      : SELECT_PANEL_PADDING_X * 2;\n    let offsetX: number;\n\n    // Adjust the offset, depending on the option padding.\n    if (this.multiple) {\n      offsetX = SELECT_MULTIPLE_PANEL_PADDING_X;\n    } else if (this.disableOptionCentering) {\n      offsetX = SELECT_PANEL_PADDING_X;\n    } else {\n      let selected = this._selectionModel.selected[0] || this.options.first;\n      offsetX = selected && selected.group ? SELECT_PANEL_INDENT_PADDING_X : SELECT_PANEL_PADDING_X;\n    }\n\n    // Invert the offset in LTR.\n    if (!isRtl) {\n      offsetX *= -1;\n    }\n\n    // Determine how much the select overflows on each side.\n    const leftOverflow = 0 - (overlayRect.left + offsetX - (isRtl ? paddingWidth : 0));\n    const rightOverflow =\n      overlayRect.right + offsetX - viewportSize.width + (isRtl ? 0 : paddingWidth);\n\n    // If the element overflows on either side, reduce the offset to allow it to fit.\n    if (leftOverflow > 0) {\n      offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;\n    } else if (rightOverflow > 0) {\n      offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;\n    }\n\n    // Set the offset directly in order to avoid having to go through change detection and\n    // potentially triggering \"changed after it was checked\" errors. Round the value to avoid\n    // blurry content in some browsers.\n    this._overlayDir.offsetX = Math.round(offsetX);\n    this._overlayDir.overlayRef.updatePosition();\n  }\n\n  /**\n   * Calculates the y-offset of the select's overlay panel in relation to the\n   * top start corner of the trigger. It has to be adjusted in order for the\n   * selected option to be aligned over the trigger when the panel opens.\n   */\n  private _calculateOverlayOffsetY(\n    selectedIndex: number,\n    scrollBuffer: number,\n    maxScroll: number,\n  ): number {\n    const itemHeight = this._getItemHeight();\n    const optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;\n    const maxOptionsDisplayed = Math.floor(SELECT_PANEL_MAX_HEIGHT / itemHeight);\n    let optionOffsetFromPanelTop: number;\n\n    // Disable offset if requested by user by returning 0 as value to offset\n    if (this.disableOptionCentering) {\n      return 0;\n    }\n\n    if (this._scrollTop === 0) {\n      optionOffsetFromPanelTop = selectedIndex * itemHeight;\n    } else if (this._scrollTop === maxScroll) {\n      const firstDisplayedIndex = this._getItemCount() - maxOptionsDisplayed;\n      const selectedDisplayIndex = selectedIndex - firstDisplayedIndex;\n\n      // The first item is partially out of the viewport. Therefore we need to calculate what\n      // portion of it is shown in the viewport and account for it in our offset.\n      let partialItemHeight =\n        itemHeight - ((this._getItemCount() * itemHeight - SELECT_PANEL_MAX_HEIGHT) % itemHeight);\n\n      // Because the panel height is longer than the height of the options alone,\n      // there is always extra padding at the top or bottom of the panel. When\n      // scrolled to the very bottom, this padding is at the top of the panel and\n      // must be added to the offset.\n      optionOffsetFromPanelTop = selectedDisplayIndex * itemHeight + partialItemHeight;\n    } else {\n      // If the option was scrolled to the middle of the panel using a scroll buffer,\n      // its offset will be the scroll buffer minus the half height that was added to\n      // center it.\n      optionOffsetFromPanelTop = scrollBuffer - itemHeight / 2;\n    }\n\n    // The final offset is the option's offset from the top, adjusted for the height difference,\n    // multiplied by -1 to ensure that the overlay moves in the correct direction up the page.\n    // The value is rounded to prevent some browsers from blurring the content.\n    return Math.round(optionOffsetFromPanelTop * -1 - optionHeightAdjustment);\n  }\n\n  /**\n   * Checks that the attempted overlay position will fit within the viewport.\n   * If it will not fit, tries to adjust the scroll position and the associated\n   * y-offset so the panel can open fully on-screen. If it still won't fit,\n   * sets the offset back to 0 to allow the fallback position to take over.\n   */\n  private _checkOverlayWithinViewport(maxScroll: number): void {\n    const itemHeight = this._getItemHeight();\n    const viewportSize = this._viewportRuler.getViewportSize();\n\n    const topSpaceAvailable = this._triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;\n    const bottomSpaceAvailable =\n      viewportSize.height - this._triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;\n\n    const panelHeightTop = Math.abs(this._offsetY);\n    const totalPanelHeight = Math.min(this._getItemCount() * itemHeight, SELECT_PANEL_MAX_HEIGHT);\n    const panelHeightBottom = totalPanelHeight - panelHeightTop - this._triggerRect.height;\n\n    if (panelHeightBottom > bottomSpaceAvailable) {\n      this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);\n    } else if (panelHeightTop > topSpaceAvailable) {\n      this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);\n    } else {\n      this._transformOrigin = this._getOriginBasedOnOption();\n    }\n  }\n\n  /** Adjusts the overlay panel up to fit in the viewport. */\n  private _adjustPanelUp(panelHeightBottom: number, bottomSpaceAvailable: number) {\n    // Browsers ignore fractional scroll offsets, so we need to round.\n    const distanceBelowViewport = Math.round(panelHeightBottom - bottomSpaceAvailable);\n\n    // Scrolls the panel up by the distance it was extending past the boundary, then\n    // adjusts the offset by that amount to move the panel up into the viewport.\n    this._scrollTop -= distanceBelowViewport;\n    this._offsetY -= distanceBelowViewport;\n    this._transformOrigin = this._getOriginBasedOnOption();\n\n    // If the panel is scrolled to the very top, it won't be able to fit the panel\n    // by scrolling, so set the offset to 0 to allow the fallback position to take\n    // effect.\n    if (this._scrollTop <= 0) {\n      this._scrollTop = 0;\n      this._offsetY = 0;\n      this._transformOrigin = `50% bottom 0px`;\n    }\n  }\n\n  /** Adjusts the overlay panel down to fit in the viewport. */\n  private _adjustPanelDown(panelHeightTop: number, topSpaceAvailable: number, maxScroll: number) {\n    // Browsers ignore fractional scroll offsets, so we need to round.\n    const distanceAboveViewport = Math.round(panelHeightTop - topSpaceAvailable);\n\n    // Scrolls the panel down by the distance it was extending past the boundary, then\n    // adjusts the offset by that amount to move the panel down into the viewport.\n    this._scrollTop += distanceAboveViewport;\n    this._offsetY += distanceAboveViewport;\n    this._transformOrigin = this._getOriginBasedOnOption();\n\n    // If the panel is scrolled to the very bottom, it won't be able to fit the\n    // panel by scrolling, so set the offset to 0 to allow the fallback position\n    // to take effect.\n    if (this._scrollTop >= maxScroll) {\n      this._scrollTop = maxScroll;\n      this._offsetY = 0;\n      this._transformOrigin = `50% top 0px`;\n      return;\n    }\n  }\n\n  /** Calculates the scroll position and x- and y-offsets of the overlay panel. */\n  private _calculateOverlayPosition(): void {\n    const itemHeight = this._getItemHeight();\n    const items = this._getItemCount();\n    const panelHeight = Math.min(items * itemHeight, SELECT_PANEL_MAX_HEIGHT);\n    const scrollContainerHeight = items * itemHeight;\n\n    // The farthest the panel can be scrolled before it hits the bottom\n    const maxScroll = scrollContainerHeight - panelHeight;\n\n    // If no value is selected we open the popup to the first item.\n    let selectedOptionOffset: number;\n\n    if (this.empty) {\n      selectedOptionOffset = 0;\n    } else {\n      selectedOptionOffset = Math.max(\n        this.options.toArray().indexOf(this._selectionModel.selected[0]),\n        0,\n      );\n    }\n\n    selectedOptionOffset += _countGroupLabelsBeforeOption(\n      selectedOptionOffset,\n      this.options,\n      this.optionGroups,\n    );\n\n    // We must maintain a scroll buffer so the selected option will be scrolled to the\n    // center of the overlay panel rather than the top.\n    const scrollBuffer = panelHeight / 2;\n    this._scrollTop = this._calculateOverlayScroll(selectedOptionOffset, scrollBuffer, maxScroll);\n    this._offsetY = this._calculateOverlayOffsetY(selectedOptionOffset, scrollBuffer, maxScroll);\n\n    this._checkOverlayWithinViewport(maxScroll);\n  }\n\n  /** Sets the transform origin point based on the selected option. */\n  private _getOriginBasedOnOption(): string {\n    const itemHeight = this._getItemHeight();\n    const optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;\n    const originY = Math.abs(this._offsetY) - optionHeightAdjustment + itemHeight / 2;\n    return `50% ${originY}px 0px`;\n  }\n\n  /** Calculates the height of the select's options. */\n  private _getItemHeight(): number {\n    return this._triggerFontSize * SELECT_ITEM_HEIGHT_EM;\n  }\n\n  /** Calculates the amount of items in the select. This includes options and group labels. */\n  private _getItemCount(): number {\n    return this.options.length + this.optionGroups.length;\n  }\n}\n","<!--\n Note that the select trigger element specifies `aria-owns` pointing to the listbox overlay.\n While aria-owns is not required for the ARIA 1.2 `role=\"combobox\"` interaction pattern,\n it fixes an issue with VoiceOver when the select appears inside of an `aria-model=\"true\"`\n element (e.g. a dialog). Without this `aria-owns`, the `aria-modal` on a dialog prevents\n VoiceOver from \"seeing\" the select's listbox overlay for aria-activedescendant.\n Using `aria-owns` re-parents the select overlay so that it works again.\n See https://github.com/angular/components/issues/20694\n-->\n<div cdk-overlay-origin\n     [attr.aria-owns]=\"panelOpen ? id + '-panel' : null\"\n     class=\"mat-select-trigger\"\n     (click)=\"toggle()\"\n     #origin=\"cdkOverlayOrigin\"\n     #trigger>\n  <div class=\"mat-select-value\" [ngSwitch]=\"empty\" [attr.id]=\"_valueId\">\n    <span class=\"mat-select-placeholder mat-select-min-line\" *ngSwitchCase=\"true\">{{placeholder}}</span>\n    <span class=\"mat-select-value-text\" *ngSwitchCase=\"false\" [ngSwitch]=\"!!customTrigger\">\n      <span class=\"mat-select-min-line\" *ngSwitchDefault>{{triggerValue}}</span>\n      <ng-content select=\"mat-select-trigger\" *ngSwitchCase=\"true\"></ng-content>\n    </span>\n  </div>\n\n  <div class=\"mat-select-arrow-wrapper\"><div class=\"mat-select-arrow\"></div></div>\n</div>\n\n<ng-template\n  cdk-connected-overlay\n  cdkConnectedOverlayLockPosition\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayPanelClass]=\"_overlayPanelClass\"\n  [cdkConnectedOverlayScrollStrategy]=\"_scrollStrategy\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width!\"\n  [cdkConnectedOverlayOffsetY]=\"_offsetY\"\n  (backdropClick)=\"close()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"close()\">\n  <div class=\"mat-select-panel-wrap\" [@transformPanelWrap]>\n    <div\n      #panel\n      role=\"listbox\"\n      tabindex=\"-1\"\n      class=\"mat-select-panel {{ _getPanelTheme() }}\"\n      [attr.id]=\"id + '-panel'\"\n      [attr.aria-multiselectable]=\"multiple\"\n      [attr.aria-label]=\"ariaLabel || null\"\n      [attr.aria-labelledby]=\"_getPanelAriaLabelledby()\"\n      [ngClass]=\"panelClass\"\n      [@transformPanel]=\"multiple ? 'showing-multiple' : 'showing'\"\n      (@transformPanel.done)=\"_panelDoneAnimatingStream.next($event.toState)\"\n      [style.transformOrigin]=\"_transformOrigin\"\n      [style.font-size.px]=\"_triggerFontSize\"\n      (keydown)=\"_handleKeydown($event)\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatOptionModule} from '@angular/material/core';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {MAT_SELECT_SCROLL_STRATEGY_PROVIDER, MatSelect, MatSelectTrigger} from './select';\n\n@NgModule({\n  imports: [CommonModule, OverlayModule, MatOptionModule, MatCommonModule],\n  exports: [\n    CdkScrollableModule,\n    MatFormFieldModule,\n    MatSelect,\n    MatSelectTrigger,\n    MatOptionModule,\n    MatCommonModule,\n  ],\n  declarations: [MatSelect, MatSelectTrigger],\n  providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER],\n})\nexport class MatSelectModule {}\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * Material select layout metadata loader\n */\nexport const MaterialSelectLayoutMetadataLoader = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* () {\n    return new (yield import('./metadata/select.layoutMetadata')).MaterialSelectLayoutEditorMetadata();\n  });\n\n  return function MaterialSelectLayoutMetadataLoader() {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Material select relations metadata loader\n */\n\nexport const MaterialSelectRelationsMetadataLoader = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* () {\n    return new (yield import('./metadata/select.relationsMetadata')).MaterialSelectRelationsEditorMetadata();\n  });\n\n  return function MaterialSelectRelationsMetadataLoader() {\n    return _ref2.apply(this, arguments);\n  };\n}();","import { __decorate } from \"tslib\";\nimport { Component, ChangeDetectionStrategy, Input } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatSelectModule } from '@angular/material/select';\nimport { LayoutEditorMetadata } from '@anglr/dynamic/layout-editor';\nimport { CastPipesModule, HostDisplayBlockStyle } from '@anglr/common';\nimport { FormPipesModule } from '@anglr/common/forms';\nimport { FormComponentBase, FormComponentControlSAPipe } from '@anglr/dynamic/form';\nimport { RelationsEditorMetadata } from '@anglr/dynamic/relations-editor';\nimport { MaterialSelectLayoutMetadataLoader, MaterialSelectRelationsMetadataLoader } from './select.metadata';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@anglr/common/forms\";\nimport * as i2 from \"@anglr/common\";\nimport * as i3 from \"@angular/forms\";\nimport * as i4 from \"@angular/common\";\nimport * as i5 from \"@angular/material/form-field\";\nimport * as i6 from \"@angular/material/select\";\nimport * as i7 from \"@angular/material/core\";\n/**\n * Component used for displaying material text field\n */\n\nfunction MaterialSelectSAComponent_mat_option_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-option\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const value_r1 = ctx.$implicit;\n    i0.ɵɵproperty(\"value\", value_r1);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(value_r1);\n  }\n}\n\nlet MaterialSelectSAComponent = class MaterialSelectSAComponent extends FormComponentBase {\n  constructor() {\n    super(...arguments); //######################### public properties #########################\n\n    this._values = [{\n      code: 'foo',\n      value: 'foo value'\n    }, {\n      code: 'bar',\n      value: 'bar value'\n    }];\n  } //######################### poublic properties - inputs and outputs #########################\n\n  /**\n   * Indication whether form component is disabled\n   */\n\n\n  set values(value) {\n    this._values = value;\n  }\n\n  get values() {\n    return this._values;\n  }\n\n};\n\nMaterialSelectSAComponent.ɵfac = /* @__PURE__ */function () {\n  let ɵMaterialSelectSAComponent_BaseFactory;\n  return function MaterialSelectSAComponent_Factory(t) {\n    return (ɵMaterialSelectSAComponent_BaseFactory || (ɵMaterialSelectSAComponent_BaseFactory = i0.ɵɵgetInheritedFactory(MaterialSelectSAComponent)))(t || MaterialSelectSAComponent);\n  };\n}();\n\nMaterialSelectSAComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: MaterialSelectSAComponent,\n  selectors: [[\"material-select\"]],\n  inputs: {\n    values: \"values\"\n  },\n  standalone: true,\n  features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n  decls: 10,\n  vars: 12,\n  consts: [[3, \"appearance\"], [3, \"multiple\", \"formControl\"], [3, \"value\", 4, \"ngFor\", \"ngForOf\"], [3, \"value\"]],\n  template: function MaterialSelectSAComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"mat-form-field\", 0);\n      i0.ɵɵpipe(1, \"asRequired\");\n      i0.ɵɵelementStart(2, \"mat-label\");\n      i0.ɵɵtext(3);\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(4, \"mat-select\", 1);\n      i0.ɵɵpipe(5, \"asRequired\");\n      i0.ɵɵpipe(6, \"asFormControl\");\n      i0.ɵɵtemplate(7, MaterialSelectSAComponent_mat_option_7_Template, 2, 2, \"mat-option\", 2);\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(8, \"mat-hint\");\n      i0.ɵɵtext(9);\n      i0.ɵɵelementEnd()();\n    }\n\n    if (rf & 2) {\n      i0.ɵɵproperty(\"appearance\", i0.ɵɵpipeBind1(1, 6, ctx.options == null ? null : ctx.options.appearance));\n      i0.ɵɵadvance(3);\n      i0.ɵɵtextInterpolate(ctx.options == null ? null : ctx.options.label);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"multiple\", ctx.options == null ? null : ctx.options.multiple)(\"formControl\", i0.ɵɵpipeBind1(5, 8, i0.ɵɵpipeBind1(6, 10, ctx.control)));\n      i0.ɵɵadvance(3);\n      i0.ɵɵproperty(\"ngForOf\", ctx.values);\n      i0.ɵɵadvance(2);\n      i0.ɵɵtextInterpolate(ctx.options == null ? null : ctx.options.hint);\n    }\n  },\n  dependencies: [FormPipesModule, i1.AsFormControlPipe, CastPipesModule, i2.AsRequiredTypePipe, ReactiveFormsModule, i3.NgControlStatus, i3.FormControlDirective, CommonModule, i4.NgForOf, MatFormFieldModule, i5.MatFormField, i5.MatHint, i5.MatLabel, MatSelectModule, i6.MatSelect, i7.MatOption],\n  styles: [\"[_nghost-%COMP%]{display: block;}\"],\n  changeDetection: 0\n});\nMaterialSelectSAComponent = __decorate([RelationsEditorMetadata(MaterialSelectRelationsMetadataLoader), LayoutEditorMetadata(MaterialSelectLayoutMetadataLoader)], MaterialSelectSAComponent);\nexport { MaterialSelectSAComponent };\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MaterialSelectSAComponent, [{\n    type: Component,\n    args: [{\n      selector: 'material-select',\n      standalone: true,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      imports: [FormPipesModule, CastPipesModule, FormComponentControlSAPipe, ReactiveFormsModule, CommonModule, MatFormFieldModule, MatSelectModule],\n      template: \"<mat-form-field [appearance]=\\\"options?.appearance|asRequired\\\">\\n    <mat-label>{{options?.label}}</mat-label>\\n    <mat-select [multiple]=\\\"options?.multiple\\\" [formControl]=\\\"control|asFormControl|asRequired\\\">\\n        <mat-option *ngFor=\\\"let value of values\\\" [value]=\\\"value\\\">{{value}}</mat-option>\\n    </mat-select>\\n    <mat-hint>{{options?.hint}}</mat-hint>\\n</mat-form-field>\",\n      styles: [\":host{display: block;}\"]\n    }]\n  }], null, {\n    values: [{\n      type: Input\n    }]\n  });\n})();","import { ComponentStylingExtension } from '@anglr/dynamic/layout';\nimport { RelationsRegistrationExtension } from '@anglr/dynamic/relations';\nimport { MaterialSelectSAComponent } from './select.component';\nexport default MaterialSelectSAComponent;\nexport const extensions = [ComponentStylingExtension, RelationsRegistrationExtension];"],"names":["ListKeyManager","constructor","_items","_activeItemIndex","_activeItem","_wrap","_letterKeyStream","Subject","_typeaheadSubscription","Subscription","_vertical","_allowedModifierKeys","_homeAndEnd","_skipPredicateFn","item","disabled","_pressedLetters","tabOut","change","QueryList","changes","subscribe","newItems","this","newIndex","toArray","indexOf","skipPredicate","predicate","withWrap","shouldWrap","withVerticalOrientation","enabled","withHorizontalOrientation","direction","_horizontal","withAllowedModifierKeys","keys","withTypeAhead","debounceInterval","unsubscribe","pipe","tap","letter","push","debounceTime","filter","length","map","join","inputString","items","_getItemsArray","i","index","getLabel","toUpperCase","trim","setActiveItem","withHomeAndEnd","previousActiveItem","updateActiveItem","next","onKeydown","event","keyCode","isModifierAllowed","every","modifier","TAB","DOWN_ARROW","setNextItemActive","UP_ARROW","setPreviousItemActive","RIGHT_ARROW","LEFT_ARROW","HOME","setFirstItemActive","END","setLastItemActive","hasModifierKey","key","toLocaleUpperCase","A","Z","ZERO","NINE","String","fromCharCode","preventDefault","activeItemIndex","activeItem","isTyping","_setActiveItemByIndex","_setActiveItemByDelta","itemArray","delta","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","ɵɵclassMapInterpolate1","prefix","v0","suffix","lView","getLView","interpolatedValue","interpolation1","checkStylingMap","keyValueArraySet","classStringParser","ɵɵclassMapInterpolate2","i0","v1","interpolation2","ɵɵclassMapInterpolate3","i1","v2","interpolation3","ɵɵclassMapInterpolate4","i2","v3","interpolation4","ɵɵclassMapInterpolate5","i3","v4","interpolation5","ɵɵclassMapInterpolate6","i4","v5","interpolation6","ɵɵclassMapInterpolate7","i5","v6","interpolation7","ɵɵclassMapInterpolate8","i6","v7","interpolation8","ɵɵclassMapInterpolateV","values","interpolationV","MatPseudoCheckboxModule","MatCommonModule","MatOptionModule","MatRippleModule","CommonModule","ActiveDescendantKeyManager","setInactiveStyles","super","setActiveStyles","SelectionModel","_multiple","initiallySelectedValues","_emitChanges","compareWith","_selection","Set","_deselectedToEmit","_selectedToEmit","changed","forEach","value","_markSelected","selected","_selected","Array","from","select","_verifyValueAssignment","_hasQueuedChanges","_emitChangeEvent","deselect","_unmarkSelected","setSelection","oldValues","newSelectedSet","has","toggle","isSelected","clear","flushEvent","_unmarkAll","otherValue","isEmpty","size","hasValue","sort","isMultipleSelection","source","added","removed","add","delete","MAT_OPTION_PARENT_COMPONENT","InjectionToken","_MatOptgroupMixinBase","mixinDisabled","_uniqueOptgroupIdCounter","_MatOptgroupBase","parent","_labelId","_inert","inertGroups","MAT_OPTGROUP","MatOptgroup","provide","useExisting","MatPseudoCheckbox","_animationMode","state","ANIMATION_MODULE_TYPE","_uniqueIdCounter","MatOptionSelectionChange","isUserInput","_MatOptionBase","_element","_changeDetectorRef","_parent","group","_active","_disabled","_mostRecentViewValue","id","onSelectionChange","EventEmitter","_stateChanges","multiple","coerceBooleanProperty","disableRipple","active","viewValue","_getHostElement","textContent","markForCheck","_emitSelectionChangeEvent","focus","_origin","options","element","_handleKeydown","ENTER","SPACE","_selectViaInteraction","_getAriaSelected","_getTabIndex","nativeElement","ngAfterViewChecked","ngOnDestroy","complete","emit","MatOption","changeDetectorRef","_countGroupLabelsBeforeOption","optionIndex","optionGroups","optionsArray","groups","groupCounter","matSelectAnimations","transformPanelWrap","trigger","transition","query","animateChild","optional","transformPanel","style","transform","minWidth","opacity","animate","LIVE_ANNOUNCER_ELEMENT_TOKEN","providedIn","factory","LIVE_ANNOUNCER_DEFAULT_OPTIONS","LiveAnnouncer","elementToken","_ngZone","_document","_defaultOptions","_liveElement","_createLiveElement","announce","message","args","defaultOptions","politeness","duration","clearTimeout","_previousTimeout","setAttribute","runOutsideAngular","_currentPromise","Promise","resolve","_currentResolve","setTimeout","undefined","remove","elementClass","previousElements","getElementsByClassName","liveEl","createElement","classList","body","appendChild","DOCUMENT","CdkAriaLive","_elementRef","_liveAnnouncer","_contentObserver","_politeness","_subscription","observe","elementText","_previousAnnouncedText","nextUniqueId","SELECT_PANEL_MAX_HEIGHT","MAT_SELECT_SCROLL_STRATEGY","MAT_SELECT_CONFIG","MAT_SELECT_SCROLL_STRATEGY_PROVIDER","deps","Overlay","useFactory","overlay","scrollStrategies","reposition","MatSelectChange","_MatSelectMixinBase","mixinDisableRipple","mixinTabIndex","mixinErrorState","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","stateChanges","MAT_SELECT_TRIGGER","MatSelectTrigger","_MatSelectBase","_viewportRuler","elementRef","_dir","_parentFormField","tabIndex","scrollStrategyFactory","_panelOpen","_compareWith","o1","o2","_uid","_triggerAriaLabelledBy","_destroy","_onChange","_onTouched","_valueId","_panelDoneAnimatingStream","_overlayPanelClass","overlayPanelClass","_focused","controlType","_disableOptionCentering","disableOptionCentering","ariaLabel","optionSelectionChanges","defer","startWith","switchMap","merge","option","onStable","take","openedChange","_openedStream","o","_closedStream","selectionChange","valueChange","valueAccessor","typeaheadDebounceInterval","_typeaheadDebounceInterval","_scrollStrategyFactory","_scrollStrategy","parseInt","focused","placeholder","_placeholder","required","_required","control","hasValidator","Validators","_selectionModel","fn","_initializeSelection","_value","newValue","_assignValue","coerceNumberProperty","_id","ngOnInit","distinctUntilChanged","takeUntil","_panelDoneAnimating","panelOpen","ngAfterContentInit","_initKeyManager","_resetOptions","ngDoCheck","newAriaLabelledby","_getTriggerAriaLabelledby","removeAttribute","_previousControl","updateErrorState","ngOnChanges","_keyManager","close","open","_canOpen","_highlightCorrectOption","_isRtl","writeValue","registerOnChange","registerOnTouched","setDisabledState","isDisabled","triggerValue","empty","selectedOptions","reverse","_handleOpenKeydown","_handleClosedKeydown","isArrowKey","isOpenKey","manager","altKey","previouslySelectedOption","selectedOption","ctrlKey","hasDeselectedOptions","some","opt","previouslyFocusedIndex","shiftKey","_onFocus","_onBlur","_onAttached","_overlayDir","positionChange","detectChanges","_positioningSettled","_getPanelTheme","color","then","_setSelectionByValue","isArray","currentValue","_selectOptionByValue","_sortValues","correspondingOption","find","error","panel","_scrollOptionIntoView","changedOrDestroyed","_onSelect","wasSelected","_propagateChanges","a","b","sortComparator","fallbackValue","valueToEmit","_getChangeEvent","_getPanelAriaLabelledby","labelId","getLabelId","labelExpression","ariaLabelledby","_getAriaActiveDescendant","isOpen","setDescribedByIds","ids","onContainerClick","shouldLabelFloat","MAT_FORM_FIELD","CdkConnectedOverlay","MatSelect","_scrollTop","_triggerFontSize","_transformOrigin","_offsetY","_positions","originX","originY","overlayX","overlayY","_calculateOverlayScroll","selectedIndex","scrollBuffer","maxScroll","itemHeight","_getItemHeight","optimalScrollPosition","Math","min","max","_triggerRect","getBoundingClientRect","getComputedStyle","fontSize","_calculateOverlayPosition","overlayRef","overlayElement","labelCount","optionOffset","optionHeight","currentScrollPosition","scrollTop","_calculateOverlayOffsetX","offsetX","overlayRect","viewportSize","getViewportSize","isRtl","paddingWidth","SELECT_MULTIPLE_PANEL_PADDING_X","SELECT_PANEL_PADDING_X","first","leftOverflow","left","rightOverflow","right","width","round","updatePosition","_calculateOverlayOffsetY","optionHeightAdjustment","height","maxOptionsDisplayed","floor","optionOffsetFromPanelTop","_getItemCount","_checkOverlayWithinViewport","topSpaceAvailable","top","bottomSpaceAvailable","bottom","panelHeightTop","abs","panelHeightBottom","_adjustPanelUp","_adjustPanelDown","_getOriginBasedOnOption","distanceBelowViewport","distanceAboveViewport","panelHeight","selectedOptionOffset","MatFormFieldControl","i7","MatSelectModule","OverlayModule","CdkScrollableModule","MatFormFieldModule","asyncGeneratorStep","gen","reject","_next","_throw","arg","info","done","_asyncToGenerator","self","arguments","apply","err","MaterialSelectLayoutMetadataLoader","_ref","MaterialSelectLayoutEditorMetadata","MaterialSelectRelationsMetadataLoader","_ref2","MaterialSelectRelationsEditorMetadata","MaterialSelectSAComponent_mat_option_7_Template","rf","ctx","value_r1","$implicit","MaterialSelectSAComponent","_values","code","t","type","selectors","inputs","standalone","features","decls","vars","consts","template","appearance","label","hint","dependencies","styles","changeDetection","extensions"],"sourceRoot":""}