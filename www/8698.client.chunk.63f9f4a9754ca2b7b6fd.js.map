{"version":3,"file":"8698.client.chunk.63f9f4a9754ca2b7b6fd.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../src/cdk/text-field/text-field-module.ts","webpack://ng-universal-demo/../../../src/material/input/input-value-accessor.ts","webpack://ng-universal-demo/../../../src/cdk/platform/features/input-types.ts","webpack://ng-universal-demo/../../../src/cdk/text-field/autofill.ts","webpack://ng-universal-demo/../../../src/material/input/input.ts","webpack://ng-universal-demo/../../../src/material/input/module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkAutofill} from './autofill';\nimport {CdkTextareaAutosize} from './autosize';\n\n@NgModule({\n  declarations: [CdkAutofill, CdkTextareaAutosize],\n  exports: [CdkAutofill, CdkTextareaAutosize],\n})\nexport class TextFieldModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nexport const MAT_INPUT_VALUE_ACCESSOR = new InjectionToken<{value: any}>(\n  'MAT_INPUT_VALUE_ACCESSOR',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Cached result Set of input types support by the current browser. */\nlet supportedInputTypes: Set<string>;\n\n/** Types of `<input>` that *might* be supported. */\nconst candidateInputTypes = [\n  // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n  // first changing it to something else:\n  // The specified value \"\" does not conform to the required format.\n  // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n  'color',\n  'button',\n  'checkbox',\n  'date',\n  'datetime-local',\n  'email',\n  'file',\n  'hidden',\n  'image',\n  'month',\n  'number',\n  'password',\n  'radio',\n  'range',\n  'reset',\n  'search',\n  'submit',\n  'tel',\n  'text',\n  'time',\n  'url',\n  'week',\n];\n\n/** @returns The input types supported by this browser. */\nexport function getSupportedInputTypes(): Set<string> {\n  // Result is cached.\n  if (supportedInputTypes) {\n    return supportedInputTypes;\n  }\n\n  // We can't check if an input type is not supported until we're on the browser, so say that\n  // everything is supported when not on the browser. We don't use `Platform` here since it's\n  // just a helper function and can't inject it.\n  if (typeof document !== 'object' || !document) {\n    supportedInputTypes = new Set(candidateInputTypes);\n    return supportedInputTypes;\n  }\n\n  let featureTestInput = document.createElement('input');\n  supportedInputTypes = new Set(\n    candidateInputTypes.filter(value => {\n      featureTestInput.setAttribute('type', value);\n      return featureTestInput.type === value;\n    }),\n  );\n\n  return supportedInputTypes;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Output,\n} from '@angular/core';\nimport {coerceElement} from '@angular/cdk/coercion';\nimport {EMPTY, Observable, Subject} from 'rxjs';\n\n/** An event that is emitted when the autofill state of an input changes. */\nexport type AutofillEvent = {\n  /** The element whose autofill state changes. */\n  target: Element;\n  /** Whether the element is currently autofilled. */\n  isAutofilled: boolean;\n};\n\n/** Used to track info about currently monitored elements. */\ntype MonitoredElementInfo = {\n  readonly subject: Subject<AutofillEvent>;\n  unlisten: () => void;\n};\n\n/** Options to pass to the animationstart listener. */\nconst listenerOptions = normalizePassiveListenerOptions({passive: true});\n\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\n@Injectable({providedIn: 'root'})\nexport class AutofillMonitor implements OnDestroy {\n  private _monitoredElements = new Map<Element, MonitoredElementInfo>();\n\n  constructor(private _platform: Platform, private _ngZone: NgZone) {}\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: Element): Observable<AutofillEvent>;\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: ElementRef<Element>): Observable<AutofillEvent>;\n\n  monitor(elementOrRef: Element | ElementRef<Element>): Observable<AutofillEvent> {\n    if (!this._platform.isBrowser) {\n      return EMPTY;\n    }\n\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      return info.subject;\n    }\n\n    const result = new Subject<AutofillEvent>();\n    const cssClass = 'cdk-text-field-autofilled';\n    const listener = ((event: AnimationEvent) => {\n      // Animation events fire on initial element render, we check for the presence of the autofill\n      // CSS class to make sure this is a real change in state, not just the initial render before\n      // we fire off events.\n      if (\n        event.animationName === 'cdk-text-field-autofill-start' &&\n        !element.classList.contains(cssClass)\n      ) {\n        element.classList.add(cssClass);\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: true}));\n      } else if (\n        event.animationName === 'cdk-text-field-autofill-end' &&\n        element.classList.contains(cssClass)\n      ) {\n        element.classList.remove(cssClass);\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: false}));\n      }\n    }) as EventListenerOrEventListenerObject;\n\n    this._ngZone.runOutsideAngular(() => {\n      element.addEventListener('animationstart', listener, listenerOptions);\n      element.classList.add('cdk-text-field-autofill-monitored');\n    });\n\n    this._monitoredElements.set(element, {\n      subject: result,\n      unlisten: () => {\n        element.removeEventListener('animationstart', listener, listenerOptions);\n      },\n    });\n\n    return result;\n  }\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: Element): void;\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: ElementRef<Element>): void;\n\n  stopMonitoring(elementOrRef: Element | ElementRef<Element>): void {\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      info.unlisten();\n      info.subject.complete();\n      element.classList.remove('cdk-text-field-autofill-monitored');\n      element.classList.remove('cdk-text-field-autofilled');\n      this._monitoredElements.delete(element);\n    }\n  }\n\n  ngOnDestroy() {\n    this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\n  }\n}\n\n/** A directive that can be used to monitor the autofill state of an input. */\n@Directive({\n  selector: '[cdkAutofill]',\n})\nexport class CdkAutofill implements OnDestroy, OnInit {\n  /** Emits when the autofill state of the element changes. */\n  @Output() readonly cdkAutofill = new EventEmitter<AutofillEvent>();\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    private _autofillMonitor: AutofillMonitor,\n  ) {}\n\n  ngOnInit() {\n    this._autofillMonitor\n      .monitor(this._elementRef)\n      .subscribe(event => this.cdkAutofill.emit(event));\n  }\n\n  ngOnDestroy() {\n    this._autofillMonitor.stopMonitoring(this._elementRef);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {getSupportedInputTypes, Platform} from '@angular/cdk/platform';\nimport {AutofillMonitor} from '@angular/cdk/text-field';\nimport {\n  AfterViewInit,\n  Directive,\n  DoCheck,\n  ElementRef,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Self,\n} from '@angular/core';\nimport {FormGroupDirective, NgControl, NgForm, Validators} from '@angular/forms';\nimport {CanUpdateErrorState, ErrorStateMatcher, mixinErrorState} from '@angular/material/core';\nimport {MatFormFieldControl, MatFormField, MAT_FORM_FIELD} from '@angular/material/form-field';\nimport {Subject} from 'rxjs';\nimport {getMatInputUnsupportedTypeError} from './input-errors';\nimport {MAT_INPUT_VALUE_ACCESSOR} from './input-value-accessor';\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n  'button',\n  'checkbox',\n  'file',\n  'hidden',\n  'image',\n  'radio',\n  'range',\n  'reset',\n  'submit',\n];\n\nlet nextUniqueId = 0;\n\n// Boilerplate for applying mixins to MatInput.\n/** @docs-private */\nconst _MatInputBase = mixinErrorState(\n  class {\n    /**\n     * Emits whenever the component state changes and should cause the parent\n     * form field to update. Implemented as part of `MatFormFieldControl`.\n     * @docs-private\n     */\n    readonly stateChanges = new Subject<void>();\n\n    constructor(\n      public _defaultErrorStateMatcher: ErrorStateMatcher,\n      public _parentForm: NgForm,\n      public _parentFormGroup: FormGroupDirective,\n      /**\n       * Form control bound to the component.\n       * Implemented as part of `MatFormFieldControl`.\n       * @docs-private\n       */\n      public ngControl: NgControl,\n    ) {}\n  },\n);\n\n@Directive({\n  selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n  exportAs: 'matInput',\n  host: {\n    'class': 'mat-mdc-input-element',\n    // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and\n    // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for\n    // this MDC equivalent input.\n    '[class.mat-input-server]': '_isServer',\n    '[class.mat-mdc-form-field-textarea-control]': '_isInFormField && _isTextarea',\n    '[class.mat-mdc-form-field-input-control]': '_isInFormField',\n    '[class.mdc-text-field__input]': '_isInFormField',\n    '[class.mat-mdc-native-select-inline]': '_isInlineSelect()',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[id]': 'id',\n    '[disabled]': 'disabled',\n    '[required]': 'required',\n    '[attr.name]': 'name || null',\n    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n    // Only mark the input as invalid for assistive technology if it has a value since the\n    // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n    '[attr.aria-invalid]': '(empty && required) ? null : errorState',\n    '[attr.aria-required]': 'required',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[attr.id]': 'id',\n    '(focus)': '_focusChanged(true)',\n    '(blur)': '_focusChanged(false)',\n    '(input)': '_onInput()',\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatInput}],\n})\nexport class MatInput\n  extends _MatInputBase\n  implements\n    MatFormFieldControl<any>,\n    OnChanges,\n    OnDestroy,\n    AfterViewInit,\n    DoCheck,\n    CanUpdateErrorState\n{\n  protected _uid = `mat-input-${nextUniqueId++}`;\n  protected _previousNativeValue: any;\n  private _inputValueAccessor: {value: any};\n  private _previousPlaceholder: string | null;\n\n  /** Whether the component is being rendered on the server. */\n  readonly _isServer: boolean;\n\n  /** Whether the component is a native html select. */\n  readonly _isNativeSelect: boolean;\n\n  /** Whether the component is a textarea. */\n  readonly _isTextarea: boolean;\n\n  /** Whether the input is inside of a form field. */\n  readonly _isInFormField: boolean;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  focused: boolean = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  override readonly stateChanges: Subject<void> = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  controlType: string = 'mat-input';\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  autofilled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  protected _disabled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n  }\n  protected _id: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input() placeholder: string;\n\n  /**\n   * Name of the input.\n   * @docs-private\n   */\n  @Input() name: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n  protected _required: boolean | undefined;\n\n  /** Input type of the element. */\n  @Input()\n  get type(): string {\n    return this._type;\n  }\n  set type(value: string) {\n    this._type = value || 'text';\n    this._validateType();\n\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n      (this._elementRef.nativeElement as HTMLInputElement).type = this._type;\n    }\n  }\n  protected _type = 'text';\n\n  /** An object used to control when error messages are shown. */\n  @Input() override errorStateMatcher: ErrorStateMatcher;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get value(): string {\n    return this._inputValueAccessor.value;\n  }\n  set value(value: any) {\n    if (value !== this.value) {\n      this._inputValueAccessor.value = value;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Whether the element is readonly. */\n  @Input()\n  get readonly(): boolean {\n    return this._readonly;\n  }\n  set readonly(value: BooleanInput) {\n    this._readonly = coerceBooleanProperty(value);\n  }\n  private _readonly = false;\n\n  protected _neverEmptyInputTypes = [\n    'date',\n    'datetime',\n    'datetime-local',\n    'month',\n    'time',\n    'week',\n  ].filter(t => getSupportedInputTypes().has(t));\n\n  constructor(\n    protected _elementRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>,\n    protected _platform: Platform,\n    @Optional() @Self() ngControl: NgControl,\n    @Optional() _parentForm: NgForm,\n    @Optional() _parentFormGroup: FormGroupDirective,\n    _defaultErrorStateMatcher: ErrorStateMatcher,\n    @Optional() @Self() @Inject(MAT_INPUT_VALUE_ACCESSOR) inputValueAccessor: any,\n    private _autofillMonitor: AutofillMonitor,\n    ngZone: NgZone,\n    // TODO: Remove this once the legacy appearance has been removed. We only need\n    // to inject the form field for determining whether the placeholder has been promoted.\n    @Optional() @Inject(MAT_FORM_FIELD) protected _formField?: MatFormField,\n  ) {\n    super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n\n    const element = this._elementRef.nativeElement;\n    const nodeName = element.nodeName.toLowerCase();\n\n    // If no input value accessor was explicitly specified, use the element as the input value\n    // accessor.\n    this._inputValueAccessor = inputValueAccessor || element;\n\n    this._previousNativeValue = this.value;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (_platform.IOS) {\n      ngZone.runOutsideAngular(() => {\n        _elementRef.nativeElement.addEventListener('keyup', this._iOSKeyupListener);\n      });\n    }\n\n    this._isServer = !this._platform.isBrowser;\n    this._isNativeSelect = nodeName === 'select';\n    this._isTextarea = nodeName === 'textarea';\n    this._isInFormField = !!_formField;\n\n    if (this._isNativeSelect) {\n      this.controlType = (element as HTMLSelectElement).multiple\n        ? 'mat-native-select-multiple'\n        : 'mat-native-select';\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n\n  ngOnDestroy() {\n    this.stateChanges.complete();\n\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n\n    if (this._platform.IOS) {\n      this._elementRef.nativeElement.removeEventListener('keyup', this._iOSKeyupListener);\n    }\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n\n      // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n      // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n      // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n      // disabled.\n      if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n        this.disabled = this.ngControl.disabled;\n        this.stateChanges.next();\n      }\n    }\n\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n\n    // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n    // present or not depends on a query which is prone to \"changed after checked\" errors.\n    this._dirtyCheckPlaceholder();\n  }\n\n  /** Focuses the input. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Callback for the cases where the focused state of the input changes. */\n  _focusChanged(isFocused: boolean) {\n    if (isFocused !== this.focused) {\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n  }\n\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n\n  /** Does some manual dirty checking on the native input `value` property. */\n  protected _dirtyCheckNativeValue() {\n    const newValue = this._elementRef.nativeElement.value;\n\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Does some manual dirty checking on the native input `placeholder` attribute. */\n  private _dirtyCheckPlaceholder() {\n    const placeholder = this._getPlaceholder();\n    if (placeholder !== this._previousPlaceholder) {\n      const element = this._elementRef.nativeElement;\n      this._previousPlaceholder = placeholder;\n      placeholder\n        ? element.setAttribute('placeholder', placeholder)\n        : element.removeAttribute('placeholder');\n    }\n  }\n\n  /** Gets the current placeholder of the form field. */\n  protected _getPlaceholder(): string | null {\n    return this.placeholder || null;\n  }\n\n  /** Make sure the input is a supported type. */\n  protected _validateType() {\n    if (\n      MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n\n  /** Checks whether the input type is one of the types that are never empty. */\n  protected _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n\n  /** Checks whether the input is invalid based on the native validation. */\n  protected _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let validity = (this._elementRef.nativeElement as HTMLInputElement).validity;\n    return validity && validity.badInput;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get empty(): boolean {\n    return (\n      !this._isNeverEmpty() &&\n      !this._elementRef.nativeElement.value &&\n      !this._isBadInput() &&\n      !this.autofilled\n    );\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    if (this._isNativeSelect) {\n      // For a single-selection `<select>`, the label should float when the selected option has\n      // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n      // overlapping the label with the options.\n      const selectElement = this._elementRef.nativeElement as HTMLSelectElement;\n      const firstOption: HTMLOptionElement | undefined = selectElement.options[0];\n\n      // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n      // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n      return (\n        this.focused ||\n        selectElement.multiple ||\n        !this.empty ||\n        !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label)\n      );\n    } else {\n      return this.focused || !this.empty;\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n    // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n    // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n    if (!this.focused) {\n      this.focus();\n    }\n  }\n\n  /** Whether the form control is a native select that is displayed inline. */\n  _isInlineSelect(): boolean {\n    const element = this._elementRef.nativeElement as HTMLSelectElement;\n    return this._isNativeSelect && (element.multiple || element.size > 1);\n  }\n\n  private _iOSKeyupListener = (event: Event): void => {\n    const el = event.target as HTMLInputElement;\n\n    // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n    // indicate different things. If the value is 0, it means that the caret is at the start\n    // of the input, whereas a value of `null` means that the input doesn't support\n    // manipulating the selection range. Inputs that don't support setting the selection range\n    // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n    // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n      // Note: Just setting `0, 0` doesn't fix the issue. Setting\n      // `1, 1` fixes it for the first time that you type text and\n      // then hold delete. Toggling to `1, 1` and then back to\n      // `0, 0` seems to completely fix it.\n      el.setSelectionRange(1, 1);\n      el.setSelectionRange(0, 0);\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TextFieldModule} from '@angular/cdk/text-field';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule} from '@angular/material/core';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatInput} from './input';\n\n@NgModule({\n  imports: [MatCommonModule, MatFormFieldModule],\n  exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule],\n  declarations: [MatInput],\n})\nexport class MatInputModule {}\n"],"names":["TextFieldModule","MAT_INPUT_VALUE_ACCESSOR","InjectionToken","supportedInputTypes","candidateInputTypes","getSupportedInputTypes","document","Set","featureTestInput","createElement","filter","value","setAttribute","type","listenerOptions","normalizePassiveListenerOptions","passive","AutofillMonitor","constructor","_platform","_ngZone","_monitoredElements","Map","monitor","elementOrRef","this","isBrowser","EMPTY","element","coerceElement","info","get","subject","result","Subject","cssClass","listener","event","animationName","classList","contains","remove","run","next","target","isAutofilled","add","runOutsideAngular","addEventListener","set","unlisten","removeEventListener","stopMonitoring","complete","delete","ngOnDestroy","forEach","_info","CdkAutofill","_elementRef","_autofillMonitor","cdkAutofill","EventEmitter","ngOnInit","subscribe","emit","MAT_INPUT_INVALID_TYPES","nextUniqueId","_MatInputBase","mixinErrorState","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","stateChanges","MatInput","disabled","_disabled","coerceBooleanProperty","focused","id","_id","_uid","required","_required","control","hasValidator","Validators","_type","_validateType","_isTextarea","has","nativeElement","_inputValueAccessor","readonly","_readonly","inputValueAccessor","ngZone","_formField","super","controlType","autofilled","_neverEmptyInputTypes","t","_iOSKeyupListener","el","selectionStart","selectionEnd","setSelectionRange","nodeName","toLowerCase","_previousNativeValue","IOS","_isServer","_isNativeSelect","_isInFormField","multiple","ngAfterViewInit","ngOnChanges","ngDoCheck","updateErrorState","_dirtyCheckNativeValue","_dirtyCheckPlaceholder","focus","options","_focusChanged","isFocused","_onInput","newValue","placeholder","_getPlaceholder","_previousPlaceholder","removeAttribute","indexOf","_isNeverEmpty","_isBadInput","validity","badInput","empty","shouldLabelFloat","selectElement","firstOption","selectedIndex","label","setDescribedByIds","ids","length","join","onContainerClick","_isInlineSelect","size","MAT_FORM_FIELD","provide","MatFormFieldControl","useExisting","MatInputModule","MatCommonModule","MatFormFieldModule"],"sourceRoot":""}