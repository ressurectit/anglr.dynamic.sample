{"version":3,"file":"7542.client.chunk.dc619899e7a064ee2ec4.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/class_map_interpolation.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/property_interpolation.ts","webpack://ng-universal-demo/../../../packages/core/src/reflection/reflection_capabilities.ts","webpack://ng-universal-demo/../../../packages/core/src/di/metadata_attr.ts","webpack://ng-universal-demo/../../../packages/core/src/di/jit/util.ts","webpack://ng-universal-demo/../../../packages/core/src/linker/ng_module_registration.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/features/copy_definition_feature.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/interfaces/i18n.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/node_manipulation_i18n.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/i18n/i18n_insert_before_index.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/i18n/i18n_util.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/i18n/i18n_apply.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/i18n_icu_container_visitor.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/i18n/i18n_parse.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/i18n/i18n_postprocess.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/i18n.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/jit/environment.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/attribute_interpolation.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/style_map_interpolation.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/style_prop_interpolation.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/jit/util.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/jit/module.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/jit/directive.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/jit/pipe.ts","webpack://ng-universal-demo/../../../packages/core/src/metadata/directives.ts","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/es2020/basic-components/src/dynamicItems/transformData/transformData.metadata.js","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/es2020/basic-components/src/dynamicItems/transformData/transformData.relations.js","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/es2020/basic-components/src/dynamicItems/transformData/type.js","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/es2020/relations-editor/src/decorators/relationsEditorMetadata/relationsEditorMetadata.decorator.js","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/es2020/relations/src/decorators/dynamicOutput/dynamicOutput.decorator.js","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/es2020/src/decorators/dynamicMetadata/dynamicClassMetadata.decorator.js"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {keyValueArraySet} from '../../util/array_utils';\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingMap, classStringParser} from './styling';\n\n\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {RENDERER} from '../interfaces/view';\nimport {getBindingIndex, getLView, getSelectedTNode, getTView} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {elementPropertyInternal, storePropertyBindingMetadata} from './shared';\n\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate(\n    propName: string, v0: any, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate {\n  ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer);\n  return ɵɵpropertyInterpolate;\n}\n\n\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate1(\n    propName: string, prefix: string, v0: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return ɵɵpropertyInterpolate1;\n}\n\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate2(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return ɵɵpropertyInterpolate2;\n}\n\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate3(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n  return ɵɵpropertyInterpolate3;\n}\n\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate4(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n  return ɵɵpropertyInterpolate4;\n}\n\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate5(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n  return ɵɵpropertyInterpolate5;\n}\n\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate6(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n  return ɵɵpropertyInterpolate6;\n}\n\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate7(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5,\n            suffix);\n  }\n  return ɵɵpropertyInterpolate7;\n}\n\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate8(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6,\n            suffix);\n  }\n  return ɵɵpropertyInterpolate8;\n}\n\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings in between those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolateV(\n    propName: string, values: any[], sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolateV {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1,\n          ...interpolationInBetween);\n    }\n  }\n  return ɵɵpropertyInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isType, Type} from '../interface/type';\nimport {newArray} from '../util/array_utils';\nimport {ANNOTATIONS, PARAMETERS, PROP_METADATA} from '../util/decorators';\nimport {global} from '../util/global';\n\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\n\n\n\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nexport const ES5_DELEGATE_CTOR =\n    /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nexport const ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nexport const ES2015_INHERITED_CLASS_WITH_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nexport const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nexport function isDelegateCtor(typeStr: string): boolean {\n  return ES5_DELEGATE_CTOR.test(typeStr) ||\n      ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\n      (ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr));\n}\n\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\n  private _reflect: any;\n\n  constructor(reflect?: any) {\n    this._reflect = reflect || global['Reflect'];\n  }\n\n  factory<T>(t: Type<T>): (args: any[]) => T {\n    return (...args: any[]) => new t(...args);\n  }\n\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = newArray(paramAnnotations.length);\n    } else {\n      result = newArray(paramTypes.length);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] && paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n\n  private _ownParameters(type: Type<any>, parentCtor: any): any[][]|null {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (isDelegateCtor(typeStr)) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if ((<any>type).parameters && (<any>type).parameters !== parentCtor.parameters) {\n      return (<any>type).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = (<any>type).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && (type as any)[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n        this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return newArray<any[]>(type.length);\n  }\n\n  parameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n\n  private _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[]|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).annotations && (<any>typeOrFunc).annotations !== parentCtor.annotations) {\n      let annotations = (<any>typeOrFunc).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).decorators && (<any>typeOrFunc).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata((<any>typeOrFunc).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return (typeOrFunc as any)[ANNOTATIONS];\n    }\n    return null;\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n\n  private _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]}|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).propMetadata &&\n        (<any>typeOrFunc).propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = (<any>typeOrFunc).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).propDecorators &&\n        (<any>typeOrFunc).propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = (<any>typeOrFunc).propDecorators;\n      const propMetadata = <{[key: string]: any[]}>{};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return (typeOrFunc as any)[PROP_METADATA];\n    }\n    return null;\n  }\n\n  propMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n\n  ownPropMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n}\n\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n\nfunction getParentCtor(ctor: Function): Type<any> {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵɵinjectAttribute} from '../render3/instructions/di_attr';\nimport {makeParamDecorator} from '../util/decorators';\n\n\n/**\n * Type of the Attribute decorator / constructor function.\n *\n * @publicApi\n */\nexport interface AttributeDecorator {\n  /**\n   * Parameter decorator for a directive constructor that designates\n   * a host-element attribute whose value is injected as a constant string literal.\n   *\n   * @usageNotes\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * The following example uses the decorator to inject the string literal `text` in a directive.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n   *\n   * The following example uses the decorator in a component constructor.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\n   *\n   */\n  (name: string): any;\n  new(name: string): Attribute;\n}\n\n/**\n * Type of the Attribute metadata.\n *\n * @publicApi\n */\nexport interface Attribute {\n  /**\n   * The name of the attribute whose value can be injected.\n   */\n  attributeName: string;\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Attribute: AttributeDecorator = makeParamDecorator(\n    'Attribute',\n    (attributeName?: string) =>\n        ({attributeName, __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName!)}));\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3DependencyMetadataFacade} from '../../compiler/compiler_facade';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type} from '../../interface/type';\nimport {ReflectionCapabilities} from '../../reflection/reflection_capabilities';\nimport {Host, Inject, Optional, Self, SkipSelf} from '../metadata';\nimport {Attribute} from '../metadata_attr';\n\nlet _reflect: ReflectionCapabilities|null = null;\n\nexport function getReflect(): ReflectionCapabilities {\n  return (_reflect = _reflect || new ReflectionCapabilities());\n}\n\nexport function reflectDependencies(type: Type<any>): R3DependencyMetadataFacade[] {\n  return convertDependencies(getReflect().parameters(type));\n}\n\nexport function convertDependencies(deps: any[]): R3DependencyMetadataFacade[] {\n  return deps.map(dep => reflectDependency(dep));\n}\n\nfunction reflectDependency(dep: any|any[]): R3DependencyMetadataFacade {\n  const meta: R3DependencyMetadataFacade = {\n    token: null,\n    attribute: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false,\n  };\n\n  if (Array.isArray(dep) && dep.length > 0) {\n    for (let j = 0; j < dep.length; j++) {\n      const param = dep[j];\n      if (param === undefined) {\n        // param may be undefined if type of dep is not set by ngtsc\n        continue;\n      }\n\n      const proto = Object.getPrototypeOf(param);\n\n      if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n        meta.optional = true;\n      } else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n        meta.skipSelf = true;\n      } else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n        meta.self = true;\n      } else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n        meta.host = true;\n      } else if (param instanceof Inject) {\n        meta.token = param.token;\n      } else if (param instanceof Attribute) {\n        if (param.attributeName === undefined) {\n          throw new RuntimeError(\n              RuntimeErrorCode.INVALID_INJECTION_TOKEN,\n              ngDevMode && `Attribute name must be defined.`);\n        }\n        meta.attribute = param.attributeName;\n      } else {\n        meta.token = param;\n      }\n    }\n  } else if (dep === undefined || (Array.isArray(dep) && dep.length === 0)) {\n    meta.token = null;\n  } else {\n    meta.token = dep;\n  }\n  return meta;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Type} from '../interface/type';\nimport {NgModuleType} from '../metadata/ng_module_def';\nimport {getNgModuleDef} from '../render3/definition';\nimport {stringify} from '../util/stringify';\n\n/**\n * Map of module-id to the corresponding NgModule.\n */\nconst modules = new Map<string, NgModuleType>();\n\n/**\n * Whether to check for duplicate NgModule registrations.\n *\n * This can be disabled for testing.\n */\nlet checkForDuplicateNgModules = true;\n\nfunction assertSameOrNotExisting(id: string, type: Type<any>|null, incoming: Type<any>): void {\n  if (type && type !== incoming && checkForDuplicateNgModules) {\n    throw new Error(\n        `Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n  }\n}\n\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\nexport function registerNgModuleType(ngModuleType: NgModuleType, id: string): void {\n  const existing = modules.get(id) || null;\n  assertSameOrNotExisting(id, existing, ngModuleType);\n  modules.set(id, ngModuleType);\n}\n\nexport function clearModulesForTest(): void {\n  modules.clear();\n}\n\nexport function getRegisteredNgModuleType(id: string): NgModuleType|undefined {\n  return modules.get(id);\n}\n\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\nexport function setAllowDuplicateNgModuleIdsForTest(allowDuplicates: boolean): void {\n  checkForDuplicateNgModules = !allowDuplicates;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentDef, DirectiveDef} from '../interfaces/definition';\nimport {isComponentDef} from '../interfaces/type_checks';\n\nimport {getSuperType} from './inherit_definition_feature';\n\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `ɵɵCopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS: (keyof DirectiveDef<unknown>)[] = [\n  // The child class should use the providers of its parent.\n  'providersResolver',\n\n  // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such\n  // as inputs, outputs, and host binding functions.\n];\n\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `ɵɵCopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS: Exclude<keyof ComponentDef<unknown>, keyof DirectiveDef<unknown>>[] = [\n  // The child class should use the template function of its parent, including all template\n  // semantics.\n  'template',\n  'decls',\n  'consts',\n  'vars',\n  'onPush',\n  'ngContentSelectors',\n\n  // The child class should use the CSS styles of its parent, including all styling semantics.\n  'styles',\n  'encapsulation',\n\n  // The child class should be checked by the runtime in the same way as its parent.\n  'schemas',\n];\n\n/**\n * Copies the fields not handled by the `ɵɵInheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `ɵɵCopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nexport function ɵɵCopyDefinitionFeature(definition: DirectiveDef<any>|ComponentDef<any>): void {\n  let superType = getSuperType(definition.type)!;\n\n  let superDef: DirectiveDef<any>|ComponentDef<any>|undefined = undefined;\n  if (isComponentDef(definition)) {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵcmp!;\n  } else {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵdir!;\n  }\n\n  // Needed because `definition` fields are readonly.\n  const defAny = (definition as any);\n\n  // Copy over any fields that apply to either directives or components.\n  for (const field of COPY_DIRECTIVE_FIELDS) {\n    defAny[field] = superDef[field];\n  }\n\n  if (isComponentDef(superDef)) {\n    // Copy over any component-specific fields.\n    for (const field of COPY_COMPONENT_FIELDS) {\n      defAny[field] = superDef[field];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SanitizerFn} from './sanitization';\n\n\n/**\n * Stores a list of nodes which need to be removed.\n *\n * Numbers are indexes into the `LView`\n * - index > 0: `removeRNode(lView[0])`\n * - index < 0: `removeICU(~lView[0])`\n */\nexport interface I18nRemoveOpCodes extends Array<number> {\n  __brand__: 'I18nRemoveOpCodes';\n}\n\n/**\n * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n *\n * OpCodes are efficient operations which can be applied to the DOM to update it. (For example to\n * update to a new ICU case requires that we clean up previous elements and create new ones.)\n *\n * OpCodes contain three parts:\n *  1) Parent node index offset. (p)\n *  2) Reference node index offset. (r)\n *  3) The instruction to execute. (i)\n *\n * pppp pppp pppp pppp rrrr rrrr rrrr riii\n * 3322 2222 2222 1111 1111 1110 0000 0000\n * 1098 7654 3210 9876 5432 1098 7654 3210\n *\n * ```\n * var parent = lView[opCode >>> SHIFT_PARENT];\n * var refNode = lView[((opCode & MASK_REF) >>> SHIFT_REF)];\n * var instruction = opCode & MASK_OPCODE;\n * ```\n *\n * See: `I18nCreateOpCodes` for example of usage.\n */\nexport const enum IcuCreateOpCode {\n  /**\n   * Stores shift amount for bits 17-3 that contain reference index.\n   */\n  SHIFT_REF = 1,\n  /**\n   * Stores shift amount for bits 31-17 that contain parent index.\n   */\n  SHIFT_PARENT = 17,\n  /**\n   * Mask for OpCode\n   */\n  MASK_INSTRUCTION = 0b1,\n\n  /**\n   * Mask for the Reference node (bits 16-3)\n   */\n  MASK_REF = 0b11111111111111110,\n  //           11111110000000000\n  //           65432109876543210\n\n  /**\n   * Instruction to append the current node to `PARENT`.\n   */\n  AppendChild = 0b0,\n\n  /**\n   * Instruction to set the attribute of a node.\n   */\n  Attr = 0b1,\n}\n\n\n/**\n * Array storing OpCode for dynamically creating `i18n` blocks.\n *\n * Example:\n * ```ts\n * <I18nCreateOpCode>[\n *   // For adding text nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createTextNode('xyz'));\n *   'xyz', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding element nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createElement('div'));\n *   ELEMENT_MARKER, 'div', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding comment nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createComment(''));\n *   ICU_MARKER, '', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For moving existing nodes to a different location\n *   // --------------------------------------------------\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].appendChild(node);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For removing existing nodes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   removeChild(tView.data(1), node, lView);\n *   1 << SHIFT_REF | Remove,\n *\n *   // For writing attributes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   node.setAttribute('attr', 'value');\n *   1 << SHIFT_REF | Attr, 'attr', 'value'\n * ];\n * ```\n */\nexport interface IcuCreateOpCodes extends Array<number|string|ELEMENT_MARKER|ICU_MARKER|null>,\n                                          I18nDebug {\n  __brand__: 'I18nCreateOpCodes';\n}\n\nexport const enum I18nUpdateOpCode {\n  /**\n   * Stores shift amount for bits 17-2 that contain reference index.\n   */\n  SHIFT_REF = 2,\n  /**\n   * Mask for OpCode\n   */\n  MASK_OPCODE = 0b11,\n\n  /**\n   * Instruction to update a text node.\n   */\n  Text = 0b00,\n  /**\n   * Instruction to update a attribute of a node.\n   */\n  Attr = 0b01,\n  /**\n   * Instruction to switch the current ICU case.\n   */\n  IcuSwitch = 0b10,\n  /**\n   * Instruction to update the current ICU case.\n   */\n  IcuUpdate = 0b11,\n}\n\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ELEMENT_MARKER: ELEMENT_MARKER = {\n  marker: 'element'\n};\nexport interface ELEMENT_MARKER {\n  marker: 'element';\n}\n\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ICU_MARKER: ICU_MARKER = {\n  marker: 'ICU'\n};\n\nexport interface ICU_MARKER {\n  marker: 'ICU';\n}\n\nexport interface I18nDebug {\n  /**\n   * Human readable representation of the OpCode arrays.\n   *\n   * NOTE: This property only exists if `ngDevMode` is set to `true` and it is not present in\n   * production. Its presence is purely to help debug issue in development, and should not be relied\n   * on in production application.\n   */\n  debug?: string[];\n}\n\n/**\n * Array storing OpCode for dynamically creating `i18n` translation DOM elements.\n *\n * This array creates a sequence of `Text` and `Comment` (as ICU anchor) DOM elements. It consists\n * of a pair of `number` and `string` pairs which encode the operations for the creation of the\n * translated block.\n *\n * The number is shifted and encoded according to `I18nCreateOpCode`\n *\n * Pseudocode:\n * ```\n * const i18nCreateOpCodes = [\n *   10 << I18nCreateOpCode.SHIFT, \"Text Node add to DOM\",\n *   11 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.COMMENT, \"Comment Node add to DOM\",\n *   12 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.APPEND_LATER, \"Text Node added later\"\n * ];\n *\n * for(var i=0; i<i18nCreateOpCodes.length; i++) {\n *   const opcode = i18NCreateOpCodes[i++];\n *   const index = opcode >> I18nCreateOpCode.SHIFT;\n *   const text = i18NCreateOpCodes[i];\n *   let node: Text|Comment;\n *   if (opcode & I18nCreateOpCode.COMMENT === I18nCreateOpCode.COMMENT) {\n *     node = lView[~index] = document.createComment(text);\n *   } else {\n *     node = lView[index] = document.createText(text);\n *   }\n *   if (opcode & I18nCreateOpCode.APPEND_EAGERLY !== I18nCreateOpCode.APPEND_EAGERLY) {\n *     parentNode.appendChild(node);\n *   }\n * }\n * ```\n */\nexport interface I18nCreateOpCodes extends Array<number|string>, I18nDebug {\n  __brand__: 'I18nCreateOpCodes';\n}\n\n/**\n * See `I18nCreateOpCodes`\n */\nexport enum I18nCreateOpCode {\n  /**\n   * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n   * `COMMENT`.\n   */\n  SHIFT = 2,\n\n  /**\n   * Should the node be appended to parent immediately after creation.\n   */\n  APPEND_EAGERLY = 0b01,\n\n  /**\n   * If set the node should be comment (rather than a text) node.\n   */\n  COMMENT = 0b10,\n}\n\n\n/**\n * Stores DOM operations which need to be applied to update DOM render tree due to changes in\n * expressions.\n *\n * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change\n * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and\n * higher.) The OpCodes then compare its own change mask against the expression change mask to\n * determine if the OpCodes should execute.\n *\n * NOTE: 32nd bit is special as it says 32nd or higher. This way if we have more than 32 bindings\n * the code still works, but with lower efficiency. (it is unlikely that a translation would have\n * more than 32 bindings.)\n *\n * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n *\n * ## Example\n *\n * Assume\n * ```ts\n *   if (rf & RenderFlags.Update) {\n *    i18nExp(ctx.exp1); // If changed set mask bit 1\n *    i18nExp(ctx.exp2); // If changed set mask bit 2\n *    i18nExp(ctx.exp3); // If changed set mask bit 3\n *    i18nExp(ctx.exp4); // If changed set mask bit 4\n *    i18nApply(0);            // Apply all changes by executing the OpCodes.\n *  }\n * ```\n * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the\n * index of `i18nExp`.\n *\n * ### OpCodes\n * ```ts\n * <I18nUpdateOpCodes>[\n *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n *   // If `changeMask & 0b11`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `8` values and start processing next OpCodes.\n *   0b11, 8,\n *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.\n *   'pre', -4, 'in', -3, 'post',\n *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,\n *\n *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!\">`\n *   // If `changeMask & 0b100`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b100, 4,\n *   // Concatenate `newValue = 'Hello ' + lView[bindIndex -2] + '!';`.\n *   'Hello ', -2, '!',\n *   // Update text: `lView[1].textContent = newValue;`\n *   1 << SHIFT_REF | Text,\n *\n *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n *   // If `changeMask & 0b1000`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `2` values and start processing next OpCodes.\n *   0b1000, 2,\n *   // Concatenate `newValue = lView[bindIndex -1];`.\n *   -1,\n *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,\n *\n *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.\n *   -1, 1,\n *   // Update ICU: `icuUpdateCase(lView[1], 0);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,\n *\n * ];\n * ```\n *\n */\nexport interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null>, I18nDebug {\n  __brand__: 'I18nUpdateOpCodes';\n}\n\n/**\n * Store information for the i18n translation block.\n */\nexport interface TI18n {\n  /**\n   * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n   *\n   * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n   */\n  create: I18nCreateOpCodes;\n\n  /**\n   * A set of OpCodes which will be executed on each change detection to determine if any changes to\n   * DOM are required.\n   */\n  update: I18nUpdateOpCodes;\n}\n\n/**\n * Defines the ICU type of `select` or `plural`\n */\nexport const enum IcuType {\n  select = 0,\n  plural = 1,\n}\n\nexport interface TIcu {\n  /**\n   * Defines the ICU type of `select` or `plural`\n   */\n  type: IcuType;\n\n  /**\n   * Index in `LView` where the anchor node is stored. `<!-- ICU 0:0 -->`\n   */\n  anchorIdx: number;\n\n  /**\n   * Currently selected ICU case pointer.\n   *\n   * `lView[currentCaseLViewIndex]` stores the currently selected case. This is needed to know how\n   * to clean up the current case when transitioning no the new case.\n   *\n   * If the value stored is:\n   * `null`: No current case selected.\n   *   `<0`: A flag which means that the ICU just switched and that `icuUpdate` must be executed\n   *         regardless of the `mask`. (After the execution the flag is cleared)\n   *   `>=0` A currently selected case index.\n   */\n  currentCaseLViewIndex: number;\n\n  /**\n   * A list of case values which the current ICU will try to match.\n   *\n   * The last value is `other`\n   */\n  cases: any[];\n\n  /**\n   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n   */\n  create: IcuCreateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n   */\n  remove: I18nRemoveOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n   */\n  update: I18nUpdateOpCodes[];\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Parsed ICU expression\n */\nexport interface IcuExpression {\n  type: IcuType;\n  mainBinding: number;\n  cases: string[];\n  values: (string|IcuExpression)[][];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDomNode, assertIndexInRange} from '../util/assert';\n\nimport {TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {Renderer} from './interfaces/renderer';\nimport {RElement, RNode} from './interfaces/renderer_dom';\nimport {LView} from './interfaces/view';\nimport {getInsertInFrontOfRNodeWithNoI18n, nativeInsertBefore} from './node_manipulation';\nimport {unwrapRNode} from './util/view_utils';\n\n\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nexport function getInsertInFrontOfRNodeWithI18n(\n    parentTNode: TNode, currentTNode: TNode, lView: LView): RNode|null {\n  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n  const insertBeforeIndex =\n      Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n  } else {\n    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n    return unwrapRNode(lView[insertBeforeIndex]);\n  }\n}\n\n\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function processI18nInsertBefore(\n    renderer: Renderer, childTNode: TNode, lView: LView, childRNode: RNode|RNode[],\n    parentRElement: RElement|null): void {\n  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n  if (Array.isArray(tNodeInsertBeforeIndex)) {\n    // An array indicates that there are i18n nodes that need to be added as children of this\n    // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n    // only now can be added. The first element of the array is the normal index where we should\n    // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n    // `childRNode`.\n    ngDevMode && assertDomNode(childRNode);\n    let i18nParent: RElement|null = childRNode as RElement;\n    let anchorRNode: RNode|null = null;\n    if (!(childTNode.type & TNodeType.AnyRNode)) {\n      anchorRNode = i18nParent;\n      i18nParent = parentRElement;\n    }\n    if (i18nParent !== null && (childTNode.flags & TNodeFlags.isComponentHost) === 0) {\n      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n        // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n        // see `assertDomNode` below.\n        const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual} from '../../util/assert';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\n\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `ɵɵi18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `ɵɵelementStart` instruction.\n * 3. `ɵɵelementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\nexport function addTNodeAndUpdateInsertBeforeIndex(previousTNodes: TNode[], newTNode: TNode) {\n  // Start with Rule1\n  ngDevMode &&\n      assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n\n  previousTNodes.push(newTNode);\n  if (previousTNodes.length > 1) {\n    for (let i = previousTNodes.length - 2; i >= 0; i--) {\n      const existingTNode = previousTNodes[i];\n      // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n      // It is safe to ignore them.\n      if (!isI18nText(existingTNode)) {\n        if (isNewTNodeCreatedBefore(existingTNode, newTNode) &&\n            getInsertBeforeIndex(existingTNode) === null) {\n          // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n          // then add the `insertBeforeIndex`.\n          setInsertBeforeIndex(existingTNode, newTNode.index);\n        }\n      }\n    }\n  }\n}\n\nfunction isI18nText(tNode: TNode): boolean {\n  return !(tNode.type & TNodeType.Placeholder);\n}\n\nfunction isNewTNodeCreatedBefore(existingTNode: TNode, newTNode: TNode): boolean {\n  return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\n\nfunction getInsertBeforeIndex(tNode: TNode): number|null {\n  const index = tNode.insertBeforeIndex;\n  return Array.isArray(index) ? index[0] : index;\n}\n\nfunction setInsertBeforeIndex(tNode: TNode, value: number): void {\n  const index = tNode.insertBeforeIndex;\n  if (Array.isArray(index)) {\n    // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n    index[0] = value;\n  } else {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    tNode.insertBeforeIndex = value;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertGreaterThan, assertGreaterThanOrEqual, throwError} from '../../util/assert';\nimport {assertTIcu, assertTNode} from '../assert';\nimport {createTNodeAtIndex} from '../instructions/shared';\nimport {IcuCreateOpCode, TIcu} from '../interfaces/i18n';\nimport {TIcuContainerNode, TNode, TNodeType} from '../interfaces/node';\nimport {LView, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\n\n\n/**\n * Retrieve `TIcu` at a given `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be read from.\n */\nexport function getTIcu(tView: TView, index: number): TIcu|null {\n  const value = tView.data[index] as null | TIcu | TIcuContainerNode | string;\n  if (value === null || typeof value === 'string') return null;\n  if (ngDevMode &&\n      !(value.hasOwnProperty('tViews') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n    throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n  }\n  // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n  // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n  // will be just two cases which fits into the browser inline cache (inline cache can take up to\n  // 4)\n  const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value as TIcu :\n                                                               (value as TIcuContainerNode).value;\n  ngDevMode && assertTIcu(tIcu);\n  return tIcu;\n}\n\n/**\n * Store `TIcu` at a give `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be stored at in `Tview.data`\n * @param tIcu The TIcu to store.\n */\nexport function setTIcu(tView: TView, index: number, tIcu: TIcu): void {\n  const tNode = tView.data[index] as null | TIcuContainerNode;\n  ngDevMode &&\n      assertEqual(\n          tNode === null || tNode.hasOwnProperty('tViews'), true,\n          'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n  if (tNode === null) {\n    tView.data[index] = tIcu;\n  } else {\n    ngDevMode && assertTNodeType(tNode, TNodeType.Icu);\n    tNode.value = tIcu;\n  }\n}\n\n/**\n * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function setTNodeInsertBeforeIndex(tNode: TNode, index: number) {\n  ngDevMode && assertTNode(tNode);\n  let insertBeforeIndex = tNode.insertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    insertBeforeIndex = tNode.insertBeforeIndex =\n        [null!/* may be updated to number later */, index];\n  } else {\n    assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n    (insertBeforeIndex as number[]).push(index);\n  }\n}\n\n/**\n * Create `TNode.type=TNodeType.Placeholder` node.\n *\n * See `TNodeType.Placeholder` for more information.\n */\nexport function createTNodePlaceholder(\n    tView: TView, previousTNodes: TNode[], index: number): TNode {\n  const tNode = createTNodeAtIndex(tView, index, TNodeType.Placeholder, null, null);\n  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n  return tNode;\n}\n\n\n/**\n * Returns current ICU case.\n *\n * ICU cases are stored as index into the `TIcu.cases`.\n * At times it is necessary to communicate that the ICU case just switched and that next ICU update\n * should update all bindings regardless of the mask. In such a case the we store negative numbers\n * for cases which have just been switched. This function removes the negative flag.\n */\nexport function getCurrentICUCaseIndex(tIcu: TIcu, lView: LView) {\n  const currentCase: number|null = lView[tIcu.currentCaseLViewIndex];\n  return currentCase === null ? currentCase : (currentCase < 0 ? ~currentCase : currentCase);\n}\n\nexport function getParentFromIcuCreateOpCode(mergedCode: number): number {\n  return mergedCode >>> IcuCreateOpCode.SHIFT_PARENT;\n}\n\nexport function getRefFromIcuCreateOpCode(mergedCode: number): number {\n  return (mergedCode & IcuCreateOpCode.MASK_REF) >>> IcuCreateOpCode.SHIFT_REF;\n}\n\nexport function getInstructionFromIcuCreateOpCode(mergedCode: number): number {\n  return mergedCode & IcuCreateOpCode.MASK_INSTRUCTION;\n}\n\nexport function icuCreateOpCode(opCode: IcuCreateOpCode, parentIdx: number, refIdx: number) {\n  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n  ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n  return opCode | parentIdx << IcuCreateOpCode.SHIFT_PARENT | refIdx << IcuCreateOpCode.SHIFT_REF;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {getPluralCase} from '../../i18n/localization';\nimport {assertDefined, assertDomNode, assertEqual, assertGreaterThan, assertIndexInRange, throwError} from '../../util/assert';\nimport {assertIndexInExpandoRange, assertTIcu} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {elementPropertyInternal, setElementAttribute} from '../instructions/shared';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes, IcuType, TI18n, TIcu} from '../interfaces/i18n';\nimport {TNode} from '../interfaces/node';\nimport {RElement, RNode, RText} from '../interfaces/renderer_dom';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\nimport {createCommentNode, createElementNode, createTextNode, nativeInsertBefore, nativeParentNode, nativeRemoveNode, updateTextNode} from '../node_manipulation';\nimport {getBindingIndex} from '../state';\nimport {renderStringify} from '../util/stringify_utils';\nimport {getNativeByIndex, unwrapRNode} from '../util/view_utils';\n\nimport {getLocaleId} from './i18n_locale_id';\nimport {getCurrentICUCaseIndex, getParentFromIcuCreateOpCode, getRefFromIcuCreateOpCode, getTIcu} from './i18n_util';\n\n\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `ɵɵi18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `ɵɵi18nExp` then all changes past 32nd `ɵɵi18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\nlet changeMask = 0b0;\n\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `ɵɵi18nExp`\n */\nlet changeMaskCounter = 0;\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `ɵɵi18nExp`.\n *\n * @param hasChange did `ɵɵi18nExp` detect a change.\n */\nexport function setMaskBit(hasChange: boolean) {\n  if (hasChange) {\n    changeMask = changeMask | (1 << Math.min(changeMaskCounter, 31));\n  }\n  changeMaskCounter++;\n}\n\nexport function applyI18n(tView: TView, lView: LView, index: number) {\n  if (changeMaskCounter > 0) {\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const tI18n = tView.data[index] as TI18n | I18nUpdateOpCodes;\n    // When `index` points to an `ɵɵi18nAttributes` then we have an array otherwise `TI18n`\n    const updateOpCodes: I18nUpdateOpCodes =\n        Array.isArray(tI18n) ? tI18n as I18nUpdateOpCodes : (tI18n as TI18n).update;\n    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n  }\n  // Reset changeMask & maskBit to default for the next update cycle\n  changeMask = 0b0;\n  changeMaskCounter = 0;\n}\n\n\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\nexport function applyCreateOpCodes(\n    lView: LView, createOpCodes: I18nCreateOpCodes, parentRNode: RElement|null,\n    insertInFrontOf: RElement|null): void {\n  const renderer = lView[RENDERER];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++] as any;\n    const text = createOpCodes[i] as string;\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow =\n        (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    let rNode = lView[index];\n    if (rNode === null) {\n      // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n      // case which was already instantiated, no need to create new DOM nodes.\n      rNode = lView[index] =\n          isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n    }\n    if (appendNow && parentRNode !== null) {\n      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n    }\n  }\n}\n\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\nexport function applyMutableOpCodes(\n    tView: TView, mutableOpCodes: IcuCreateOpCodes, lView: LView, anchorRNode: RNode): void {\n  ngDevMode && assertDomNode(anchorRNode);\n  const renderer = lView[RENDERER];\n  // `rootIdx` represents the node into which all inserts happen.\n  let rootIdx: number|null = null;\n  // `rootRNode` represents the real node into which we insert. This can be different from\n  // `lView[rootIdx]` if we have projection.\n  //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n  //    LView which has no parent.)\n  //  - `RElement` The element representing the root after taking projection into account.\n  let rootRNode!: RElement|null;\n  for (let i = 0; i < mutableOpCodes.length; i++) {\n    const opCode = mutableOpCodes[i];\n    if (typeof opCode == 'string') {\n      const textNodeIndex = mutableOpCodes[++i] as number;\n      if (lView[textNodeIndex] === null) {\n        ngDevMode && ngDevMode.rendererCreateTextNode++;\n        ngDevMode && assertIndexInRange(lView, textNodeIndex);\n        lView[textNodeIndex] = createTextNode(renderer, opCode);\n      }\n    } else if (typeof opCode == 'number') {\n      switch (opCode & IcuCreateOpCode.MASK_INSTRUCTION) {\n        case IcuCreateOpCode.AppendChild:\n          const parentIdx = getParentFromIcuCreateOpCode(opCode);\n          if (rootIdx === null) {\n            // The first operation should save the `rootIdx` because the first operation\n            // must insert into the root. (Only subsequent operations can insert into a dynamic\n            // parent)\n            rootIdx = parentIdx;\n            rootRNode = nativeParentNode(renderer, anchorRNode);\n          }\n          let insertInFrontOf: RNode|null;\n          let parentRNode: RElement|null;\n          if (parentIdx === rootIdx) {\n            insertInFrontOf = anchorRNode;\n            parentRNode = rootRNode;\n          } else {\n            insertInFrontOf = null;\n            parentRNode = unwrapRNode(lView[parentIdx]) as RElement;\n          }\n          // FIXME(misko): Refactor with `processI18nText`\n          if (parentRNode !== null) {\n            // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n            // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n            // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n            // get picked up and added.\n            ngDevMode && assertDomNode(parentRNode);\n            const refIdx = getRefFromIcuCreateOpCode(opCode);\n            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n            // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n            // which can't have components.\n            const child = lView[refIdx] as RElement;\n            ngDevMode && assertDomNode(child);\n            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n            const tIcu = getTIcu(tView, refIdx);\n            if (tIcu !== null && typeof tIcu === 'object') {\n              // If we just added a comment node which has ICU then that ICU may have already been\n              // rendered and therefore we need to re-add it here.\n              ngDevMode && assertTIcu(tIcu);\n              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n              if (caseIndex !== null) {\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n              }\n            }\n          }\n          break;\n        case IcuCreateOpCode.Attr:\n          const elementNodeIndex = opCode >>> IcuCreateOpCode.SHIFT_REF;\n          const attrName = mutableOpCodes[++i] as string;\n          const attrValue = mutableOpCodes[++i] as string;\n          // This code is used for ICU expressions only, since we don't support\n          // directives/components in ICUs, we don't need to worry about inputs here\n          setElementAttribute(\n              renderer, getNativeByIndex(elementNodeIndex, lView) as RElement, null, null, attrName,\n              attrValue, null);\n          break;\n        default:\n          if (ngDevMode) {\n            throw new RuntimeError(\n                RuntimeErrorCode.INVALID_I18N_STRUCTURE,\n                `Unable to determine the type of mutate operation for \"${opCode}\"`);\n          }\n      }\n    } else {\n      switch (opCode) {\n        case ICU_MARKER:\n          const commentValue = mutableOpCodes[++i] as string;\n          const commentNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[commentNodeIndex] === null) {\n            ngDevMode &&\n                assertEqual(\n                    typeof commentValue, 'string',\n                    `Expected \"${commentValue}\" to be a comment node value`);\n            ngDevMode && ngDevMode.rendererCreateComment++;\n            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n            const commentRNode = lView[commentNodeIndex] =\n                createCommentNode(renderer, commentValue);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(commentRNode, lView);\n          }\n          break;\n        case ELEMENT_MARKER:\n          const tagName = mutableOpCodes[++i] as string;\n          const elementNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[elementNodeIndex] === null) {\n            ngDevMode &&\n                assertEqual(\n                    typeof tagName, 'string',\n                    `Expected \"${tagName}\" to be an element node tag name`);\n\n            ngDevMode && ngDevMode.rendererCreateElement++;\n            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n            const elementRNode = lView[elementNodeIndex] =\n                createElementNode(renderer, tagName, null);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(elementRNode, lView);\n          }\n          break;\n        default:\n          ngDevMode &&\n              throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n      }\n    }\n  }\n}\n\n\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\nexport function applyUpdateOpCodes(\n    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, bindingsStartIndex: number,\n    changeMask: number) {\n  for (let i = 0; i < updateOpCodes.length; i++) {\n    // bit code to check if we should apply the next update\n    const checkBit = updateOpCodes[i] as number;\n    // Number of opCodes to skip until next set of update codes\n    const skipCodes = updateOpCodes[++i] as number;\n    if (checkBit & changeMask) {\n      // The value has been updated since last checked\n      let value = '';\n      for (let j = i + 1; j <= (i + skipCodes); j++) {\n        const opCode = updateOpCodes[j];\n        if (typeof opCode == 'string') {\n          value += opCode;\n        } else if (typeof opCode == 'number') {\n          if (opCode < 0) {\n            // Negative opCode represent `i18nExp` values offset.\n            value += renderStringify(lView[bindingsStartIndex - opCode]);\n          } else {\n            const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n              case I18nUpdateOpCode.Attr:\n                const propName = updateOpCodes[++j] as string;\n                const sanitizeFn = updateOpCodes[++j] as SanitizerFn | null;\n                const tNodeOrTagName = tView.data[nodeIndex] as TNode | string;\n                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n                if (typeof tNodeOrTagName === 'string') {\n                  // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                  // not have TNode), in which case we know that there are no directives, and hence\n                  // we use attribute setting.\n                  setElementAttribute(\n                      lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value,\n                      sanitizeFn);\n                } else {\n                  elementPropertyInternal(\n                      tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn,\n                      false);\n                }\n                break;\n              case I18nUpdateOpCode.Text:\n                const rText = lView[nodeIndex] as RText | null;\n                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                break;\n              case I18nUpdateOpCode.IcuSwitch:\n                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex)!, lView, value);\n                break;\n              case I18nUpdateOpCode.IcuUpdate:\n                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex)!, bindingsStartIndex, lView);\n                break;\n            }\n          }\n        }\n      }\n    } else {\n      const opCode = updateOpCodes[i + 1] as number;\n      if (opCode > 0 && (opCode & I18nUpdateOpCode.MASK_OPCODE) === I18nUpdateOpCode.IcuUpdate) {\n        // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n        // we still need to execute `icuUpdateCase` because the case has changed recently due to\n        // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n        // pairs.)\n        const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n        const tIcu = getTIcu(tView, nodeIndex)!;\n        const currentIndex = lView[tIcu.currentCaseLViewIndex];\n        if (currentIndex < 0) {\n          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n        }\n      }\n    }\n    i += skipCodes;\n  }\n}\n\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param lView Current `LView`\n */\nfunction applyIcuUpdateCase(tView: TView, tIcu: TIcu, bindingsStartIndex: number, lView: LView) {\n  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n  if (activeCaseIndex !== null) {\n    let mask = changeMask;\n    if (activeCaseIndex < 0) {\n      // Clear the flag.\n      // Negative number means that the ICU was freshly created and we need to force the update.\n      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n      // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n      mask = -1;\n    }\n    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n  }\n}\n\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\nfunction applyIcuSwitchCase(tView: TView, tIcu: TIcu, lView: LView, value: string) {\n  // Rebuild a new case for this ICU\n  const caseIndex = getCaseIndex(tIcu, value);\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== caseIndex) {\n    applyIcuSwitchCaseRemove(tView, tIcu, lView);\n    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n    if (caseIndex !== null) {\n      // Add the nodes for the new case\n      const anchorRNode = lView[tIcu.anchorIdx];\n      if (anchorRNode) {\n        ngDevMode && assertDomNode(anchorRNode);\n        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n      }\n    }\n  }\n}\n\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\nfunction applyIcuSwitchCaseRemove(tView: TView, tIcu: TIcu, lView: LView) {\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== null) {\n    const removeCodes = tIcu.remove[activeCaseIndex];\n    for (let i = 0; i < removeCodes.length; i++) {\n      const nodeOrIcuIndex = removeCodes[i] as number;\n      if (nodeOrIcuIndex > 0) {\n        // Positive numbers are `RNode`s.\n        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n      } else {\n        // Negative numbers are ICUs\n        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex)!, lView);\n      }\n    }\n  }\n}\n\n\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\nfunction getCaseIndex(icuExpression: TIcu, bindingValue: string): number|null {\n  let index = icuExpression.cases.indexOf(bindingValue);\n  if (index === -1) {\n    switch (icuExpression.type) {\n      case IcuType.plural: {\n        const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n        index = icuExpression.cases.indexOf(resolvedCase);\n        if (index === -1 && resolvedCase !== 'other') {\n          index = icuExpression.cases.indexOf('other');\n        }\n        break;\n      }\n      case IcuType.select: {\n        index = icuExpression.cases.indexOf('other');\n        break;\n      }\n    }\n  }\n  return index === -1 ? null : index;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDomNode, assertNumber, assertNumberInRange} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {assertTIcu, assertTNodeForLView} from '../assert';\nimport {getCurrentICUCaseIndex} from '../i18n/i18n_util';\nimport {I18nRemoveOpCodes, TIcu} from '../interfaces/i18n';\nimport {TIcuContainerNode} from '../interfaces/node';\nimport {RNode} from '../interfaces/renderer_dom';\nimport {LView, TVIEW} from '../interfaces/view';\n\nexport function loadIcuContainerVisitor() {\n  const _stack: any[] = [];\n  let _index: number = -1;\n  let _lView: LView;\n  let _removes: I18nRemoveOpCodes;\n\n  /**\n   * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n   * to determine which root belong to the ICU.\n   *\n   * Example of usage.\n   * ```\n   * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n   * let rNode: RNode|null;\n   * while(rNode = nextRNode()) {\n   *   console.log(rNode);\n   * }\n   * ```\n   *\n   * @param tIcuContainerNode Current `TIcuContainerNode`\n   * @param lView `LView` where the `RNode`s should be looked up.\n   */\n  function icuContainerIteratorStart(tIcuContainerNode: TIcuContainerNode, lView: LView): () =>\n      RNode | null {\n    _lView = lView;\n    while (_stack.length) _stack.pop();\n    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n    enterIcu(tIcuContainerNode.value, lView);\n    return icuContainerIteratorNext;\n  }\n\n  function enterIcu(tIcu: TIcu, lView: LView) {\n    _index = 0;\n    const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n    if (currentCase !== null) {\n      ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n      _removes = tIcu.remove[currentCase];\n    } else {\n      _removes = EMPTY_ARRAY as any;\n    }\n  }\n\n\n  function icuContainerIteratorNext(): RNode|null {\n    if (_index < _removes.length) {\n      const removeOpCode = _removes[_index++] as number;\n      ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n      if (removeOpCode > 0) {\n        const rNode = _lView[removeOpCode];\n        ngDevMode && assertDomNode(rNode);\n        return rNode;\n      } else {\n        _stack.push(_index, _removes);\n        // ICUs are represented by negative indices\n        const tIcuIndex = ~removeOpCode;\n        const tIcu = _lView[TVIEW].data[tIcuIndex] as TIcu;\n        ngDevMode && assertTIcu(tIcu);\n        enterIcu(tIcu, _lView);\n        return icuContainerIteratorNext();\n      }\n    } else {\n      if (_stack.length === 0) {\n        return null;\n      } else {\n        _removes = _stack.pop();\n        _index = _stack.pop();\n        return icuContainerIteratorNext();\n      }\n    }\n  }\n\n  return icuContainerIteratorStart;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {getTemplateContent, URI_ATTRS, VALID_ATTRS, VALID_ELEMENTS} from '../../sanitization/html_sanitizer';\nimport {getInertBodyHelper} from '../../sanitization/inert_body';\nimport {_sanitizeUrl} from '../../sanitization/url_sanitizer';\nimport {assertDefined, assertEqual, assertGreaterThanOrEqual, assertOneOf, assertString} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\nimport {loadIcuContainerVisitor} from '../instructions/i18n_icu_container_visitor';\nimport {allocExpando, createTNodeAtIndex} from '../instructions/shared';\nimport {getDocument} from '../interfaces/document';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nRemoveOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes, IcuExpression, IcuType, TI18n, TIcu} from '../interfaces/i18n';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, TView} from '../interfaces/view';\nimport {getCurrentParentTNode, getCurrentTNode, setCurrentTNode} from '../state';\nimport {attachDebugGetter} from '../util/debug_utils';\n\nimport {i18nCreateOpCodesToString, i18nRemoveOpCodesToString, i18nUpdateOpCodesToString, icuCreateOpCodesToString} from './i18n_debug';\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\nimport {ensureIcuContainerVisitorLoaded} from './i18n_tree_shaking';\nimport {createTNodePlaceholder, icuCreateOpCode, setTIcu, setTNodeInsertBeforeIndex} from './i18n_util';\n\n\n\nconst BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\nconst ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /�(\\d+)�/;\nconst ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\n\nconst MARKER = `�`;\nconst SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\nconst PH_REGEXP = /�(\\/?[#*]\\d+):?\\d*�/gi;\n\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here, since translations\n * might contain this special character.\n */\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value: string): string {\n  return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `ɵɵi18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\nexport function i18nStartFirstCreatePass(\n    tView: TView, parentTNodeIndex: number, lView: LView, index: number, message: string,\n    subTemplateIndex: number) {\n  const rootTNode = getCurrentParentTNode();\n  const createOpCodes: I18nCreateOpCodes = [] as any;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  const existingTNodeStack: TNode[][] = [[]];\n  if (ngDevMode) {\n    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n\n  message = getTranslationForTemplate(message, subTemplateIndex);\n  const msgParts = replaceNgsp(message).split(PH_REGEXP);\n  for (let i = 0; i < msgParts.length; i++) {\n    let value = msgParts[i];\n    if ((i & 1) === 0) {\n      // Even indexes are text (including bindings & ICU expressions)\n      const parts = i18nParseTextIntoPartsAndICU(value);\n      for (let j = 0; j < parts.length; j++) {\n        let part = parts[j];\n        if ((j & 1) === 0) {\n          // `j` is odd therefore `part` is string\n          const text = part as string;\n          ngDevMode && assertString(text, 'Parsed ICU part should be string');\n          if (text !== '') {\n            i18nStartFirstCreatePassProcessTextNode(\n                tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n          }\n        } else {\n          // `j` is Even therefor `part` is an `ICUExpression`\n          const icuExpression: IcuExpression = part as IcuExpression;\n          // Verify that ICU expression has the right shape. Translations might contain invalid\n          // constructions (while original messages were correct), so ICU parsing at runtime may\n          // not succeed (thus `icuExpression` remains a string).\n          // Note: we intentionally retain the error here by not using `ngDevMode`, because\n          // the value can change based on the locale and users aren't guaranteed to hit\n          // an invalid string while they're developing.\n          if (typeof icuExpression !== 'object') {\n            throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n          }\n          const icuContainerTNode = createTNodeAndAddOpCode(\n              tView, rootTNode, existingTNodeStack[0], lView, createOpCodes,\n              ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n          const icuNodeIndex = icuContainerTNode.index;\n          ngDevMode &&\n              assertGreaterThanOrEqual(\n                  icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n          icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n        }\n      }\n    } else {\n      // Odd indexes are placeholders (elements and sub-templates)\n      // At this point value is something like: '/#1:2' (originally coming from '�/#1:2�')\n      const isClosing = value.charCodeAt(0) === CharCode.SLASH;\n      const type = value.charCodeAt(isClosing ? 1 : 0);\n      ngDevMode && assertOneOf(type, CharCode.STAR, CharCode.HASH);\n      const index = HEADER_OFFSET + Number.parseInt(value.substring((isClosing ? 2 : 1)));\n      if (isClosing) {\n        existingTNodeStack.shift();\n        setCurrentTNode(getCurrentParentTNode()!, false);\n      } else {\n        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n        existingTNodeStack.unshift([]);\n        setCurrentTNode(tNode, true);\n      }\n    }\n  }\n\n  tView.data[index] = <TI18n>{\n    create: createOpCodes,\n    update: updateOpCodes,\n  };\n}\n\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\nfunction createTNodeAndAddOpCode(\n    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], lView: LView,\n    createOpCodes: I18nCreateOpCodes, text: string|null, isICU: boolean): TNode {\n  const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n  let parentTNode = getCurrentParentTNode();\n\n  if (rootTNode === parentTNode) {\n    // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n    // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n    // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n    parentTNode = null;\n  }\n  if (parentTNode === null) {\n    // If we don't have a parent that means that we can eagerly add nodes.\n    // If we have a parent than these nodes can't be added now (as the parent has not been created\n    // yet) and instead the `parentTNode` is responsible for adding it. See\n    // `TNode.insertBeforeIndex`\n    opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n  }\n  if (isICU) {\n    opCode |= I18nCreateOpCode.COMMENT;\n    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n  }\n  createOpCodes.push(opCode, text === null ? '' : text);\n  // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n  // bindings are.\n  const tNode = createTNodeAtIndex(\n      tView, i18nNodeIdx, isICU ? TNodeType.Icu : TNodeType.Text,\n      text === null ? (ngDevMode ? '{{?}}' : '') : text, null);\n  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n  const tNodeIdx = tNode.index;\n  setCurrentTNode(tNode, false /* Text nodes are self closing */);\n  if (parentTNode !== null && rootTNode !== parentTNode) {\n    // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n    // We have to make sure to add ourselves to the parent.\n    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n  }\n  return tNode;\n}\n\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\nfunction i18nStartFirstCreatePassProcessTextNode(\n    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], createOpCodes: I18nCreateOpCodes,\n    updateOpCodes: I18nUpdateOpCodes, lView: LView, text: string): void {\n  const hasBinding = text.match(BINDING_REGEXP);\n  const tNode = createTNodeAndAddOpCode(\n      tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n  if (hasBinding) {\n    generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);\n  }\n}\n\n/**\n * See `i18nAttributes` above.\n */\nexport function i18nAttributesFirstPass(tView: TView, index: number, values: string[]) {\n  const previousElement = getCurrentTNode()!;\n  const previousElementIndex = previousElement.index;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  if (tView.firstCreatePass && tView.data[index] === null) {\n    for (let i = 0; i < values.length; i += 2) {\n      const attrName = values[i];\n      const message = values[i + 1];\n\n      if (message !== '') {\n        // Check if attribute value contains an ICU and throw an error if that's the case.\n        // ICUs in element attributes are not supported.\n        // Note: we intentionally retain the error here by not using `ngDevMode`, because\n        // the `value` can change based on the locale and users aren't guaranteed to hit\n        // an invalid string while they're developing.\n        if (ICU_REGEXP.test(message)) {\n          throw new Error(\n              `ICU expressions are not supported in attributes. Message: \"${message}\".`);\n        }\n\n        // i18n attributes that hit this code path are guaranteed to have bindings, because\n        // the compiler treats static i18n attributes as regular attribute bindings.\n        // Since this may not be the first i18n attribute on this element we need to pass in how\n        // many previous bindings there have already been.\n        generateBindingUpdateOpCodes(\n            updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes),\n            null);\n      }\n    }\n    tView.data[index] = updateOpCodes;\n  }\n}\n\n\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\nfunction generateBindingUpdateOpCodes(\n    updateOpCodes: I18nUpdateOpCodes, str: string, destinationNode: number, attrName: string|null,\n    bindingStart: number, sanitizeFn: SanitizerFn|null): number {\n  ngDevMode &&\n      assertGreaterThanOrEqual(\n          destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n  const maskIndex = updateOpCodes.length;  // Location of mask\n  const sizeIndex = maskIndex + 1;         // location of size for skipping\n  updateOpCodes.push(null, null);          // Alloc space for mask and size\n  const startIndex = maskIndex + 2;        // location of first allocation.\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  const textParts = str.split(BINDING_REGEXP);\n  let mask = 0;\n\n  for (let j = 0; j < textParts.length; j++) {\n    const textValue = textParts[j];\n\n    if (j & 1) {\n      // Odd indexes are bindings\n      const bindingIndex = bindingStart + parseInt(textValue, 10);\n      updateOpCodes.push(-1 - bindingIndex);\n      mask = mask | toMaskBit(bindingIndex);\n    } else if (textValue !== '') {\n      // Even indexes are text\n      updateOpCodes.push(textValue);\n    }\n  }\n\n  updateOpCodes.push(\n      destinationNode << I18nUpdateOpCode.SHIFT_REF |\n      (attrName ? I18nUpdateOpCode.Attr : I18nUpdateOpCode.Text));\n  if (attrName) {\n    updateOpCodes.push(attrName, sanitizeFn);\n  }\n  updateOpCodes[maskIndex] = mask;\n  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n  return mask;\n}\n\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\nfunction countBindings(opCodes: I18nUpdateOpCodes): number {\n  let count = 0;\n  for (let i = 0; i < opCodes.length; i++) {\n    const opCode = opCodes[i];\n    // Bindings are negative numbers.\n    if (typeof opCode === 'number' && opCode < 0) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\nfunction toMaskBit(bindingIndex: number): number {\n  return 1 << Math.min(bindingIndex, 31);\n}\n\nexport function isRootTemplateMessage(subTemplateIndex: number): subTemplateIndex is - 1 {\n  return subTemplateIndex === -1;\n}\n\n\n/**\n * Removes everything inside the sub-templates of a message.\n */\nfunction removeInnerTemplateTranslation(message: string): string {\n  let match;\n  let res = '';\n  let index = 0;\n  let inTemplate = false;\n  let tagMatched;\n\n  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n    if (!inTemplate) {\n      res += message.substring(index, match.index + match[0].length);\n      tagMatched = match[1];\n      inTemplate = true;\n    } else {\n      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n        index = match.index;\n        inTemplate = false;\n      }\n    }\n  }\n\n  ngDevMode &&\n      assertEqual(\n          inTemplate, false,\n          `Tag mismatch: unable to find the end of the sub-template in the translation \"${\n              message}\"`);\n\n  res += message.slice(index);\n  return res;\n}\n\n\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nexport function getTranslationForTemplate(message: string, subTemplateIndex: number) {\n  if (isRootTemplateMessage(subTemplateIndex)) {\n    // We want the root template message, ignore all sub-templates\n    return removeInnerTemplateTranslation(message);\n  } else {\n    // We want a specific sub-template\n    const start =\n        message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n    return removeInnerTemplateTranslation(message.substring(start, end));\n  }\n}\n\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\nexport function icuStart(\n    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n    icuExpression: IcuExpression, anchorIdx: number) {\n  ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n  let bindingMask = 0;\n  const tIcu: TIcu = {\n    type: icuExpression.type,\n    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n    anchorIdx,\n    cases: [],\n    create: [],\n    remove: [],\n    update: []\n  };\n  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n  setTIcu(tView, anchorIdx, tIcu);\n  const values = icuExpression.values;\n  for (let i = 0; i < values.length; i++) {\n    // Each value is an array of strings & other ICU expressions\n    const valueArr = values[i];\n    const nestedIcus: IcuExpression[] = [];\n    for (let j = 0; j < valueArr.length; j++) {\n      const value = valueArr[j];\n      if (typeof value !== 'string') {\n        // It is an nested ICU expression\n        const icuIndex = nestedIcus.push(value as IcuExpression) - 1;\n        // Replace nested ICU expression by a comment node\n        valueArr[j] = `<!--�${icuIndex}�-->`;\n      }\n    }\n    bindingMask = parseIcuCase(\n                      tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i],\n                      valueArr.join(''), nestedIcus) |\n        bindingMask;\n  }\n  if (bindingMask) {\n    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n  }\n}\n\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\nexport function parseICUBlock(pattern: string): IcuExpression {\n  const cases = [];\n  const values: (string|IcuExpression)[][] = [];\n  let icuType = IcuType.plural;\n  let mainBinding = 0;\n  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str: string, binding: string, type: string) {\n    if (type === 'select') {\n      icuType = IcuType.select;\n    } else {\n      icuType = IcuType.plural;\n    }\n    mainBinding = parseInt(binding.slice(1), 10);\n    return '';\n  });\n\n  const parts = i18nParseTextIntoPartsAndICU(pattern) as string[];\n  // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n  for (let pos = 0; pos < parts.length;) {\n    let key = parts[pos++].trim();\n    if (icuType === IcuType.plural) {\n      // Key can be \"=x\", we just want \"x\"\n      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n    }\n    if (key.length) {\n      cases.push(key);\n    }\n\n    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]) as string[];\n    if (cases.length > values.length) {\n      values.push(blocks);\n    }\n  }\n\n  // TODO(ocombe): support ICU expressions in attributes, see #21615\n  return {type: icuType, mainBinding: mainBinding, cases, values};\n}\n\n\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\nexport function i18nParseTextIntoPartsAndICU(pattern: string): (string|IcuExpression)[] {\n  if (!pattern) {\n    return [];\n  }\n\n  let prevPos = 0;\n  const braceStack = [];\n  const results: (string|IcuExpression)[] = [];\n  const braces = /[{}]/g;\n  // lastIndex doesn't get set to 0 so we have to.\n  braces.lastIndex = 0;\n\n  let match;\n  while (match = braces.exec(pattern)) {\n    const pos = match.index;\n    if (match[0] == '}') {\n      braceStack.pop();\n\n      if (braceStack.length == 0) {\n        // End of the block.\n        const block = pattern.substring(prevPos, pos);\n        if (ICU_BLOCK_REGEXP.test(block)) {\n          results.push(parseICUBlock(block));\n        } else {\n          results.push(block);\n        }\n\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        const substring = pattern.substring(prevPos, pos);\n        results.push(substring);\n        prevPos = pos + 1;\n      }\n      braceStack.push('{');\n    }\n  }\n\n  const substring = pattern.substring(prevPos);\n  results.push(substring);\n  return results;\n}\n\n\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\nexport function parseIcuCase(\n    tView: TView, tIcu: TIcu, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n    caseName: string, unsafeCaseHtml: string, nestedIcus: IcuExpression[]): number {\n  const create: IcuCreateOpCodes = [] as any;\n  const remove: I18nRemoveOpCodes = [] as any;\n  const update: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(create, icuCreateOpCodesToString);\n    attachDebugGetter(remove, i18nRemoveOpCodesToString);\n    attachDebugGetter(update, i18nUpdateOpCodesToString);\n  }\n  tIcu.cases.push(caseName);\n  tIcu.create.push(create);\n  tIcu.remove.push(remove);\n  tIcu.update.push(update);\n\n  const inertBodyHelper = getInertBodyHelper(getDocument());\n  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n  ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n  const inertRootNode = getTemplateContent(inertBodyElement!) as Element || inertBodyElement;\n  if (inertRootNode) {\n    return walkIcuTree(\n        tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx,\n        nestedIcus, 0);\n  } else {\n    return 0;\n  }\n}\n\nfunction walkIcuTree(\n    tView: TView, tIcu: TIcu, lView: LView, sharedUpdateOpCodes: I18nUpdateOpCodes,\n    create: IcuCreateOpCodes, remove: I18nRemoveOpCodes, update: I18nUpdateOpCodes,\n    parentNode: Element, parentIdx: number, nestedIcus: IcuExpression[], depth: number): number {\n  let bindingMask = 0;\n  let currentNode = parentNode.firstChild;\n  while (currentNode) {\n    const newIndex = allocExpando(tView, lView, 1, null);\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = currentNode as Element;\n        const tagName = element.tagName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n          tView.data[newIndex] = tagName;\n          const elAttrs = element.attributes;\n          for (let i = 0; i < elAttrs.length; i++) {\n            const attr = elAttrs.item(i)!;\n            const lowerAttrName = attr.name.toLowerCase();\n            const hasBinding = !!attr.value.match(BINDING_REGEXP);\n            // we assume the input string is safe, unless it's using a binding\n            if (hasBinding) {\n              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                if (URI_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(\n                      update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                } else {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                }\n              } else {\n                ngDevMode &&\n                    console.warn(\n                        `WARNING: ignoring unsafe attribute value ` +\n                        `${lowerAttrName} on element ${tagName} ` +\n                        `(see https://g.co/ng/security#xss)`);\n              }\n            } else {\n              addCreateAttribute(create, newIndex, attr);\n            }\n          }\n          // Parse the children of this node (if any)\n          bindingMask = walkIcuTree(\n                            tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update,\n                            currentNode as Element, newIndex, nestedIcus, depth + 1) |\n              bindingMask;\n          addRemoveNode(remove, newIndex, depth);\n        }\n        break;\n      case Node.TEXT_NODE:\n        const value = currentNode.textContent || '';\n        const hasBinding = value.match(BINDING_REGEXP);\n        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n        addRemoveNode(remove, newIndex, depth);\n        if (hasBinding) {\n          bindingMask =\n              generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n        }\n        break;\n      case Node.COMMENT_NODE:\n        // Check if the comment node is a placeholder for a nested ICU\n        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n        if (isNestedIcu) {\n          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n          const icuExpression: IcuExpression = nestedIcus[nestedIcuIndex];\n          // Create the comment node that will anchor the ICU expression\n          addCreateNodeAndAppend(\n              create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx,\n              newIndex);\n          icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n          addRemoveNestedIcu(remove, newIndex, depth);\n        }\n        break;\n    }\n    currentNode = currentNode.nextSibling;\n  }\n  return bindingMask;\n}\n\nfunction addRemoveNode(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(index);\n  }\n}\n\nfunction addRemoveNestedIcu(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(~index);  // remove ICU at `index`\n    remove.push(index);   // remove ICU comment at `index`\n  }\n}\n\nfunction addUpdateIcuSwitch(\n    update: I18nUpdateOpCodes, icuExpression: IcuExpression, index: number) {\n  update.push(\n      toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding,\n      index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch);\n}\n\nfunction addUpdateIcuUpdate(update: I18nUpdateOpCodes, bindingMask: number, index: number) {\n  update.push(bindingMask, 1, index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate);\n}\n\nfunction addCreateNodeAndAppend(\n    create: IcuCreateOpCodes, marker: null|ICU_MARKER|ELEMENT_MARKER, text: string,\n    appendToParentIdx: number, createAtIdx: number) {\n  if (marker !== null) {\n    create.push(marker);\n  }\n  create.push(\n      text, createAtIdx,\n      icuCreateOpCode(IcuCreateOpCode.AppendChild, appendToParentIdx, createAtIdx));\n}\n\nfunction addCreateAttribute(create: IcuCreateOpCodes, newIndex: number, attr: Attr) {\n  create.push(newIndex << IcuCreateOpCode.SHIFT_REF | IcuCreateOpCode.Attr, attr.name, attr.value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// i18nPostprocess consts\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n\n// Parsed placeholder structure used in postprocessing (within `i18nPostprocess` function)\n// Contains the following fields: [templateId, isCloseTemplateTag, placeholder]\ntype PostprocessPlaceholder = [number, boolean, string];\n\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function i18nPostprocess(\n    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n  /**\n   * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\n   *\n   * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n   * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\n   * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\n   * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\n   * front of �#6�. The post processing step restores the right order by keeping track of the\n   * template id stack and looks for placeholders that belong to the currently active template.\n   */\n  let result: string = message;\n  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n    const matches: {[key: string]: PostprocessPlaceholder[]} = {};\n    const templateIdsStack: number[] = [ROOT_TEMPLATE_ID];\n    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m: any, phs: string, tmpl: string): string => {\n      const content = phs || tmpl;\n      const placeholders: PostprocessPlaceholder[] = matches[content] || [];\n      if (!placeholders.length) {\n        content.split('|').forEach((placeholder: string) => {\n          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n          placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n        });\n        matches[content] = placeholders;\n      }\n\n      if (!placeholders.length) {\n        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n      }\n\n      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n      let idx = 0;\n      // find placeholder index that matches current template id\n      for (let i = 0; i < placeholders.length; i++) {\n        if (placeholders[i][0] === currentTemplateId) {\n          idx = i;\n          break;\n        }\n      }\n      // update template id stack based on the current tag extracted\n      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n      if (isCloseTemplateTag) {\n        templateIdsStack.pop();\n      } else if (currentTemplateId !== templateId) {\n        templateIdsStack.push(templateId);\n      }\n      // remove processed tag from the list\n      placeholders.splice(idx, 1);\n      return placeholder;\n    });\n  }\n\n  // return current result if no replacements specified\n  if (!Object.keys(replacements).length) {\n    return result;\n  }\n\n  /**\n   * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n   */\n  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end): string => {\n    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n  });\n\n  /**\n   * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n   */\n  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key): string => {\n    return replacements.hasOwnProperty(key) ? replacements[key] as string : match;\n  });\n\n  /**\n   * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\n   * multiple ICUs have the same placeholder name\n   */\n  result = result.replace(PP_ICUS_REGEXP, (match, key): string => {\n    if (replacements.hasOwnProperty(key)) {\n      const list = replacements[key] as string[];\n      if (!list.length) {\n        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n      }\n      return list.shift()!;\n    }\n    return match;\n  });\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {assertDefined} from '../../util/assert';\nimport {bindingUpdated} from '../bindings';\nimport {applyCreateOpCodes, applyI18n, setMaskBit} from '../i18n/i18n_apply';\nimport {i18nAttributesFirstPass, i18nStartFirstCreatePass} from '../i18n/i18n_parse';\nimport {i18nPostprocess} from '../i18n/i18n_postprocess';\nimport {TI18n} from '../interfaces/i18n';\nimport {TElementNode, TNodeType} from '../interfaces/node';\nimport {HEADER_OFFSET, T_HOST} from '../interfaces/view';\nimport {getClosestRElement} from '../node_manipulation';\nimport {getCurrentParentTNode, getLView, getTView, nextBindingIndex, setInI18nBlock} from '../state';\nimport {getConstant} from '../util/view_utils';\n\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport function ɵɵi18nStart(\n    index: number, messageIndex: number, subTemplateIndex: number = -1): void {\n  const tView = getTView();\n  const lView = getLView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const message = getConstant<string>(tView.consts, messageIndex)!;\n  const parentTNode = getCurrentParentTNode() as TElementNode | null;\n  if (tView.firstCreatePass) {\n    i18nStartFirstCreatePass(\n        tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message,\n        subTemplateIndex);\n  }\n  const tI18n = tView.data[adjustedIndex] as TI18n;\n  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n  // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n  // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n  const insertInFrontOf = parentTNode && (parentTNode.type & TNodeType.ElementContainer) ?\n      lView[parentTNode.index] :\n      null;\n  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n  setInI18nBlock(true);\n}\n\n\n\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\nexport function ɵɵi18nEnd(): void {\n  setInI18nBlock(false);\n}\n\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport function ɵɵi18n(index: number, messageIndex: number, subTemplateIndex?: number): void {\n  ɵɵi18nStart(index, messageIndex, subTemplateIndex);\n  ɵɵi18nEnd();\n}\n\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\nexport function ɵɵi18nAttributes(index: number, attrsIndex: number): void {\n  const tView = getTView();\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const attrs = getConstant<string[]>(tView.consts, attrsIndex)!;\n  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\n\n\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\nexport function ɵɵi18nExp<T>(value: T): typeof ɵɵi18nExp {\n  const lView = getLView();\n  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n  return ɵɵi18nExp;\n}\n\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\nexport function ɵɵi18nApply(index: number) {\n  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function ɵɵi18nPostprocess(\n    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n  return i18nPostprocess(message, replacements);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {forwardRef, resolveForwardRef} from '../../di/forward_ref';\nimport {ɵɵinject, ɵɵinvalidFactoryDep} from '../../di/injector_compatibility';\nimport {ɵɵdefineInjectable, ɵɵdefineInjector} from '../../di/interface/defs';\nimport {registerNgModuleType} from '../../linker/ng_module_registration';\nimport * as sanitization from '../../sanitization/sanitization';\nimport * as r3 from '../index';\n\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nexport const angularCoreEnv: {[name: string]: Function} =\n    (() => ({\n       'ɵɵattribute': r3.ɵɵattribute,\n       'ɵɵattributeInterpolate1': r3.ɵɵattributeInterpolate1,\n       'ɵɵattributeInterpolate2': r3.ɵɵattributeInterpolate2,\n       'ɵɵattributeInterpolate3': r3.ɵɵattributeInterpolate3,\n       'ɵɵattributeInterpolate4': r3.ɵɵattributeInterpolate4,\n       'ɵɵattributeInterpolate5': r3.ɵɵattributeInterpolate5,\n       'ɵɵattributeInterpolate6': r3.ɵɵattributeInterpolate6,\n       'ɵɵattributeInterpolate7': r3.ɵɵattributeInterpolate7,\n       'ɵɵattributeInterpolate8': r3.ɵɵattributeInterpolate8,\n       'ɵɵattributeInterpolateV': r3.ɵɵattributeInterpolateV,\n       'ɵɵdefineComponent': r3.ɵɵdefineComponent,\n       'ɵɵdefineDirective': r3.ɵɵdefineDirective,\n       'ɵɵdefineInjectable': ɵɵdefineInjectable,\n       'ɵɵdefineInjector': ɵɵdefineInjector,\n       'ɵɵdefineNgModule': r3.ɵɵdefineNgModule,\n       'ɵɵdefinePipe': r3.ɵɵdefinePipe,\n       'ɵɵdirectiveInject': r3.ɵɵdirectiveInject,\n       'ɵɵgetInheritedFactory': r3.ɵɵgetInheritedFactory,\n       'ɵɵinject': ɵɵinject,\n       'ɵɵinjectAttribute': r3.ɵɵinjectAttribute,\n       'ɵɵinvalidFactory': r3.ɵɵinvalidFactory,\n       'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n       'ɵɵtemplateRefExtractor': r3.ɵɵtemplateRefExtractor,\n       'ɵɵresetView': r3.ɵɵresetView,\n       'ɵɵNgOnChangesFeature': r3.ɵɵNgOnChangesFeature,\n       'ɵɵProvidersFeature': r3.ɵɵProvidersFeature,\n       'ɵɵCopyDefinitionFeature': r3.ɵɵCopyDefinitionFeature,\n       'ɵɵInheritDefinitionFeature': r3.ɵɵInheritDefinitionFeature,\n       'ɵɵStandaloneFeature': r3.ɵɵStandaloneFeature,\n       'ɵɵnextContext': r3.ɵɵnextContext,\n       'ɵɵnamespaceHTML': r3.ɵɵnamespaceHTML,\n       'ɵɵnamespaceMathML': r3.ɵɵnamespaceMathML,\n       'ɵɵnamespaceSVG': r3.ɵɵnamespaceSVG,\n       'ɵɵenableBindings': r3.ɵɵenableBindings,\n       'ɵɵdisableBindings': r3.ɵɵdisableBindings,\n       'ɵɵelementStart': r3.ɵɵelementStart,\n       'ɵɵelementEnd': r3.ɵɵelementEnd,\n       'ɵɵelement': r3.ɵɵelement,\n       'ɵɵelementContainerStart': r3.ɵɵelementContainerStart,\n       'ɵɵelementContainerEnd': r3.ɵɵelementContainerEnd,\n       'ɵɵelementContainer': r3.ɵɵelementContainer,\n       'ɵɵpureFunction0': r3.ɵɵpureFunction0,\n       'ɵɵpureFunction1': r3.ɵɵpureFunction1,\n       'ɵɵpureFunction2': r3.ɵɵpureFunction2,\n       'ɵɵpureFunction3': r3.ɵɵpureFunction3,\n       'ɵɵpureFunction4': r3.ɵɵpureFunction4,\n       'ɵɵpureFunction5': r3.ɵɵpureFunction5,\n       'ɵɵpureFunction6': r3.ɵɵpureFunction6,\n       'ɵɵpureFunction7': r3.ɵɵpureFunction7,\n       'ɵɵpureFunction8': r3.ɵɵpureFunction8,\n       'ɵɵpureFunctionV': r3.ɵɵpureFunctionV,\n       'ɵɵgetCurrentView': r3.ɵɵgetCurrentView,\n       'ɵɵrestoreView': r3.ɵɵrestoreView,\n       'ɵɵlistener': r3.ɵɵlistener,\n       'ɵɵprojection': r3.ɵɵprojection,\n       'ɵɵsyntheticHostProperty': r3.ɵɵsyntheticHostProperty,\n       'ɵɵsyntheticHostListener': r3.ɵɵsyntheticHostListener,\n       'ɵɵpipeBind1': r3.ɵɵpipeBind1,\n       'ɵɵpipeBind2': r3.ɵɵpipeBind2,\n       'ɵɵpipeBind3': r3.ɵɵpipeBind3,\n       'ɵɵpipeBind4': r3.ɵɵpipeBind4,\n       'ɵɵpipeBindV': r3.ɵɵpipeBindV,\n       'ɵɵprojectionDef': r3.ɵɵprojectionDef,\n       'ɵɵhostProperty': r3.ɵɵhostProperty,\n       'ɵɵproperty': r3.ɵɵproperty,\n       'ɵɵpropertyInterpolate': r3.ɵɵpropertyInterpolate,\n       'ɵɵpropertyInterpolate1': r3.ɵɵpropertyInterpolate1,\n       'ɵɵpropertyInterpolate2': r3.ɵɵpropertyInterpolate2,\n       'ɵɵpropertyInterpolate3': r3.ɵɵpropertyInterpolate3,\n       'ɵɵpropertyInterpolate4': r3.ɵɵpropertyInterpolate4,\n       'ɵɵpropertyInterpolate5': r3.ɵɵpropertyInterpolate5,\n       'ɵɵpropertyInterpolate6': r3.ɵɵpropertyInterpolate6,\n       'ɵɵpropertyInterpolate7': r3.ɵɵpropertyInterpolate7,\n       'ɵɵpropertyInterpolate8': r3.ɵɵpropertyInterpolate8,\n       'ɵɵpropertyInterpolateV': r3.ɵɵpropertyInterpolateV,\n       'ɵɵpipe': r3.ɵɵpipe,\n       'ɵɵqueryRefresh': r3.ɵɵqueryRefresh,\n       'ɵɵviewQuery': r3.ɵɵviewQuery,\n       'ɵɵloadQuery': r3.ɵɵloadQuery,\n       'ɵɵcontentQuery': r3.ɵɵcontentQuery,\n       'ɵɵreference': r3.ɵɵreference,\n       'ɵɵclassMap': r3.ɵɵclassMap,\n       'ɵɵclassMapInterpolate1': r3.ɵɵclassMapInterpolate1,\n       'ɵɵclassMapInterpolate2': r3.ɵɵclassMapInterpolate2,\n       'ɵɵclassMapInterpolate3': r3.ɵɵclassMapInterpolate3,\n       'ɵɵclassMapInterpolate4': r3.ɵɵclassMapInterpolate4,\n       'ɵɵclassMapInterpolate5': r3.ɵɵclassMapInterpolate5,\n       'ɵɵclassMapInterpolate6': r3.ɵɵclassMapInterpolate6,\n       'ɵɵclassMapInterpolate7': r3.ɵɵclassMapInterpolate7,\n       'ɵɵclassMapInterpolate8': r3.ɵɵclassMapInterpolate8,\n       'ɵɵclassMapInterpolateV': r3.ɵɵclassMapInterpolateV,\n       'ɵɵstyleMap': r3.ɵɵstyleMap,\n       'ɵɵstyleMapInterpolate1': r3.ɵɵstyleMapInterpolate1,\n       'ɵɵstyleMapInterpolate2': r3.ɵɵstyleMapInterpolate2,\n       'ɵɵstyleMapInterpolate3': r3.ɵɵstyleMapInterpolate3,\n       'ɵɵstyleMapInterpolate4': r3.ɵɵstyleMapInterpolate4,\n       'ɵɵstyleMapInterpolate5': r3.ɵɵstyleMapInterpolate5,\n       'ɵɵstyleMapInterpolate6': r3.ɵɵstyleMapInterpolate6,\n       'ɵɵstyleMapInterpolate7': r3.ɵɵstyleMapInterpolate7,\n       'ɵɵstyleMapInterpolate8': r3.ɵɵstyleMapInterpolate8,\n       'ɵɵstyleMapInterpolateV': r3.ɵɵstyleMapInterpolateV,\n       'ɵɵstyleProp': r3.ɵɵstyleProp,\n       'ɵɵstylePropInterpolate1': r3.ɵɵstylePropInterpolate1,\n       'ɵɵstylePropInterpolate2': r3.ɵɵstylePropInterpolate2,\n       'ɵɵstylePropInterpolate3': r3.ɵɵstylePropInterpolate3,\n       'ɵɵstylePropInterpolate4': r3.ɵɵstylePropInterpolate4,\n       'ɵɵstylePropInterpolate5': r3.ɵɵstylePropInterpolate5,\n       'ɵɵstylePropInterpolate6': r3.ɵɵstylePropInterpolate6,\n       'ɵɵstylePropInterpolate7': r3.ɵɵstylePropInterpolate7,\n       'ɵɵstylePropInterpolate8': r3.ɵɵstylePropInterpolate8,\n       'ɵɵstylePropInterpolateV': r3.ɵɵstylePropInterpolateV,\n       'ɵɵclassProp': r3.ɵɵclassProp,\n       'ɵɵadvance': r3.ɵɵadvance,\n       'ɵɵtemplate': r3.ɵɵtemplate,\n       'ɵɵtext': r3.ɵɵtext,\n       'ɵɵtextInterpolate': r3.ɵɵtextInterpolate,\n       'ɵɵtextInterpolate1': r3.ɵɵtextInterpolate1,\n       'ɵɵtextInterpolate2': r3.ɵɵtextInterpolate2,\n       'ɵɵtextInterpolate3': r3.ɵɵtextInterpolate3,\n       'ɵɵtextInterpolate4': r3.ɵɵtextInterpolate4,\n       'ɵɵtextInterpolate5': r3.ɵɵtextInterpolate5,\n       'ɵɵtextInterpolate6': r3.ɵɵtextInterpolate6,\n       'ɵɵtextInterpolate7': r3.ɵɵtextInterpolate7,\n       'ɵɵtextInterpolate8': r3.ɵɵtextInterpolate8,\n       'ɵɵtextInterpolateV': r3.ɵɵtextInterpolateV,\n       'ɵɵi18n': r3.ɵɵi18n,\n       'ɵɵi18nAttributes': r3.ɵɵi18nAttributes,\n       'ɵɵi18nExp': r3.ɵɵi18nExp,\n       'ɵɵi18nStart': r3.ɵɵi18nStart,\n       'ɵɵi18nEnd': r3.ɵɵi18nEnd,\n       'ɵɵi18nApply': r3.ɵɵi18nApply,\n       'ɵɵi18nPostprocess': r3.ɵɵi18nPostprocess,\n       'ɵɵresolveWindow': r3.ɵɵresolveWindow,\n       'ɵɵresolveDocument': r3.ɵɵresolveDocument,\n       'ɵɵresolveBody': r3.ɵɵresolveBody,\n       'ɵɵsetComponentScope': r3.ɵɵsetComponentScope,\n       'ɵɵsetNgModuleScope': r3.ɵɵsetNgModuleScope,\n       'ɵɵregisterNgModuleType': registerNgModuleType,\n\n       'ɵɵsanitizeHtml': sanitization.ɵɵsanitizeHtml,\n       'ɵɵsanitizeStyle': sanitization.ɵɵsanitizeStyle,\n       'ɵɵsanitizeResourceUrl': sanitization.ɵɵsanitizeResourceUrl,\n       'ɵɵsanitizeScript': sanitization.ɵɵsanitizeScript,\n       'ɵɵsanitizeUrl': sanitization.ɵɵsanitizeUrl,\n       'ɵɵsanitizeUrlOrResourceUrl': sanitization.ɵɵsanitizeUrlOrResourceUrl,\n       'ɵɵtrustConstantHtml': sanitization.ɵɵtrustConstantHtml,\n       'ɵɵtrustConstantResourceUrl': sanitization.ɵɵtrustConstantResourceUrl,\n\n       'forwardRef': forwardRef,\n       'resolveForwardRef': resolveForwardRef,\n     }))();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {getBindingIndex, getLView, getSelectedTNode, getTView} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {elementAttributeInternal, storePropertyBindingMetadata} from './shared';\n\n\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate1(\n    attrName: string, prefix: string, v0: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return ɵɵattributeInterpolate1;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate2(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return ɵɵattributeInterpolate2;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate3(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1,\n            suffix);\n  }\n  return ɵɵattributeInterpolate3;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate4(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2,\n            suffix);\n  }\n  return ɵɵattributeInterpolate4;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate5(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2,\n            i3, suffix);\n  }\n  return ɵɵattributeInterpolate5;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate6(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2,\n            i3, i4, suffix);\n  }\n  return ɵɵattributeInterpolate6;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate7(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2,\n            i3, i4, i5, suffix);\n  }\n  return ɵɵattributeInterpolate7;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate8(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2,\n            i3, i4, i5, i6, suffix);\n  }\n  return ɵɵattributeInterpolate8;\n}\n\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolateV(\n    attrName: string, values: any[], sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolateV {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          getTView().data, tNode, 'attr.' + attrName,\n          getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n  return ɵɵattributeInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {ɵɵstyleMap} from './styling';\n\n\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  ɵɵstyleMap(interpolatedValue);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView,} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingProperty} from './styling';\n\n\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate1(\n    prop: string, prefix: string, v0: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate1;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate2(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate2;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate3(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate3;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate4(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, valueSuffix?: string|null): typeof ɵɵstylePropInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate4;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate5(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate5;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate6(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate6;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate7(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate7;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate8(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, valueSuffix?: string|null): typeof ɵɵstylePropInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate8;\n}\n\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolateV(\n    prop: string, values: any[], valueSuffix?: string|null): typeof ɵɵstylePropInterpolateV {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ModuleWithProviders} from '../../di/interface/provider';\nimport {Type} from '../../interface/type';\nimport {NgModuleDef} from '../../metadata/ng_module_def';\nimport {getNgModuleDef} from '../definition';\n\nexport function isModuleWithProviders(value: any): value is ModuleWithProviders<{}> {\n  return (value as {ngModule?: any}).ngModule !== undefined;\n}\n\nexport function isNgModule<T>(value: Type<T>): value is Type<T>&{ɵmod: NgModuleDef<T>} {\n  return !!getNgModuleDef(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3InjectorMetadataFacade} from '../../compiler/compiler_facade';\nimport {resolveForwardRef} from '../../di/forward_ref';\nimport {NG_INJ_DEF} from '../../di/interface/defs';\nimport {ModuleWithProviders} from '../../di/interface/provider';\nimport {reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {registerNgModuleType} from '../../linker/ng_module_registration';\nimport {Component} from '../../metadata/directives';\nimport {NgModule} from '../../metadata/ng_module';\nimport {NgModuleDef, NgModuleTransitiveScopes, NgModuleType} from '../../metadata/ng_module_def';\nimport {deepForEach, flatten} from '../../util/array_utils';\nimport {assertDefined} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {getComponentDef, getDirectiveDef, getNgModuleDef, getPipeDef, isStandalone} from '../definition';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF, NG_MOD_DEF, NG_PIPE_DEF} from '../fields';\nimport {ComponentDef} from '../interfaces/definition';\nimport {maybeUnwrapFn} from '../util/misc_utils';\nimport {stringifyForError} from '../util/stringify_utils';\n\nimport {angularCoreEnv} from './environment';\nimport {patchModuleCompilation} from './module_patch';\nimport {isModuleWithProviders, isNgModule} from './util';\n\ninterface ModuleQueueItem {\n  moduleType: Type<any>;\n  ngModule: NgModule;\n}\n\nconst moduleQueue: ModuleQueueItem[] = [];\n\n/**\n * Enqueues moduleDef to be checked later to see if scope can be set on its\n * component declarations.\n */\nfunction enqueueModuleForDelayedScoping(moduleType: Type<any>, ngModule: NgModule) {\n  moduleQueue.push({moduleType, ngModule});\n}\n\nlet flushingModuleQueue = false;\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\nexport function flushModuleScopingQueueAsMuchAsPossible() {\n  if (!flushingModuleQueue) {\n    flushingModuleQueue = true;\n    try {\n      for (let i = moduleQueue.length - 1; i >= 0; i--) {\n        const {moduleType, ngModule} = moduleQueue[i];\n\n        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n          // dequeue\n          moduleQueue.splice(i, 1);\n          setScopeOnDeclaredComponents(moduleType, ngModule);\n        }\n      }\n    } finally {\n      flushingModuleQueue = false;\n    }\n  }\n}\n\n/**\n * Returns truthy if a declaration has resolved. If the declaration happens to be\n * an array of declarations, it will recurse to check each declaration in that array\n * (which may also be arrays).\n */\nfunction isResolvedDeclaration(declaration: any[]|Type<any>): boolean {\n  if (Array.isArray(declaration)) {\n    return declaration.every(isResolvedDeclaration);\n  }\n  return !!resolveForwardRef(declaration);\n}\n\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nexport function compileNgModule(moduleType: Type<any>, ngModule: NgModule = {}): void {\n  patchModuleCompilation();\n  compileNgModuleDefs(moduleType as NgModuleType, ngModule);\n  if (ngModule.id !== undefined) {\n    registerNgModuleType(moduleType as NgModuleType, ngModule.id);\n  }\n\n  // Because we don't know if all declarations have resolved yet at the moment the\n  // NgModule decorator is executing, we're enqueueing the setting of module scope\n  // on its declarations to be run at a later time when all declarations for the module,\n  // including forward refs, have resolved.\n  enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\n\n/**\n * Compiles and adds the `ɵmod`, `ɵfac` and `ɵinj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\nexport function compileNgModuleDefs(\n    moduleType: NgModuleType, ngModule: NgModule,\n    allowDuplicateDeclarationsInRoot: boolean = false): void {\n  ngDevMode && assertDefined(moduleType, 'Required value moduleType');\n  ngDevMode && assertDefined(ngModule, 'Required value ngModule');\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n  let ngModuleDef: any = null;\n  Object.defineProperty(moduleType, NG_MOD_DEF, {\n    configurable: true,\n    get: () => {\n      if (ngModuleDef === null) {\n        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n          // We need to assert this immediately, because allowing it to continue will cause it to\n          // go into an infinite loop before we've reached the point where we throw all the errors.\n          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n        }\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {\n          type: moduleType,\n          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n          declarations: declarations.map(resolveForwardRef),\n          imports: flatten(ngModule.imports || EMPTY_ARRAY)\n                       .map(resolveForwardRef)\n                       .map(expandModuleWithProviders),\n          exports: flatten(ngModule.exports || EMPTY_ARRAY)\n                       .map(resolveForwardRef)\n                       .map(expandModuleWithProviders),\n          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,\n          id: ngModule.id || null,\n        });\n        // Set `schemas` on ngModuleDef to an empty array in JIT mode to indicate that runtime\n        // should verify that there are no unknown elements in a template. In AOT mode, that check\n        // happens at compile time and `schemas` information is not present on Component and Module\n        // defs after compilation (so the check doesn't happen the second time at runtime).\n        if (!ngModuleDef.schemas) {\n          ngModuleDef.schemas = [];\n        }\n      }\n      return ngModuleDef;\n    }\n  });\n\n  let ngFactoryDef: any = null;\n  Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {\n          name: moduleType.name,\n          type: moduleType,\n          deps: reflectDependencies(moduleType),\n          target: compiler.FactoryTarget.NgModule,\n          typeArgumentCount: 0,\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n\n  let ngInjectorDef: any = null;\n  Object.defineProperty(moduleType, NG_INJ_DEF, {\n    get: () => {\n      if (ngInjectorDef === null) {\n        ngDevMode &&\n            verifySemanticsOfNgModuleDef(\n                moduleType as any as NgModuleType, allowDuplicateDeclarationsInRoot);\n        const meta: R3InjectorMetadataFacade = {\n          name: moduleType.name,\n          type: moduleType,\n          providers: ngModule.providers || EMPTY_ARRAY,\n          imports: [\n            (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),\n            (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef),\n          ],\n        };\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngInjectorDef =\n            compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);\n      }\n      return ngInjectorDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nexport function generateStandaloneInDeclarationsError(type: Type<any>, location: string) {\n  const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n  const suffix = `\"${stringifyForError(type)}\" is marked as standalone and can't be declared ` +\n      'in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?';\n  return `${prefix} ${location}, ${suffix}`;\n}\n\nfunction verifySemanticsOfNgModuleDef(\n    moduleType: NgModuleType, allowDuplicateDeclarationsInRoot: boolean,\n    importingModule?: NgModuleType): void {\n  if (verifiedNgModule.get(moduleType)) return;\n\n  // skip verifications of standalone components, directives and pipes\n  if (isStandalone(moduleType)) return;\n\n  verifiedNgModule.set(moduleType, true);\n  moduleType = resolveForwardRef(moduleType);\n  let ngModuleDef: NgModuleDef<any>;\n  if (importingModule) {\n    ngModuleDef = getNgModuleDef(moduleType)!;\n    if (!ngModuleDef) {\n      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  } else {\n    ngModuleDef = getNgModuleDef(moduleType, true);\n  }\n  const errors: string[] = [];\n  const declarations = maybeUnwrapFn(ngModuleDef.declarations);\n  const imports = maybeUnwrapFn(ngModuleDef.imports);\n  flatten(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {\n    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n  });\n  const exports = maybeUnwrapFn(ngModuleDef.exports);\n  declarations.forEach(verifyDeclarationsHaveDefinitions);\n  declarations.forEach(verifyDirectivesHaveSelector);\n  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));\n  const combinedDeclarations: Type<any>[] = [\n    ...declarations.map(resolveForwardRef),\n    ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef),\n  ];\n  exports.forEach(verifyExportsAreDeclaredOrReExported);\n  declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n  declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);\n\n  const ngModule = getAnnotation<NgModule>(moduleType, 'NgModule');\n  if (ngModule) {\n    ngModule.imports &&\n        flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {\n          verifySemanticsOfNgModuleImport(mod, moduleType);\n          verifySemanticsOfNgModuleDef(mod, false, moduleType);\n        });\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n    ngModule.entryComponents &&\n        deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);\n  }\n\n  // Throw Error if any errors were detected.\n  if (errors.length) {\n    throw new Error(errors.join('\\n'));\n  }\n  ////////////////////////////////////////////////////////////////////////////////////////////////\n  function verifyDeclarationsHaveDefinitions(type: Type<any>): void {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    if (!def) {\n      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${\n          stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);\n    }\n  }\n\n  function verifyDirectivesHaveSelector(type: Type<any>): void {\n    type = resolveForwardRef(type);\n    const def = getDirectiveDef(type);\n    if (!getComponentDef(type) && def && def.selectors.length == 0) {\n      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n    }\n  }\n\n  function verifyNotStandalone(type: Type<any>, moduleType: NgModuleType): void {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    if (def?.standalone) {\n      const location = `\"${stringifyForError(moduleType)}\" NgModule`;\n      errors.push(generateStandaloneInDeclarationsError(type, location));\n    }\n  }\n\n  function verifyExportsAreDeclaredOrReExported(type: Type<any>) {\n    type = resolveForwardRef(type);\n    const kind = getComponentDef(type) && 'component' || getDirectiveDef(type) && 'directive' ||\n        getPipeDef(type) && 'pipe';\n    if (kind) {\n      // only checked if we are declared as Component, Directive, or Pipe\n      // Modules don't need to be declared or imported.\n      if (combinedDeclarations.lastIndexOf(type) === -1) {\n        // We are exporting something which we don't explicitly declare or import.\n        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${\n            stringifyForError(moduleType)} as it was neither declared nor imported!`);\n      }\n    }\n  }\n\n  function verifyDeclarationIsUnique(type: Type<any>, suppressErrors: boolean) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (existingModule && existingModule !== moduleType) {\n      if (!suppressErrors) {\n        const modules = [existingModule, moduleType].map(stringifyForError).sort();\n        errors.push(\n            `Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${\n                modules[0]} and ${modules[1]}! ` +\n            `Please consider moving ${stringifyForError(type)} to a higher module that imports ${\n                modules[0]} and ${modules[1]}. ` +\n            `You can also create a new NgModule that exports and includes ${\n                stringifyForError(\n                    type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);\n      }\n    } else {\n      // Mark type as having owner.\n      ownerNgModule.set(type, moduleType);\n    }\n  }\n\n  function verifyComponentIsPartOfNgModule(type: Type<any>) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (!existingModule && !isStandalone(type)) {\n      errors.push(`Component ${\n          stringifyForError(\n              type)} is not part of any NgModule or the module has not been imported into your module.`);\n    }\n  }\n\n  function verifyCorrectBootstrapType(type: Type<any>) {\n    type = resolveForwardRef(type);\n    if (!getComponentDef(type)) {\n      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n    }\n    if (isStandalone(type)) {\n      // Note: this error should be the same as the\n      // `NGMODULE_BOOTSTRAP_IS_STANDALONE` one in AOT compiler.\n      errors.push(\n          `The \\`${stringifyForError(type)}\\` class is a standalone component, which can ` +\n          `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` +\n          `function for bootstrap instead.`);\n    }\n  }\n\n  function verifyComponentEntryComponentsIsPartOfNgModule(type: Type<any>) {\n    type = resolveForwardRef(type);\n    if (getComponentDef(type)) {\n      // We know we are component\n      const component = getAnnotation<Component>(type, 'Component');\n      if (component && component.entryComponents) {\n        deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);\n      }\n    }\n  }\n\n  function verifySemanticsOfNgModuleImport(type: Type<any>, importingModule: Type<any>) {\n    type = resolveForwardRef(type);\n\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null && !directiveDef.standalone) {\n      throw new Error(`Unexpected directive '${type.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n\n    const pipeDef = getPipeDef(type);\n    if (pipeDef !== null && !pipeDef.standalone) {\n      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  }\n}\n\nfunction unwrapModuleWithProvidersImports(typeOrWithProviders: NgModuleType<any>|\n                                          {ngModule: NgModuleType<any>}): NgModuleType<any> {\n  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n  return (typeOrWithProviders as any).ngModule || typeOrWithProviders;\n}\n\nfunction getAnnotation<T>(type: any, name: string): T|null {\n  let annotation: T|null = null;\n  collect(type.__annotations__);\n  collect(type.decorators);\n  return annotation;\n\n  function collect(annotations: any[]|null) {\n    if (annotations) {\n      annotations.forEach(readAnnotation);\n    }\n  }\n\n  function readAnnotation(\n      decorator: {type: {prototype: {ngMetadataName: string}, args: any[]}, args: any}): void {\n    if (!annotation) {\n      const proto = Object.getPrototypeOf(decorator);\n      if (proto.ngMetadataName == name) {\n        annotation = decorator as any;\n      } else if (decorator.type) {\n        const proto = Object.getPrototypeOf(decorator.type);\n        if (proto.ngMetadataName == name) {\n          annotation = decorator.args[0];\n        }\n      }\n    }\n  }\n}\n\n/**\n * Keep track of compiled components. This is needed because in tests we often want to compile the\n * same component with more than one NgModule. This would cause an error unless we reset which\n * NgModule the component belongs to. We keep the list of compiled components here so that the\n * TestBed can reset it later.\n */\nlet ownerNgModule = new WeakMap<Type<any>, NgModuleType<any>>();\nlet verifiedNgModule = new WeakMap<NgModuleType<any>, boolean>();\n\nexport function resetCompiledComponents(): void {\n  ownerNgModule = new WeakMap<Type<any>, NgModuleType<any>>();\n  verifiedNgModule = new WeakMap<NgModuleType<any>, boolean>();\n  moduleQueue.length = 0;\n}\n\n/**\n * Computes the combined declarations of explicit declarations, as well as declarations inherited by\n * traversing the exports of imported modules.\n * @param type\n */\nfunction computeCombinedExports(type: Type<any>): Type<any>[] {\n  type = resolveForwardRef(type);\n  const ngModuleDef = getNgModuleDef(type);\n\n  // a standalone component, directive or pipe\n  if (ngModuleDef === null) {\n    return [type];\n  }\n\n  return [...flatten(maybeUnwrapFn(ngModuleDef.exports).map((type) => {\n    const ngModuleDef = getNgModuleDef(type);\n    if (ngModuleDef) {\n      verifySemanticsOfNgModuleDef(type as any as NgModuleType, false);\n      return computeCombinedExports(type);\n    } else {\n      return type;\n    }\n  }))];\n}\n\n/**\n * Some declared components may be compiled asynchronously, and thus may not have their\n * ɵcmp set yet. If this is the case, then a reference to the module is written into\n * the `ngSelectorScope` property of the declared type.\n */\nfunction setScopeOnDeclaredComponents(moduleType: Type<any>, ngModule: NgModule) {\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n\n  const transitiveScopes = transitiveScopesFor(moduleType);\n\n  declarations.forEach(declaration => {\n    declaration = resolveForwardRef(declaration);\n    if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n      // A `ɵcmp` field exists - go ahead and patch the component directly.\n      const component = declaration as Type<any>& {ɵcmp: ComponentDef<any>};\n      const componentDef = getComponentDef(component)!;\n      patchComponentDefWithScope(componentDef, transitiveScopes);\n    } else if (\n        !declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n      // Set `ngSelectorScope` for future reference when the component compilation finishes.\n      (declaration as Type<any>& {ngSelectorScope?: any}).ngSelectorScope = moduleType;\n    }\n  });\n}\n\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nexport function patchComponentDefWithScope<C>(\n    componentDef: ComponentDef<C>, transitiveScopes: NgModuleTransitiveScopes) {\n  componentDef.directiveDefs = () =>\n      Array.from(transitiveScopes.compilation.directives)\n          .map(\n              dir => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir)! : getDirectiveDef(dir)!\n              )\n          .filter(def => !!def);\n  componentDef.pipeDefs = () =>\n      Array.from(transitiveScopes.compilation.pipes).map(pipe => getPipeDef(pipe)!);\n  componentDef.schemas = transitiveScopes.schemas;\n\n  // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n  // may face a problem where previously compiled defs available to a given Component/Directive\n  // are cached in TView and may become stale (in case any of these defs gets recompiled). In\n  // order to avoid this problem, we force fresh TView to be created.\n  componentDef.tView = null;\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\nexport function transitiveScopesFor<T>(type: Type<T>): NgModuleTransitiveScopes {\n  if (isNgModule(type)) {\n    return transitiveScopesForNgModule(type);\n  } else if (isStandalone(type)) {\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set<any>(),\n          pipes: new Set<any>(),\n        },\n        exported: {\n          directives: new Set<any>([type]),\n          pipes: new Set<any>(),\n        },\n      };\n    }\n\n    const pipeDef = getPipeDef(type);\n    if (pipeDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set<any>(),\n          pipes: new Set<any>(),\n        },\n        exported: {\n          directives: new Set<any>(),\n          pipes: new Set<any>([type]),\n        },\n      };\n    }\n  }\n\n  // TODO: change the error message to be more user-facing and take standalone into account\n  throw new Error(`${type.name} does not have a module def (ɵmod property)`);\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. This function can\n * be called on modules with components that have not fully compiled yet, but the result should not\n * be used until they have.\n *\n * @param moduleType module that transitive scope should be calculated for.\n */\nexport function transitiveScopesForNgModule<T>(moduleType: Type<T>): NgModuleTransitiveScopes {\n  const def = getNgModuleDef(moduleType, true);\n\n  if (def.transitiveCompileScopes !== null) {\n    return def.transitiveCompileScopes;\n  }\n\n  const scopes: NgModuleTransitiveScopes = {\n    schemas: def.schemas || null,\n    compilation: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n    exported: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n  };\n\n  maybeUnwrapFn(def.imports).forEach(<I>(imported: Type<I>) => {\n    // When this module imports another, the imported module's exported directives and pipes are\n    // added to the compilation scope of this module.\n    const importedScope = transitiveScopesFor(imported);\n    importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));\n    importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));\n  });\n\n  maybeUnwrapFn(def.declarations).forEach(declared => {\n    const declaredWithDefs = declared as Type<any>& {\n      ɵpipe?: any;\n    };\n\n    if (getPipeDef(declaredWithDefs)) {\n      scopes.compilation.pipes.add(declared);\n    } else {\n      // Either declared has a ɵcmp or ɵdir, or it's a component which hasn't\n      // had its template compiled yet. In either case, it gets added to the compilation's\n      // directives.\n      scopes.compilation.directives.add(declared);\n    }\n  });\n\n  maybeUnwrapFn(def.exports).forEach(<E>(exported: Type<E>) => {\n    const exportedType = exported as Type<E>& {\n      // Components, Directives, NgModules, and Pipes can all be exported.\n      ɵcmp?: any;\n      ɵdir?: any;\n      ɵmod?: NgModuleDef<E>;\n      ɵpipe?: any;\n    };\n\n    // Either the type is a module, a pipe, or a component/directive (which may not have a\n    // ɵcmp as it might be compiled asynchronously).\n    if (isNgModule(exportedType)) {\n      // When this module exports another, the exported module's exported directives and pipes are\n      // added to both the compilation and exported scopes of this module.\n      const exportedScope = transitiveScopesFor(exportedType);\n      exportedScope.exported.directives.forEach(entry => {\n        scopes.compilation.directives.add(entry);\n        scopes.exported.directives.add(entry);\n      });\n      exportedScope.exported.pipes.forEach(entry => {\n        scopes.compilation.pipes.add(entry);\n        scopes.exported.pipes.add(entry);\n      });\n    } else if (getPipeDef(exportedType)) {\n      scopes.exported.pipes.add(exportedType);\n    } else {\n      scopes.exported.directives.add(exportedType);\n    }\n  });\n\n  def.transitiveCompileScopes = scopes;\n  return scopes;\n}\n\nfunction expandModuleWithProviders(value: Type<any>|ModuleWithProviders<{}>): Type<any> {\n  if (isModuleWithProviders(value)) {\n    return value.ngModule;\n  }\n  return value;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3DirectiveMetadataFacade} from '../../compiler/compiler_facade';\nimport {R3ComponentMetadataFacade, R3QueryMetadataFacade} from '../../compiler/compiler_facade_interface';\nimport {isForwardRef, resolveForwardRef} from '../../di/forward_ref';\nimport {getReflect, reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {Query} from '../../metadata/di';\nimport {Component, Directive, Input} from '../../metadata/directives';\nimport {componentNeedsResolution, maybeQueueResolutionOfComponentResources} from '../../metadata/resource_loading';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {flatten} from '../../util/array_utils';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from '../../util/empty';\nimport {initNgDevMode} from '../../util/ng_dev_mode';\nimport {getComponentDef, getDirectiveDef, getNgModuleDef, getPipeDef} from '../definition';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF} from '../fields';\nimport {ComponentDef, ComponentType, DirectiveDefList, PipeDefList} from '../interfaces/definition';\nimport {stringifyForError} from '../util/stringify_utils';\n\nimport {angularCoreEnv} from './environment';\nimport {getJitOptions} from './jit_options';\nimport {flushModuleScopingQueueAsMuchAsPossible, patchComponentDefWithScope, transitiveScopesFor} from './module';\nimport {isModuleWithProviders} from './util';\n\n/**\n * Keep track of the compilation depth to avoid reentrancy issues during JIT compilation. This\n * matters in the following scenario:\n *\n * Consider a component 'A' that extends component 'B', both declared in module 'M'. During\n * the compilation of 'A' the definition of 'B' is requested to capture the inheritance chain,\n * potentially triggering compilation of 'B'. If this nested compilation were to trigger\n * `flushModuleScopingQueueAsMuchAsPossible` it may happen that module 'M' is still pending in the\n * queue, resulting in 'A' and 'B' to be patched with the NgModule scope. As the compilation of\n * 'A' is still in progress, this would introduce a circular dependency on its compilation. To avoid\n * this issue, the module scope queue is only flushed for compilations at the depth 0, to ensure\n * all compilations have finished.\n */\nlet compilationDepth = 0;\n\n/**\n * Compile an Angular component according to its decorator metadata, and patch the resulting\n * component def (ɵcmp) onto the component type.\n *\n * Compilation may be asynchronous (due to the need to resolve URLs for the component template or\n * other resources, for example). In the event that compilation is not immediate, `compileComponent`\n * will enqueue resource resolution into a global queue and will fail to return the `ɵcmp`\n * until the global queue has been resolved with a call to `resolveComponentResources`.\n */\nexport function compileComponent(type: Type<any>, metadata: Component): void {\n  // Initialize ngDevMode. This must be the first statement in compileComponent.\n  // See the `initNgDevMode` docstring for more information.\n  (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n\n  let ngComponentDef: ComponentDef<unknown>|null = null;\n\n  // Metadata may have resources which need to be resolved.\n  maybeQueueResolutionOfComponentResources(type, metadata);\n\n  // Note that we're using the same function as `Directive`, because that's only subset of metadata\n  // that we need to create the ngFactoryDef. We're avoiding using the component metadata\n  // because we'd have to resolve the asynchronous templates.\n  addDirectiveFactoryDef(type, metadata);\n\n  Object.defineProperty(type, NG_COMP_DEF, {\n    get: () => {\n      if (ngComponentDef === null) {\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'component', type: type});\n\n        if (componentNeedsResolution(metadata)) {\n          const error = [`Component '${type.name}' is not resolved:`];\n          if (metadata.templateUrl) {\n            error.push(` - templateUrl: ${metadata.templateUrl}`);\n          }\n          if (metadata.styleUrls && metadata.styleUrls.length) {\n            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);\n          }\n          error.push(`Did you run and wait for 'resolveComponentResources()'?`);\n          throw new Error(error.join('\\n'));\n        }\n\n        // This const was called `jitOptions` previously but had to be renamed to `options` because\n        // of a bug with Terser that caused optimized JIT builds to throw a `ReferenceError`.\n        // This bug was investigated in https://github.com/angular/angular-cli/issues/17264.\n        // We should not rename it back until https://github.com/terser/terser/issues/615 is fixed.\n        const options = getJitOptions();\n        let preserveWhitespaces = metadata.preserveWhitespaces;\n        if (preserveWhitespaces === undefined) {\n          if (options !== null && options.preserveWhitespaces !== undefined) {\n            preserveWhitespaces = options.preserveWhitespaces;\n          } else {\n            preserveWhitespaces = false;\n          }\n        }\n        let encapsulation = metadata.encapsulation;\n        if (encapsulation === undefined) {\n          if (options !== null && options.defaultEncapsulation !== undefined) {\n            encapsulation = options.defaultEncapsulation;\n          } else {\n            encapsulation = ViewEncapsulation.Emulated;\n          }\n        }\n\n        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;\n        const meta: R3ComponentMetadataFacade = {\n          ...directiveMetadata(type, metadata),\n          typeSourceSpan: compiler.createParseSourceSpan('Component', type.name, templateUrl),\n          template: metadata.template || '',\n          preserveWhitespaces,\n          styles: metadata.styles || EMPTY_ARRAY,\n          animations: metadata.animations,\n          // JIT components are always compiled against an empty set of `declarations`. Instead, the\n          // `directiveDefs` and `pipeDefs` are updated at a later point:\n          //  * for NgModule-based components, they're set when the NgModule which declares the\n          //    component resolves in the module scoping queue\n          //  * for standalone components, they're set just below, after `compileComponent`.\n          declarations: [],\n          changeDetection: metadata.changeDetection,\n          encapsulation,\n          interpolation: metadata.interpolation,\n          viewProviders: metadata.viewProviders || null,\n          isStandalone: !!metadata.standalone,\n        };\n\n        compilationDepth++;\n        try {\n          if (meta.usesInheritance) {\n            addDirectiveDefToUndecoratedParents(type);\n          }\n          ngComponentDef =\n              compiler.compileComponent(angularCoreEnv, templateUrl, meta) as ComponentDef<unknown>;\n\n          if (metadata.standalone) {\n            // Patch the component definition for standalone components with `directiveDefs` and\n            // `pipeDefs` functions which lazily compute the directives/pipes available in the\n            // standalone component. Also set `dependencies` to the lazily resolved list of imports.\n            const imports: Type<any>[] = flatten(metadata.imports || EMPTY_ARRAY);\n            const {directiveDefs, pipeDefs} = getStandaloneDefFunctions(type, imports);\n            ngComponentDef.directiveDefs = directiveDefs;\n            ngComponentDef.pipeDefs = pipeDefs;\n            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);\n          }\n        } finally {\n          // Ensure that the compilation depth is decremented even when the compilation failed.\n          compilationDepth--;\n        }\n\n        if (compilationDepth === 0) {\n          // When NgModule decorator executed, we enqueued the module definition such that\n          // it would only dequeue and add itself as module scope to all of its declarations,\n          // but only if  if all of its declarations had resolved. This call runs the check\n          // to see if any modules that are in the queue can be dequeued and add scope to\n          // their declarations.\n          flushModuleScopingQueueAsMuchAsPossible();\n        }\n\n        // If component compilation is async, then the @NgModule annotation which declares the\n        // component may execute and set an ngSelectorScope property on the component type. This\n        // allows the component to patch itself with directiveDefs from the module after it\n        // finishes compiling.\n        if (hasSelectorScope(type)) {\n          const scopes = transitiveScopesFor(type.ngSelectorScope);\n          patchComponentDefWithScope(ngComponentDef, scopes);\n        }\n\n        if (metadata.schemas) {\n          if (metadata.standalone) {\n            ngComponentDef.schemas = metadata.schemas;\n          } else {\n            throw new Error(`The 'schemas' was specified for the ${\n                stringifyForError(type)} but is only valid on a component that is standalone.`);\n          }\n        } else if (metadata.standalone) {\n          ngComponentDef.schemas = [];\n        }\n      }\n      return ngComponentDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getDependencyTypeForError(type: Type<any>) {\n  if (getComponentDef(type)) return 'component';\n  if (getDirectiveDef(type)) return 'directive';\n  if (getPipeDef(type)) return 'pipe';\n  return 'type';\n}\n\nfunction verifyStandaloneImport(depType: Type<unknown>, importingType: Type<unknown>) {\n  if (isForwardRef(depType)) {\n    depType = resolveForwardRef(depType);\n    if (!depType) {\n      throw new Error(`Expected forwardRef function, imported from \"${\n          stringifyForError(importingType)}\", to return a standalone entity or NgModule but got \"${\n          stringifyForError(depType) || depType}\".`);\n    }\n  }\n\n  if (getNgModuleDef(depType) == null) {\n    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef(depType);\n    if (def != null) {\n      // if a component, directive or pipe is imported make sure that it is standalone\n      if (!def.standalone) {\n        throw new Error(`The \"${stringifyForError(depType)}\" ${\n            getDependencyTypeForError(depType)}, imported from \"${\n            stringifyForError(\n                importingType)}\", is not standalone. Did you forget to add the standalone: true flag?`);\n      }\n    } else {\n      // it can be either a module with provider or an unknown (not annotated) type\n      if (isModuleWithProviders(depType)) {\n        throw new Error(`A module with providers was imported from \"${\n            stringifyForError(\n                importingType)}\". Modules with providers are not supported in standalone components imports.`);\n      } else {\n        throw new Error(`The \"${stringifyForError(depType)}\" type, imported from \"${\n            stringifyForError(\n                importingType)}\", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);\n      }\n    }\n  }\n}\n\n/**\n * Build memoized `directiveDefs` and `pipeDefs` functions for the component definition of a\n * standalone component, which process `imports` and filter out directives and pipes. The use of\n * memoized functions here allows for the delayed resolution of any `forwardRef`s present in the\n * component's `imports`.\n */\nfunction getStandaloneDefFunctions(type: Type<any>, imports: Type<any>[]): {\n  directiveDefs: () => DirectiveDefList,\n  pipeDefs: () => PipeDefList,\n} {\n  let cachedDirectiveDefs: DirectiveDefList|null = null;\n  let cachedPipeDefs: PipeDefList|null = null;\n  const directiveDefs = () => {\n    if (cachedDirectiveDefs === null) {\n      // Standalone components are always able to self-reference, so include the component's own\n      // definition in its `directiveDefs`.\n      cachedDirectiveDefs = [getComponentDef(type)!];\n      const seen = new Set<Type<unknown>>();\n\n      for (const rawDep of imports) {\n        ngDevMode && verifyStandaloneImport(rawDep, type);\n\n        const dep = resolveForwardRef(rawDep);\n        if (seen.has(dep)) {\n          continue;\n        }\n        seen.add(dep);\n\n        if (!!getNgModuleDef(dep)) {\n          const scope = transitiveScopesFor(dep);\n          for (const dir of scope.exported.directives) {\n            const def = getComponentDef(dir) || getDirectiveDef(dir);\n            if (def && !seen.has(dir)) {\n              seen.add(dir);\n              cachedDirectiveDefs.push(def);\n            }\n          }\n        } else {\n          const def = getComponentDef(dep) || getDirectiveDef(dep);\n          if (def) {\n            cachedDirectiveDefs.push(def);\n          }\n        }\n      }\n    }\n    return cachedDirectiveDefs;\n  };\n\n  const pipeDefs = () => {\n    if (cachedPipeDefs === null) {\n      cachedPipeDefs = [];\n      const seen = new Set<Type<unknown>>();\n\n      for (const rawDep of imports) {\n        const dep = resolveForwardRef(rawDep);\n        if (seen.has(dep)) {\n          continue;\n        }\n        seen.add(dep);\n\n        if (!!getNgModuleDef(dep)) {\n          const scope = transitiveScopesFor(dep);\n          for (const pipe of scope.exported.pipes) {\n            const def = getPipeDef(pipe);\n            if (def && !seen.has(pipe)) {\n              seen.add(pipe);\n              cachedPipeDefs.push(def);\n            }\n          }\n        } else {\n          const def = getPipeDef(dep);\n          if (def) {\n            cachedPipeDefs.push(def);\n          }\n        }\n      }\n    }\n    return cachedPipeDefs;\n  };\n\n  return {\n    directiveDefs,\n    pipeDefs,\n  };\n}\n\nfunction hasSelectorScope<T>(component: Type<T>): component is Type<T>&\n    {ngSelectorScope: Type<any>} {\n  return (component as {ngSelectorScope?: any}).ngSelectorScope !== undefined;\n}\n\n/**\n * Compile an Angular directive according to its decorator metadata, and patch the resulting\n * directive def onto the component type.\n *\n * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which\n * will resolve when compilation completes and the directive becomes usable.\n */\nexport function compileDirective(type: Type<any>, directive: Directive|null): void {\n  let ngDirectiveDef: any = null;\n\n  addDirectiveFactoryDef(type, directive || {});\n\n  Object.defineProperty(type, NG_DIR_DEF, {\n    get: () => {\n      if (ngDirectiveDef === null) {\n        // `directive` can be null in the case of abstract directives as a base class\n        // that use `@Directive()` with no selector. In that case, pass empty object to the\n        // `directiveMetadata` function instead of null.\n        const meta = getDirectiveMetadata(type, directive || {});\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n        ngDirectiveDef =\n            compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);\n      }\n      return ngDirectiveDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getDirectiveMetadata(type: Type<any>, metadata: Directive) {\n  const name = type && type.name;\n  const sourceMapUrl = `ng:///${name}/ɵdir.js`;\n  const compiler = getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n  const facade = directiveMetadata(type as ComponentType<any>, metadata);\n  facade.typeSourceSpan = compiler.createParseSourceSpan('Directive', name, sourceMapUrl);\n  if (facade.usesInheritance) {\n    addDirectiveDefToUndecoratedParents(type);\n  }\n  return {metadata: facade, sourceMapUrl};\n}\n\nfunction addDirectiveFactoryDef(type: Type<any>, metadata: Directive|Component) {\n  let ngFactoryDef: any = null;\n\n  Object.defineProperty(type, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const meta = getDirectiveMetadata(type, metadata);\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/ɵfac.js`, {\n          name: meta.metadata.name,\n          type: meta.metadata.type,\n          typeArgumentCount: 0,\n          deps: reflectDependencies(type),\n          target: compiler.FactoryTarget.Directive\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nexport function extendsDirectlyFromObject(type: Type<any>): boolean {\n  return Object.getPrototypeOf(type.prototype) === Object.prototype;\n}\n\n/**\n * Extract the `R3DirectiveMetadata` for a particular directive (either a `Directive` or a\n * `Component`).\n */\nexport function directiveMetadata(type: Type<any>, metadata: Directive): R3DirectiveMetadataFacade {\n  // Reflect inputs and outputs.\n  const reflect = getReflect();\n  const propMetadata = reflect.ownPropMetadata(type);\n\n  return {\n    name: type.name,\n    type: type,\n    selector: metadata.selector !== undefined ? metadata.selector : null,\n    host: metadata.host || EMPTY_OBJ,\n    propMetadata: propMetadata,\n    inputs: metadata.inputs || EMPTY_ARRAY,\n    outputs: metadata.outputs || EMPTY_ARRAY,\n    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),\n    lifecycle: {usesOnChanges: reflect.hasLifecycleHook(type, 'ngOnChanges')},\n    typeSourceSpan: null!,\n    usesInheritance: !extendsDirectlyFromObject(type),\n    exportAs: extractExportAs(metadata.exportAs),\n    providers: metadata.providers || null,\n    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),\n    isStandalone: !!metadata.standalone,\n  };\n}\n\n/**\n * Adds a directive definition to all parent classes of a type that don't have an Angular decorator.\n */\nfunction addDirectiveDefToUndecoratedParents(type: Type<any>) {\n  const objPrototype = Object.prototype;\n  let parent = Object.getPrototypeOf(type.prototype).constructor;\n\n  // Go up the prototype until we hit `Object`.\n  while (parent && parent !== objPrototype) {\n    // Since inheritance works if the class was annotated already, we only need to add\n    // the def if there are no annotations and the def hasn't been created already.\n    if (!getDirectiveDef(parent) && !getComponentDef(parent) &&\n        shouldAddAbstractDirective(parent)) {\n      compileDirective(parent, null);\n    }\n    parent = Object.getPrototypeOf(parent);\n  }\n}\n\nfunction convertToR3QueryPredicate(selector: any): any|string[] {\n  return typeof selector === 'string' ? splitByComma(selector) : resolveForwardRef(selector);\n}\n\nexport function convertToR3QueryMetadata(propertyName: string, ann: Query): R3QueryMetadataFacade {\n  return {\n    propertyName: propertyName,\n    predicate: convertToR3QueryPredicate(ann.selector),\n    descendants: ann.descendants,\n    first: ann.first,\n    read: ann.read ? ann.read : null,\n    static: !!ann.static,\n    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,\n  };\n}\nfunction extractQueriesMetadata(\n    type: Type<any>, propMetadata: {[key: string]: any[]},\n    isQueryAnn: (ann: any) => ann is Query): R3QueryMetadataFacade[] {\n  const queriesMeta: R3QueryMetadataFacade[] = [];\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      const annotations = propMetadata[field];\n      annotations.forEach(ann => {\n        if (isQueryAnn(ann)) {\n          if (!ann.selector) {\n            throw new Error(\n                `Can't construct a query for the property \"${field}\" of ` +\n                `\"${stringifyForError(type)}\" since the query selector wasn't defined.`);\n          }\n          if (annotations.some(isInputAnnotation)) {\n            throw new Error(`Cannot combine @Input decorators with query decorators`);\n          }\n          queriesMeta.push(convertToR3QueryMetadata(field, ann));\n        }\n      });\n    }\n  }\n  return queriesMeta;\n}\n\nfunction extractExportAs(exportAs: string|undefined): string[]|null {\n  return exportAs === undefined ? null : splitByComma(exportAs);\n}\n\nfunction isContentQuery(value: any): value is Query {\n  const name = value.ngMetadataName;\n  return name === 'ContentChild' || name === 'ContentChildren';\n}\n\nfunction isViewQuery(value: any): value is Query {\n  const name = value.ngMetadataName;\n  return name === 'ViewChild' || name === 'ViewChildren';\n}\n\nfunction isInputAnnotation(value: any): value is Input {\n  return value.ngMetadataName === 'Input';\n}\n\nfunction splitByComma(value: string): string[] {\n  return value.split(',').map(piece => piece.trim());\n}\n\nconst LIFECYCLE_HOOKS = [\n  'ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked',\n  'ngAfterContentInit', 'ngAfterContentChecked'\n];\n\nfunction shouldAddAbstractDirective(type: Type<any>): boolean {\n  const reflect = getReflect();\n\n  if (LIFECYCLE_HOOKS.some(hookName => reflect.hasLifecycleHook(type, hookName))) {\n    return true;\n  }\n\n  const propMetadata = reflect.propMetadata(type);\n\n  for (const field in propMetadata) {\n    const annotations = propMetadata[field];\n\n    for (let i = 0; i < annotations.length; i++) {\n      const current = annotations[i];\n      const metadataName = current.ngMetadataName;\n\n      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) ||\n          metadataName === 'Output' || metadataName === 'HostBinding' ||\n          metadataName === 'HostListener') {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3PipeMetadataFacade} from '../../compiler/compiler_facade';\nimport {reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {Pipe} from '../../metadata/directives';\nimport {NG_FACTORY_DEF, NG_PIPE_DEF} from '../fields';\n\nimport {angularCoreEnv} from './environment';\n\nexport function compilePipe(type: Type<any>, meta: Pipe): void {\n  let ngPipeDef: any = null;\n  let ngFactoryDef: any = null;\n\n  Object.defineProperty(type, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const metadata = getPipeMetadata(type, meta);\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'pipe', type: metadata.type});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/ɵfac.js`, {\n          name: metadata.name,\n          type: metadata.type,\n          typeArgumentCount: 0,\n          deps: reflectDependencies(type),\n          target: compiler.FactoryTarget.Pipe\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n\n  Object.defineProperty(type, NG_PIPE_DEF, {\n    get: () => {\n      if (ngPipeDef === null) {\n        const metadata = getPipeMetadata(type, meta);\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'pipe', type: metadata.type});\n        ngPipeDef =\n            compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/ɵpipe.js`, metadata);\n      }\n      return ngPipeDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getPipeMetadata(type: Type<any>, meta: Pipe): R3PipeMetadataFacade {\n  return {\n    type: type,\n    name: type.name,\n    pipeName: meta.name,\n    pure: meta.pure !== undefined ? meta.pure : true,\n    isStandalone: !!meta.standalone,\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {Provider} from '../di/interface/provider';\nimport {Type} from '../interface/type';\nimport {compileComponent, compileDirective} from '../render3/jit/directive';\nimport {compilePipe} from '../render3/jit/pipe';\nimport {makeDecorator, makePropDecorator, TypeDecorator} from '../util/decorators';\n\nimport {SchemaMetadata} from './schema';\nimport {ViewEncapsulation} from './view';\n\n\n\n/**\n * Type of the Directive decorator / constructor function.\n * @publicApi\n */\nexport interface DirectiveDecorator {\n  /**\n   * Decorator that marks a class as an Angular directive.\n   * You can define your own directives to attach custom behavior to elements in the DOM.\n   *\n   * The options provide configuration metadata that determines\n   * how the directive should be processed, instantiated and used at\n   * runtime.\n   *\n   * Directive classes, like component classes, can implement\n   * [life-cycle hooks](guide/lifecycle-hooks) to influence their configuration and behavior.\n   *\n   *\n   * @usageNotes\n   * To define a directive, mark the class with the decorator and provide metadata.\n   *\n   * ```ts\n   * import {Directive} from '@angular/core';\n   *\n   * @Directive({\n   *   selector: 'my-directive',\n   * })\n   * export class MyDirective {\n   * ...\n   * }\n   * ```\n   *\n   * ### Declaring directives\n   *\n   * In order to make a directive available to other components in your application, you should do\n   * one of the following:\n   *  - either mark the directive as [standalone](guide/standalone-components),\n   *  - or declare it in an NgModule by adding it to the `declarations` and `exports` fields.\n   *\n   * ** Marking a directive as standalone **\n   *\n   * You can add the `standalone: true` flag to the Directive decorator metadata to declare it as\n   * [standalone](guide/standalone-components):\n   *\n   * ```ts\n   * @Directive({\n   *   standalone: true,\n   *   selector: 'my-directive',\n   * })\n   * class MyDirective {}\n   * ```\n   *\n   * When marking a directive as standalone, please make sure that the directive is not already\n   * declared in an NgModule.\n   *\n   *\n   * ** Declaring a directive in an NgModule **\n   *\n   * Another approach is to declare a directive in an NgModule:\n   *\n   * ```ts\n   * @Directive({\n   *   selector: 'my-directive',\n   * })\n   * class MyDirective {}\n   *\n   * @NgModule({\n   *   declarations: [MyDirective, SomeComponent],\n   *   exports: [MyDirective], // making it available outside of this module\n   * })\n   * class SomeNgModule {}\n   * ```\n   *\n   * When declaring a directive in an NgModule, please make sure that:\n   *  - the directive is declared in exactly one NgModule.\n   *  - the directive is not standalone.\n   *  - you do not re-declare a directive imported from another module.\n   *  - the directive is included into the `exports` field as well if you want this directive to be\n   *    accessible for components outside of the NgModule.\n   *\n   *\n   * @Annotation\n   */\n  (obj?: Directive): TypeDecorator;\n\n  /**\n   * See the `Directive` decorator.\n   */\n  new(obj?: Directive): Directive;\n}\n\n/**\n * Directive decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport interface Directive {\n  /**\n   * The CSS selector that identifies this directive in a template\n   * and triggers instantiation of the directive.\n   *\n   * Declare as one of the following:\n   *\n   * - `element-name`: Select by element name.\n   * - `.class`: Select by class name.\n   * - `[attribute]`: Select by attribute name.\n   * - `[attribute=value]`: Select by attribute name and value.\n   * - `:not(sub_selector)`: Select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: Select if either `selector1` or `selector2` matches.\n   *\n   * Angular only allows directives to apply on CSS selectors that do not cross\n   * element boundaries.\n   *\n   * For the following template HTML, a directive with an `input[type=text]` selector,\n   * would be instantiated only on the `<input type=\"text\">` element.\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   */\n  selector?: string;\n\n  /**\n   * Enumerates the set of data-bound input properties for a directive\n   *\n   * Angular automatically updates input properties during change detection.\n   * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property where the value is written.\n   * - `bindingProperty` specifies the DOM property where the value is read from.\n   *\n   * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.\n   *\n   * @usageNotes\n   *\n   * The following example creates a component with two data-bound properties.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   inputs: ['bankName', 'id: account-id'],\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   bankName: string;\n   *   id: string;\n   * }\n   * ```\n   *\n   */\n  inputs?: string[];\n\n  /**\n   * Enumerates the set of event-bound output properties.\n   *\n   * When an output property emits an event, an event handler attached to that event\n   * in the template is invoked.\n   *\n   * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property that emits events.\n   * - `bindingProperty` specifies the DOM property the event handler is attached to.\n   *\n   * @usageNotes\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'child-dir',\n   *   outputs: [ 'bankNameChange' ]\n   *   template: `<input (input)=\"bankNameChange.emit($event.target.value)\" />`\n   * })\n   * class ChildDir {\n   *  bankNameChange: EventEmitter<string> = new EventEmitter<string>();\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `\n   *     {{ bankName }} <child-dir (bankNameChange)=\"onBankNameChange($event)\"></child-dir>\n   *   `\n   * })\n   * class MainComponent {\n   *  bankName: string;\n   *\n   *   onBankNameChange(bankName: string) {\n   *     this.bankName = bankName;\n   *   }\n   * }\n   * ```\n   *\n   */\n  outputs?: string[];\n\n  /**\n   * Configures the [injector](guide/glossary#injector) of this\n   * directive or component with a [token](guide/glossary#di-token)\n   * that maps to a [provider](guide/glossary#provider) of a dependency.\n   */\n  providers?: Provider[];\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * @usageNotes\n   *\n   * ```ts\n   * @Directive({\n   *   selector: 'child-dir',\n   *   exportAs: 'child'\n   * })\n   * class ChildDir {\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `<child-dir #c=\"child\"></child-dir>`\n   * })\n   * class MainComponent {\n   * }\n   * ```\n   *\n   */\n  exportAs?: string;\n\n  /**\n   * Configures the queries that will be injected into the directive.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * @usageNotes\n   *\n   * The following example shows how queries are defined\n   * and when their results are available in lifecycle hooks:\n   *\n   * ```ts\n   * @Component({\n   *   selector: 'someDir',\n   *   queries: {\n   *     contentChildren: new ContentChildren(ChildDirective),\n   *     viewChildren: new ViewChildren(ChildDirective)\n   *   },\n   *   template: '<child-directive></child-directive>'\n   * })\n   * class SomeDir {\n   *   contentChildren: QueryList<ChildDirective>,\n   *   viewChildren: QueryList<ChildDirective>\n   *\n   *   ngAfterContentInit() {\n   *     // contentChildren is set\n   *   }\n   *\n   *   ngAfterViewInit() {\n   *     // viewChildren is set\n   *   }\n   * }\n   * ```\n   *\n   * @Annotation\n   */\n  queries?: {[key: string]: any};\n\n  /**\n   * Maps class properties to host element bindings for properties,\n   * attributes, and events, using a set of key-value pairs.\n   *\n   * Angular automatically checks host property bindings during change detection.\n   * If a binding changes, Angular updates the directive's host element.\n   *\n   * When the key is a property of the host element, the property value is\n   * the propagated to the specified DOM property.\n   *\n   * When the key is a static attribute in the DOM, the attribute value\n   * is propagated to the specified property in the host element.\n   *\n   * For event handling:\n   * - The key is the DOM event that the directive listens to.\n   * To listen to global events, add the target to the event name.\n   * The target can be `window`, `document` or `body`.\n   * - The value is the statement to execute when the event occurs. If the\n   * statement evaluates to `false`, then `preventDefault` is applied on the DOM\n   * event. A handler method can refer to the `$event` local variable.\n   *\n   */\n  host?: {[key: string]: string};\n\n  /**\n   * When present, this directive/component is ignored by the AOT compiler.\n   * It remains in distributed code, and the JIT compiler attempts to compile it\n   * at run time, in the browser.\n   * To ensure the correct behavior, the app must import `@angular/compiler`.\n   */\n  jit?: true;\n\n  /**\n   * Angular directives marked as `standalone` do not need to be declared in an NgModule. Such\n   * directives don't depend on any \"intermediate context\" of an NgModule (ex. configured\n   * providers).\n   *\n   * More information about standalone components, directives and pipes can be found in [this\n   * guide](guide/standalone-components).\n   *\n   * @developerPreview\n   */\n  standalone?: boolean;\n}\n\n/**\n * Type of the Directive metadata.\n *\n * @publicApi\n */\nexport const Directive: DirectiveDecorator = makeDecorator(\n    'Directive', (dir: Directive = {}) => dir, undefined, undefined,\n    (type: Type<any>, meta: Directive) => compileDirective(type, meta));\n\n/**\n * Component decorator interface\n *\n * @publicApi\n */\nexport interface ComponentDecorator {\n  /**\n   * Decorator that marks a class as an Angular component and provides configuration\n   * metadata that determines how the component should be processed,\n   * instantiated, and used at runtime.\n   *\n   * Components are the most basic UI building block of an Angular app.\n   * An Angular app contains a tree of Angular components.\n   *\n   * Angular components are a subset of directives, always associated with a template.\n   * Unlike other directives, only one component can be instantiated for a given element in a\n   * template.\n   *\n   * A component must belong to an NgModule in order for it to be available\n   * to another component or application. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `NgModule` metadata.\n   *\n   * Note that, in addition to these options for configuring a directive,\n   * you can control a component's runtime behavior by implementing\n   * life-cycle hooks. For more information, see the\n   * [Lifecycle Hooks](guide/lifecycle-hooks) guide.\n   *\n   * @usageNotes\n   *\n   * ### Setting component inputs\n   *\n   * The following example creates a component with two data-bound properties,\n   * specified by the `inputs` value.\n   *\n   * <code-example path=\"core/ts/metadata/directives.ts\" region=\"component-input\"></code-example>\n   *\n   *\n   * ### Setting component outputs\n   *\n   * The following example shows two event emitters that emit on an interval. One\n   * emits an output every second, while the other emits every five seconds.\n   *\n   * {@example core/ts/metadata/directives.ts region='component-output-interval'}\n   *\n   * ### Injecting a class with a view provider\n   *\n   * The following simple example injects a class into a component\n   * using the view provider specified in component metadata:\n   *\n   * ```ts\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Directive({\n   *   selector: 'needs-greeter'\n   * })\n   * class NeedsGreeter {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'greet',\n   *   viewProviders: [\n   *     Greeter\n   *   ],\n   *   template: `<needs-greeter></needs-greeter>`\n   * })\n   * class HelloWorld {\n   * }\n   *\n   * ```\n   *\n   * ### Preserving whitespace\n   *\n   * Removing whitespace can greatly reduce AOT-generated code size and speed up view creation.\n   * As of Angular 6, the default for `preserveWhitespaces` is false (whitespace is removed).\n   * To change the default setting for all components in your application, set\n   * the `preserveWhitespaces` option of the AOT compiler.\n   *\n   * By default, the AOT compiler removes whitespace characters as follows:\n   * * Trims all whitespaces at the beginning and the end of a template.\n   * * Removes whitespace-only text nodes. For example,\n   *\n   * ```html\n   * <button>Action 1</button>  <button>Action 2</button>\n   * ```\n   *\n   * becomes:\n   *\n   * ```html\n   * <button>Action 1</button><button>Action 2</button>\n   * ```\n   *\n   * * Replaces a series of whitespace characters in text nodes with a single space.\n   * For example, `<span>\\n some text\\n</span>` becomes `<span> some text </span>`.\n   * * Does NOT alter text nodes inside HTML tags such as `<pre>` or `<textarea>`,\n   * where whitespace characters are significant.\n   *\n   * Note that these transformations can influence DOM nodes layout, although impact\n   * should be minimal.\n   *\n   * You can override the default behavior to preserve whitespace characters\n   * in certain fragments of a template. For example, you can exclude an entire\n   * DOM sub-tree by using the `ngPreserveWhitespaces` attribute:\n   *\n   * ```html\n   * <div ngPreserveWhitespaces>\n   *     whitespaces are preserved here\n   *     <span>    and here </span>\n   * </div>\n   * ```\n   *\n   * You can force a single space to be preserved in a text node by using `&ngsp;`,\n   * which is replaced with a space character by Angular's template\n   * compiler:\n   *\n   * ```html\n   * <a>Spaces</a>&ngsp;<a>between</a>&ngsp;<a>links.</a>\n   * <!-- compiled to be equivalent to:\n   *  <a>Spaces</a> <a>between</a> <a>links.</a>  -->\n   * ```\n   *\n   * Note that sequences of `&ngsp;` are still collapsed to just one space character when\n   * the `preserveWhitespaces` option is set to `false`.\n   *\n   * ```html\n   * <a>before</a>&ngsp;&ngsp;&ngsp;<a>after</a>\n   * <!-- compiled to be equivalent to:\n   *  <a>before</a> <a>after</a> -->\n   * ```\n   *\n   * To preserve sequences of whitespace characters, use the\n   * `ngPreserveWhitespaces` attribute.\n   *\n   * @Annotation\n   */\n  (obj: Component): TypeDecorator;\n  /**\n   * See the `Component` decorator.\n   */\n  new(obj: Component): Component;\n}\n\n/**\n * Supplies configuration metadata for an Angular component.\n *\n * @publicApi\n */\nexport interface Component extends Directive {\n  /**\n   * The change-detection strategy to use for this component.\n   *\n   * When a component is instantiated, Angular creates a change detector,\n   * which is responsible for propagating the component's bindings.\n   * The strategy is one of:\n   * - `ChangeDetectionStrategy#OnPush` sets the strategy to `CheckOnce` (on demand).\n   * - `ChangeDetectionStrategy#Default` sets the strategy to `CheckAlways`.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Defines the set of injectable objects that are visible to its view DOM children.\n   * See [example](#injecting-a-class-with-a-view-provider).\n   *\n   */\n  viewProviders?: Provider[];\n\n  /**\n   * The module ID of the module that contains the component.\n   * The component must be able to resolve relative URLs for templates and styles.\n   * SystemJS exposes the `__moduleName` variable within each module.\n   * In CommonJS, this can  be set to `module.id`.\n   *\n   */\n  moduleId?: string;\n\n  /**\n   * The relative path or absolute URL of a template file for an Angular component.\n   * If provided, do not supply an inline template using `template`.\n   *\n   */\n  templateUrl?: string;\n\n  /**\n   * An inline template for an Angular component. If provided,\n   * do not supply a template file using `templateUrl`.\n   *\n   */\n  template?: string;\n\n  /**\n   * One or more relative paths or absolute URLs for files containing CSS stylesheets to use\n   * in this component.\n   */\n  styleUrls?: string[];\n\n  /**\n   * One or more inline CSS stylesheets to use\n   * in this component.\n   */\n  styles?: string[];\n\n  /**\n   * One or more animation `trigger()` calls, containing\n   * [`state()`](api/animations/state) and `transition()` definitions.\n   * See the [Animations guide](/guide/animations) and animations API documentation.\n   *\n   */\n  animations?: any[];\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Possible values:\n   * - `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate\n   *                                 a native Shadow DOM CSS encapsulation behavior.\n   * - `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n   * - `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n   *\n   * If not supplied, the value is taken from the `CompilerOptions`\n   * which defaults to `ViewEncapsulation.Emulated`.\n   *\n   * If the policy is `ViewEncapsulation.Emulated` and the component has no\n   * {@link Component#styles styles} nor {@link Component#styleUrls styleUrls},\n   * the policy is automatically switched to `ViewEncapsulation.None`.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Overrides the default interpolation start and end delimiters (`{{` and `}}`).\n   */\n  interpolation?: [string, string];\n\n  /**\n   * A set of components that should be compiled along with\n   * this component. For each component listed here,\n   * Angular creates a {@link ComponentFactory} and stores it in the\n   * {@link ComponentFactoryResolver}.\n   * @deprecated Since 9.0.0. With Ivy, this property is no longer necessary.\n   */\n  entryComponents?: Array<Type<any>|any[]>;\n\n  /**\n   * True to preserve or false to remove potentially superfluous whitespace characters\n   * from the compiled template. Whitespace characters are those matching the `\\s`\n   * character class in JavaScript regular expressions. Default is false, unless\n   * overridden in compiler options.\n   */\n  preserveWhitespaces?: boolean;\n\n  /**\n   * Angular components marked as `standalone` do not need to be declared in an NgModule. Such\n   * components directly manage their own template dependencies (components, directives and pipes\n   * used in a template) via the imports property.\n   *\n   * More information about standalone components, directives and pipes can be found in [this\n   * guide](guide/standalone-components).\n   *\n   * @developerPreview\n   */\n  standalone?: boolean;\n\n  /**\n   * The imports property specifies the standalone component's template dependencies — those\n   * directives, components, and pipes that can be used within its template. Standalone components\n   * can import other standalone components, directives and pipes as well as existing NgModules.\n   *\n   * This property is only available for standalone components - specifying it for components\n   * declared in an NgModule generates a compilation error.\n   *\n   * More information about standalone components, directives and pipes can be found in [this\n   * guide](guide/standalone-components).\n   *\n   * @developerPreview\n   */\n  imports?: (Type<any>|any[])[];\n\n  /**\n   * The set of schemas that declare elements to be allowed in a standalone component. Elements and\n   * properties that are neither Angular components nor directives must be declared in a schema.\n   *\n   * This property is only available for standalone components - specifying it for components\n   * declared in an NgModule generates a compilation error.\n   *\n   * More information about standalone components, directives and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  schemas?: SchemaMetadata[];\n}\n\n/**\n * Component decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Component: ComponentDecorator = makeDecorator(\n    'Component', (c: Component = {}) => ({changeDetection: ChangeDetectionStrategy.Default, ...c}),\n    Directive, undefined, (type: Type<any>, meta: Component) => compileComponent(type, meta));\n\n/**\n * Type of the Pipe decorator / constructor function.\n *\n * @publicApi\n */\nexport interface PipeDecorator {\n  /**\n   *\n   * Decorator that marks a class as pipe and supplies configuration metadata.\n   *\n   * A pipe class must implement the `PipeTransform` interface.\n   * For example, if the name is \"myPipe\", use a template binding expression\n   * such as the following:\n   *\n   * ```\n   * {{ exp | myPipe }}\n   * ```\n   *\n   * The result of the expression is passed to the pipe's `transform()` method.\n   *\n   * A pipe must belong to an NgModule in order for it to be available\n   * to a template. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `NgModule` metadata.\n   *\n   * @see [Style Guide: Pipe Names](guide/styleguide#02-09)\n   *\n   */\n  (obj: Pipe): TypeDecorator;\n\n  /**\n   * See the `Pipe` decorator.\n   */\n  new(obj: Pipe): Pipe;\n}\n\n/**\n * Type of the Pipe metadata.\n *\n * @publicApi\n */\nexport interface Pipe {\n  /**\n   * The pipe name to use in template bindings.\n   * Typically uses [lowerCamelCase](guide/glossary#case-types)\n   * because the name cannot contain hyphens.\n   */\n  name: string;\n\n  /**\n   * When true, the pipe is pure, meaning that the\n   * `transform()` method is invoked only when its input arguments\n   * change. Pipes are pure by default.\n   *\n   * If the pipe has internal state (that is, the result\n   * depends on state other than its arguments), set `pure` to false.\n   * In this case, the pipe is invoked on each change-detection cycle,\n   * even if the arguments have not changed.\n   */\n  pure?: boolean;\n\n  /**\n   * Angular pipes marked as `standalone` do not need to be declared in an NgModule. Such\n   * pipes don't depend on any \"intermediate context\" of an NgModule (ex. configured providers).\n   *\n   * More information about standalone components, directives and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  standalone?: boolean;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Pipe: PipeDecorator = makeDecorator(\n    'Pipe', (p: Pipe) => ({pure: true, ...p}), undefined, undefined,\n    (type: Type<any>, meta: Pipe) => compilePipe(type, meta));\n\n\n/**\n * @publicApi\n */\nexport interface InputDecorator {\n  /**\n   * Decorator that marks a class field as an input property and supplies configuration metadata.\n   * The input property is bound to a DOM property in the template. During change detection,\n   * Angular automatically updates the data property with the DOM property's value.\n   *\n   * @usageNotes\n   *\n   * You can supply an optional name to use in templates when the\n   * component is instantiated, that maps to the\n   * name of the bound property. By default, the original\n   * name of the bound property is used for input binding.\n   *\n   * The following example creates a component with two input properties,\n   * one of which is given a special binding name.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   // This property is bound using its original name.\n   *   @Input() bankName: string;\n   *   // this property value is bound to a different property name\n   *   // when this component is instantiated in a template.\n   *   @Input('account-id') id: string;\n   *\n   *   // this property is not bound, and is not automatically updated by Angular\n   *   normalizedBankName: string;\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `\n   *     <bank-account bankName=\"RBC\" account-id=\"4747\"></bank-account>\n   *   `\n   * })\n   * class App {}\n   * ```\n   *\n   * @see [Input and Output properties](guide/inputs-outputs)\n   */\n  (bindingPropertyName?: string): any;\n  new(bindingPropertyName?: string): any;\n}\n\n/**\n * Type of metadata for an `Input` property.\n *\n * @publicApi\n */\nexport interface Input {\n  /**\n   * The name of the DOM property to which the input property is bound.\n   */\n  bindingPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Input: InputDecorator =\n    makePropDecorator('Input', (bindingPropertyName?: string) => ({bindingPropertyName}));\n\n/**\n * Type of the Output decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OutputDecorator {\n  /**\n   * Decorator that marks a class field as an output property and supplies configuration metadata.\n   * The DOM property bound to the output property is automatically updated during change detection.\n   *\n   * @usageNotes\n   *\n   * You can supply an optional name to use in templates when the\n   * component is instantiated, that maps to the\n   * name of the bound property. By default, the original\n   * name of the bound property is used for output binding.\n   *\n   * See `Input` decorator for an example of providing a binding name.\n   *\n   * @see [Input and Output properties](guide/inputs-outputs)\n   *\n   */\n  (bindingPropertyName?: string): any;\n  new(bindingPropertyName?: string): any;\n}\n\n/**\n * Type of the Output metadata.\n *\n * @publicApi\n */\nexport interface Output {\n  /**\n   * The name of the DOM property to which the output property is bound.\n   */\n  bindingPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Output: OutputDecorator =\n    makePropDecorator('Output', (bindingPropertyName?: string) => ({bindingPropertyName}));\n\n\n\n/**\n * Type of the HostBinding decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostBindingDecorator {\n  /**\n   * Decorator that marks a DOM property as a host-binding property and supplies configuration\n   * metadata.\n   * Angular automatically checks host property bindings during change detection, and\n   * if a binding changes it updates the host element of the directive.\n   *\n   * @usageNotes\n   *\n   * The following example creates a directive that sets the `valid` and `invalid`\n   * properties on the DOM element that has an `ngModel` directive on it.\n   *\n   * ```typescript\n   * @Directive({selector: '[ngModel]'})\n   * class NgModelStatus {\n   *   constructor(public control: NgModel) {}\n   *   @HostBinding('class.valid') get valid() { return this.control.valid; }\n   *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `<input [(ngModel)]=\"prop\">`,\n   * })\n   * class App {\n   *   prop;\n   * }\n   * ```\n   *\n   */\n  (hostPropertyName?: string): any;\n  new(hostPropertyName?: string): any;\n}\n\n/**\n * Type of the HostBinding metadata.\n *\n * @publicApi\n */\nexport interface HostBinding {\n  /**\n   * The DOM property that is bound to a data property.\n   */\n  hostPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const HostBinding: HostBindingDecorator =\n    makePropDecorator('HostBinding', (hostPropertyName?: string) => ({hostPropertyName}));\n\n\n/**\n * Type of the HostListener decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostListenerDecorator {\n  /**\n   * Decorator that declares a DOM event to listen for,\n   * and provides a handler method to run when that event occurs.\n   *\n   * Angular invokes the supplied handler method when the host element emits the specified event,\n   * and updates the bound element with the result.\n   *\n   * If the handler method returns false, applies `preventDefault` on the bound element.\n   */\n  (eventName: string, args?: string[]): any;\n  new(eventName: string, args?: string[]): any;\n}\n\n/**\n * Type of the HostListener metadata.\n *\n * @publicApi\n */\nexport interface HostListener {\n  /**\n   * The DOM event to listen for.\n   */\n  eventName?: string;\n  /**\n   * A set of arguments to pass to the handler method when the event occurs.\n   */\n  args?: string[];\n}\n\n/**\n * Decorator that binds a DOM event to a host listener and supplies configuration metadata.\n * Angular invokes the supplied handler method when the host element emits the specified event,\n * and updates the bound element with the result.\n *\n * If the handler method returns false, applies `preventDefault` on the bound element.\n *\n * @usageNotes\n *\n * The following example declares a directive\n * that attaches a click listener to a button and counts clicks.\n *\n * ```ts\n * @Directive({selector: 'button[counting]'})\n * class CountClicks {\n *   numberOfClicks = 0;\n *\n *   @HostListener('click', ['$event.target'])\n *   onClick(btn) {\n *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\n *   }\n * }\n *\n * @Component({\n *   selector: 'app',\n *   template: '<button counting>Increment</button>',\n * })\n * class App {}\n *\n * ```\n *\n * The following example registers another DOM event handler that listens for `Enter` key-press\n * events on the global `window`.\n * ``` ts\n * import { HostListener, Component } from \"@angular/core\";\n *\n * @Component({\n *   selector: 'app',\n *   template: `<h1>Hello, you have pressed enter {{counter}} number of times!</h1> Press enter key\n * to increment the counter.\n *   <button (click)=\"resetCounter()\">Reset Counter</button>`\n * })\n * class AppComponent {\n *   counter = 0;\n *   @HostListener('window:keydown.enter', ['$event'])\n *   handleKeyDown(event: KeyboardEvent) {\n *     this.counter++;\n *   }\n *   resetCounter() {\n *     this.counter = 0;\n *   }\n * }\n * ```\n * The list of valid key names for `keydown` and `keyup` events\n * can be found here:\n * https://www.w3.org/TR/DOM-Level-3-Events-key/#named-key-attribute-values\n *\n * Note that keys can also be combined, e.g. `@HostListener('keydown.shift.a')`.\n *\n * The global target names that can be used to prefix an event name are\n * `document:`, `window:` and `body:`.\n *\n * @Annotation\n * @publicApi\n */\nexport const HostListener: HostListenerDecorator =\n    makePropDecorator('HostListener', (eventName?: string, args?: string[]) => ({eventName, args}));\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * Transform data relations metadata loader\n */\nexport const TransformDataRelationsMetadataLoader = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* () {\n    return new (yield import('./metadata/transformData.relationsMetadata')).TransformDataRelationsEditorMetadata();\n  });\n\n  return function TransformDataRelationsMetadataLoader() {\n    return _ref.apply(this, arguments);\n  };\n}();","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { __decorate, __metadata } from \"tslib\";\nimport { Injector, Input } from '@angular/core';\nimport { CodeExecutor, DynamicOutput, PureRelationsComponent } from '@anglr/dynamic/relations';\nimport { RelationsEditorMetadata } from '@anglr/dynamic/relations-editor';\nimport { nameof } from '@jscrpt/common';\nimport { TransformDataRelationsMetadataLoader } from './transformData.metadata';\n/**\n * Transform data relations component\n */\n\nlet TransformDataRelations = class TransformDataRelations {\n  //######################### constructor #########################\n  constructor(injector) {\n    this.injector = injector;\n    /**\n     * Code executor used for execution o\n     */\n\n    this.codeExecutor = this.injector.get(CodeExecutor);\n  } //######################### public properties - implementation of RelationsComponent #########################\n\n  /**\n   * @inheritdoc\n   */\n\n\n  get relationsOptions() {\n    return this.ɵRelationsOptions;\n  }\n\n  set relationsOptions(value) {\n    this.ɵRelationsOptions = value;\n  } //######################### public methods - implementation of OnChanges #########################\n\n  /**\n   * Called when input value changes\n   */\n\n\n  ngOnChanges(changes) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (nameof('data') in changes) {\n        if (!_this.relationsOptions) {\n          return;\n        }\n\n        const transformer = yield _this.codeExecutor.loadData(_this.relationsOptions.id, _this.relationsOptions.code);\n\n        if (!transformer) {\n          return;\n        }\n\n        try {\n          _this.transformedData = transformer(_this.data);\n        } catch (e) {\n          console.error(e);\n        }\n      }\n    })();\n  } //######################### public properties - dynamic outputs #########################\n\n  /**\n   * @inheritdoc\n   */\n\n\n  invalidateVisuals() {}\n\n};\n\n__decorate([Input(), __metadata(\"design:type\", Object)], TransformDataRelations.prototype, \"data\", void 0);\n\n__decorate([DynamicOutput(), __metadata(\"design:type\", Object)], TransformDataRelations.prototype, \"transformedData\", void 0);\n\nTransformDataRelations = __decorate([PureRelationsComponent(), RelationsEditorMetadata(TransformDataRelationsMetadataLoader), __metadata(\"design:paramtypes\", [Injector])], TransformDataRelations);\nexport { TransformDataRelations };","import { TransformDataRelations } from './transformData.relations';\nexport default TransformDataRelations;","import { DynamicClassMetadata } from '@anglr/dynamic';\n/**\n * Sets relations editor metadata to class on which is this decorator applied\n * @param metadataLoader - Relations editor metadata loader function used for obtaining metadata\n */\n\nexport function RelationsEditorMetadata(metadataLoader) {\n  return DynamicClassMetadata(metadataLoader, 'relationsEditorMetadata');\n}","import { Subject } from 'rxjs';\n/**\n * Creates dynamic output for property\n */\n\nexport function DynamicOutput() {\n  return function (target, propertyKey) {\n    const prop = propertyKey;\n    Object.defineProperty(target, `${prop}Change`, {\n      get: function () {\n        if (!this[`ɵ${prop}Change`]) {\n          this[`ɵ${prop}Change`] = new Subject();\n        }\n\n        return this[`ɵ${prop}Change`];\n      }\n    });\n    Object.defineProperty(target, prop, {\n      get: function () {\n        return this[`ɵ${prop}`];\n      },\n      set: function (value) {\n        this[`ɵ${prop}`] = value;\n        this[`${prop}Change`].next();\n      }\n    });\n  };\n}","//TODO: rework also with symbol\n\n/**\n * Sets dynamic metadata to class on which is this decorator applied\n * @param metadataLoader - Metadata loader function used for obtaining metadata\n * @param propertyName - Name of property where will be metadata instance stored\n */\nexport function DynamicClassMetadata(metadataLoader, propertyName) {\n  if (ngDesignerMetadata) {\n    return function (target) {\n      target[propertyName] = metadataLoader();\n      return target;\n    };\n  }\n\n  return function (target) {\n    return target;\n  };\n}"],"names":["ɵɵclassMapInterpolate1","prefix","v0","suffix","lView","getLView","interpolatedValue","interpolation1","checkStylingMap","keyValueArraySet","classStringParser","ɵɵclassMapInterpolate2","i0","v1","interpolation2","ɵɵclassMapInterpolate3","i1","v2","interpolation3","ɵɵclassMapInterpolate4","i2","v3","interpolation4","ɵɵclassMapInterpolate5","i3","v4","interpolation5","ɵɵclassMapInterpolate6","i4","v5","interpolation6","ɵɵclassMapInterpolate7","i5","v6","interpolation7","ɵɵclassMapInterpolate8","i6","v7","interpolation8","ɵɵclassMapInterpolateV","values","interpolationV","ɵɵpropertyInterpolate","propName","sanitizer","ɵɵpropertyInterpolate1","NO_CHANGE","tView","getTView","tNode","getSelectedTNode","elementPropertyInternal","RENDERER","ɵɵpropertyInterpolate2","ɵɵpropertyInterpolate3","ɵɵpropertyInterpolate4","ɵɵpropertyInterpolate5","ɵɵpropertyInterpolate6","ɵɵpropertyInterpolate7","ɵɵpropertyInterpolate8","ɵɵpropertyInterpolateV","ES5_DELEGATE_CTOR","ES2015_INHERITED_CLASS","ES2015_INHERITED_CLASS_WITH_CTOR","ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR","ReflectionCapabilities","constructor","reflect","this","_reflect","global","factory","t","args","_zipTypesAndAnnotations","paramTypes","paramAnnotations","result","newArray","length","i","Object","concat","_ownParameters","type","parentCtor","typeStr","toString","test","parameters","tsickleCtorParams","ctorParameters","map","ctorParam","convertTsickleDecoratorIntoMetadata","decorators","hasOwnProperty","PARAMETERS","getOwnMetadata","isType","getParentCtor","_ownAnnotations","typeOrFunc","annotations","ANNOTATIONS","ownAnnotations","_ownPropMetadata","propMetadata","propDecorators","keys","forEach","prop","PROP_METADATA","parentPropMetadata","ownPropMetadata","push","hasLifecycleHook","lcProperty","Type","prototype","decoratorInvocations","decoratorInvocation","annotationCls","ctor","parentProto","getPrototypeOf","Attribute","makeParamDecorator","attributeName","__NG_ELEMENT_ID__","ɵɵinjectAttribute","getReflect","reflectDependencies","dep","meta","token","attribute","host","optional","self","skipSelf","Array","isArray","j","param","undefined","proto","Optional","ngMetadataName","SkipSelf","Self","Host","Inject","RuntimeError","ngDevMode","reflectDependency","modules","Map","COPY_DIRECTIVE_FIELDS","COPY_COMPONENT_FIELDS","ELEMENT_MARKER","marker","ICU_MARKER","I18nCreateOpCode","getInsertInFrontOfRNodeWithI18n","parentTNode","currentTNode","tNodeInsertBeforeIndex","insertBeforeIndex","getInsertInFrontOfRNodeWithNoI18n","unwrapRNode","processI18nInsertBefore","renderer","childTNode","childRNode","parentRElement","i18nParent","anchorRNode","flags","i18nChild","nativeInsertBefore","addTNodeAndUpdateInsertBeforeIndex","previousTNodes","newTNode","existingTNode","isI18nText","isNewTNodeCreatedBefore","getInsertBeforeIndex","setInsertBeforeIndex","index","value","setI18nHandling","getTIcu","data","createTNodePlaceholder","createTNodeAtIndex","getCurrentICUCaseIndex","tIcu","currentCase","currentCaseLViewIndex","changeMask","changeMaskCounter","applyMutableOpCodes","mutableOpCodes","rootRNode","rootIdx","opCode","textNodeIndex","createTextNode","parentIdx","insertInFrontOf","parentRNode","nativeParentNode","refIdx","child","caseIndex","create","anchorIdx","elementNodeIndex","attrName","attrValue","setElementAttribute","getNativeByIndex","commentValue","commentNodeIndex","commentRNode","createCommentNode","attachPatchData","tagName","elementRNode","createElementNode","applyUpdateOpCodes","updateOpCodes","bindingsStartIndex","checkBit","skipCodes","renderStringify","nodeIndex","sanitizeFn","tNodeOrTagName","rText","updateTextNode","applyIcuSwitchCase","applyIcuUpdateCase","activeCaseIndex","mask","update","icuExpression","bindingValue","cases","indexOf","resolvedCase","getPluralCase","getLocaleId","getCaseIndex","applyIcuSwitchCaseRemove","removeCodes","remove","nodeOrIcuIndex","rNode","nativeRemoveNode","loadIcuContainerVisitor","_stack","_lView","_removes","_index","enterIcu","EMPTY_ARRAY","icuContainerIteratorNext","removeOpCode","tIcuIndex","TVIEW","pop","tIcuContainerNode","BINDING_REGEXP","ICU_REGEXP","NESTED_ICU","ICU_BLOCK_REGEXP","SUBTEMPLATE_REGEXP","PH_REGEXP","NGSP_UNICODE_REGEXP","createTNodeAndAddOpCode","rootTNode","existingTNodes","createOpCodes","text","isICU","i18nNodeIdx","allocExpando","SHIFT","getCurrentParentTNode","APPEND_EAGERLY","COMMENT","ensureIcuContainerVisitorLoaded","tNodeIdx","setCurrentTNode","assertEqual","setTNodeInsertBeforeIndex","i18nStartFirstCreatePassProcessTextNode","hasBinding","match","generateBindingUpdateOpCodes","str","destinationNode","bindingStart","maskIndex","sizeIndex","startIndex","textParts","split","textValue","bindingIndex","parseInt","toMaskBit","countBindings","opCodes","count","Math","min","removeInnerTemplateTranslation","message","tagMatched","res","inTemplate","exec","substring","slice","icuStart","bindingMask","mainBinding","addUpdateIcuSwitch","setTIcu","valueArr","nestedIcus","icuIndex","parseIcuCase","join","addUpdateIcuUpdate","parseICUBlock","pattern","icuType","replace","binding","parts","i18nParseTextIntoPartsAndICU","pos","key","trim","blocks","prevPos","braceStack","results","braces","lastIndex","block","caseName","unsafeCaseHtml","inertBodyElement","getInertBodyHelper","getDocument","getInertBodyElement","inertRootNode","getTemplateContent","walkIcuTree","sharedUpdateOpCodes","parentNode","depth","currentNode","firstChild","newIndex","nodeType","Node","ELEMENT_NODE","element","toLowerCase","VALID_ELEMENTS","addCreateNodeAndAppend","elAttrs","attributes","attr","item","lowerAttrName","name","VALID_ATTRS","URI_ATTRS","_sanitizeUrl","addCreateAttribute","addRemoveNode","TEXT_NODE","textContent","COMMENT_NODE","isNestedIcu","addRemoveNestedIcu","nextSibling","appendToParentIdx","createAtIdx","PP_MULTI_VALUE_PLACEHOLDERS_REGEXP","PP_PLACEHOLDERS_REGEXP","PP_ICU_VARS_REGEXP","PP_ICU_PLACEHOLDERS_REGEXP","PP_ICUS_REGEXP","PP_CLOSE_TEMPLATE_REGEXP","PP_TEMPLATE_ID_REGEXP","ɵɵi18nStart","messageIndex","subTemplateIndex","adjustedIndex","HEADER_OFFSET","getConstant","consts","firstCreatePass","parentTNodeIndex","existingTNodeStack","isRootTemplateMessage","start","end","search","RegExp","getTranslationForTemplate","msgParts","part","Error","isClosing","charCodeAt","Number","shift","unshift","i18nStartFirstCreatePass","tI18n","sameViewParentTNode","T_HOST","getClosestRElement","isComment","appendNow","createComment","applyCreateOpCodes","setInI18nBlock","ɵɵi18nEnd","angularCoreEnv","r3","ɵɵattributeInterpolate1","namespace","elementAttributeInternal","ɵɵattributeInterpolate2","ɵɵattributeInterpolate3","ɵɵattributeInterpolate4","ɵɵattributeInterpolate5","ɵɵattributeInterpolate6","ɵɵattributeInterpolate7","ɵɵattributeInterpolate8","ɵɵattributeInterpolateV","interpolated","ɵɵdefineInjectable","ɵɵdefineInjector","ɵɵinject","ɵɵinvalidFactoryDep","definition","superDef","superType","getSuperType","isComponentDef","ɵcmp","ɵdir","defAny","field","ɵɵstyleMap","ɵɵstylePropInterpolate1","valueSuffix","checkStylingProperty","ɵɵstylePropInterpolate2","ɵɵstylePropInterpolate3","ɵɵstylePropInterpolate4","ɵɵstylePropInterpolate5","ɵɵstylePropInterpolate6","ɵɵstylePropInterpolate7","ɵɵstylePropInterpolate8","ɵɵstylePropInterpolateV","attrsIndex","attrs","previousElementIndex","getCurrentTNode","i18nAttributesFirstPass","ɵɵi18nExp","bindingUpdated","nextBindingIndex","getBindingIndex","applyI18n","replacements","matches","templateIdsStack","m","phs","tmpl","content","placeholders","placeholder","templateId","isCloseTemplateTag","currentTemplateId","idx","splice","_type","_idx","list","i18nPostprocess","ngModuleType","id","incoming","stringify","assertSameOrNotExisting","get","set","sanitization","forwardRef","resolveForwardRef","isNgModule","getNgModuleDef","moduleQueue","flushingModuleQueue","isResolvedDeclaration","declaration","every","setScopeOnDeclaredComponents","moduleType","ngModule","declarations","flatten","transitiveScopes","transitiveScopesFor","NG_COMP_DEF","component","patchComponentDefWithScope","getComponentDef","NG_DIR_DEF","NG_PIPE_DEF","ngSelectorScope","componentDef","directiveDefs","from","compilation","directives","dir","getDirectiveDef","filter","def","pipeDefs","pipes","pipe","getPipeDef","schemas","transitiveCompileScopes","scopes","Set","exported","maybeUnwrapFn","imports","imported","importedScope","entry","add","declared","declaredWithDefs","exports","exportedType","exportedScope","transitiveScopesForNgModule","isStandalone","WeakMap","compilationDepth","compileDirective","directive","ngDirectiveDef","addDirectiveFactoryDef","defineProperty","getDirectiveMetadata","compiler","getCompilerFacade","usage","kind","sourceMapUrl","metadata","configurable","facade","directiveMetadata","typeSourceSpan","createParseSourceSpan","usesInheritance","addDirectiveDefToUndecoratedParents","ngFactoryDef","NG_FACTORY_DEF","compileFactory","typeArgumentCount","deps","target","FactoryTarget","Directive","extendsDirectlyFromObject","selector","EMPTY_OBJ","inputs","outputs","queries","extractQueriesMetadata","isContentQuery","lifecycle","usesOnChanges","exportAs","splitByComma","providers","viewQueries","isViewQuery","standalone","objPrototype","parent","shouldAddAbstractDirective","convertToR3QueryMetadata","propertyName","ann","predicate","descendants","first","read","static","emitDistinctChangesOnly","isQueryAnn","queriesMeta","stringifyForError","some","isInputAnnotation","piece","LIFECYCLE_HOOKS","hookName","current","metadataName","getPipeMetadata","pipeName","pure","makeDecorator","Input","c","changeDetection","ChangeDetectionStrategy","ngComponentDef","maybeQueueResolutionOfComponentResources","componentNeedsResolution","error","templateUrl","styleUrls","JSON","options","getJitOptions","preserveWhitespaces","encapsulation","defaultEncapsulation","ViewEncapsulation","template","styles","animations","interpolation","viewProviders","compileComponent","cachedDirectiveDefs","cachedPipeDefs","seen","rawDep","has","scope","getStandaloneDefFunctions","dependencies","flushModuleScopingQueueAsMuchAsPossible","p","ngPipeDef","Pipe","compilePipe","makePropDecorator","bindingPropertyName","hostPropertyName","eventName","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","done","Promise","then","TransformDataRelationsMetadataLoader","fn","_ref","TransformDataRelationsEditorMetadata","arguments","apply","err","TransformDataRelations","injector","codeExecutor","relationsOptions","ngOnChanges","changes","_this","nameof","transformer","loadData","code","transformedData","e","console","invalidateVisuals","RelationsEditorMetadata","metadataLoader","DynamicOutput","propertyKey","next","DynamicClassMetadata"],"sourceRoot":""}