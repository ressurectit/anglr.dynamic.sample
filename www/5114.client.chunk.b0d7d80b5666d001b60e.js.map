{"version":3,"file":"5114.client.chunk.b0d7d80b5666d001b60e.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../src/cdk/text-field/text-field-module.ts","webpack://ng-universal-demo/../../../src/material/input/input-module.ts","webpack://ng-universal-demo/../../../src/material/input/input-value-accessor.ts","webpack://ng-universal-demo/../../../src/cdk/platform/features/input-types.ts","webpack://ng-universal-demo/../../../src/cdk/text-field/autofill.ts","webpack://ng-universal-demo/../../../src/material/input/input.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkAutofill} from './autofill';\nimport {CdkTextareaAutosize} from './autosize';\n\n@NgModule({\n  declarations: [CdkAutofill, CdkTextareaAutosize],\n  exports: [CdkAutofill, CdkTextareaAutosize],\n})\nexport class TextFieldModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TextFieldModule} from '@angular/cdk/text-field';\nimport {NgModule} from '@angular/core';\nimport {ErrorStateMatcher, MatCommonModule} from '@angular/material/core';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatInput} from './input';\n\n@NgModule({\n  declarations: [MatInput],\n  imports: [TextFieldModule, MatFormFieldModule, MatCommonModule],\n  exports: [\n    TextFieldModule,\n    // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n    // be used together with `MatFormField`.\n    MatFormFieldModule,\n    MatInput,\n  ],\n  providers: [ErrorStateMatcher],\n})\nexport class MatInputModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nexport const MAT_INPUT_VALUE_ACCESSOR = new InjectionToken<{value: any}>(\n  'MAT_INPUT_VALUE_ACCESSOR',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Cached result Set of input types support by the current browser. */\nlet supportedInputTypes: Set<string>;\n\n/** Types of `<input>` that *might* be supported. */\nconst candidateInputTypes = [\n  // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n  // first changing it to something else:\n  // The specified value \"\" does not conform to the required format.\n  // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n  'color',\n  'button',\n  'checkbox',\n  'date',\n  'datetime-local',\n  'email',\n  'file',\n  'hidden',\n  'image',\n  'month',\n  'number',\n  'password',\n  'radio',\n  'range',\n  'reset',\n  'search',\n  'submit',\n  'tel',\n  'text',\n  'time',\n  'url',\n  'week',\n];\n\n/** @returns The input types supported by this browser. */\nexport function getSupportedInputTypes(): Set<string> {\n  // Result is cached.\n  if (supportedInputTypes) {\n    return supportedInputTypes;\n  }\n\n  // We can't check if an input type is not supported until we're on the browser, so say that\n  // everything is supported when not on the browser. We don't use `Platform` here since it's\n  // just a helper function and can't inject it.\n  if (typeof document !== 'object' || !document) {\n    supportedInputTypes = new Set(candidateInputTypes);\n    return supportedInputTypes;\n  }\n\n  let featureTestInput = document.createElement('input');\n  supportedInputTypes = new Set(\n    candidateInputTypes.filter(value => {\n      featureTestInput.setAttribute('type', value);\n      return featureTestInput.type === value;\n    }),\n  );\n\n  return supportedInputTypes;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Output,\n} from '@angular/core';\nimport {coerceElement} from '@angular/cdk/coercion';\nimport {EMPTY, Observable, Subject} from 'rxjs';\n\n/** An event that is emitted when the autofill state of an input changes. */\nexport type AutofillEvent = {\n  /** The element whose autofill state changes. */\n  target: Element;\n  /** Whether the element is currently autofilled. */\n  isAutofilled: boolean;\n};\n\n/** Used to track info about currently monitored elements. */\ntype MonitoredElementInfo = {\n  readonly subject: Subject<AutofillEvent>;\n  unlisten: () => void;\n};\n\n/** Options to pass to the animationstart listener. */\nconst listenerOptions = normalizePassiveListenerOptions({passive: true});\n\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\n@Injectable({providedIn: 'root'})\nexport class AutofillMonitor implements OnDestroy {\n  private _monitoredElements = new Map<Element, MonitoredElementInfo>();\n\n  constructor(private _platform: Platform, private _ngZone: NgZone) {}\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: Element): Observable<AutofillEvent>;\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: ElementRef<Element>): Observable<AutofillEvent>;\n\n  monitor(elementOrRef: Element | ElementRef<Element>): Observable<AutofillEvent> {\n    if (!this._platform.isBrowser) {\n      return EMPTY;\n    }\n\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      return info.subject;\n    }\n\n    const result = new Subject<AutofillEvent>();\n    const cssClass = 'cdk-text-field-autofilled';\n    const listener = ((event: AnimationEvent) => {\n      // Animation events fire on initial element render, we check for the presence of the autofill\n      // CSS class to make sure this is a real change in state, not just the initial render before\n      // we fire off events.\n      if (\n        event.animationName === 'cdk-text-field-autofill-start' &&\n        !element.classList.contains(cssClass)\n      ) {\n        element.classList.add(cssClass);\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: true}));\n      } else if (\n        event.animationName === 'cdk-text-field-autofill-end' &&\n        element.classList.contains(cssClass)\n      ) {\n        element.classList.remove(cssClass);\n        this._ngZone.run(() => result.next({target: event.target as Element, isAutofilled: false}));\n      }\n    }) as EventListenerOrEventListenerObject;\n\n    this._ngZone.runOutsideAngular(() => {\n      element.addEventListener('animationstart', listener, listenerOptions);\n      element.classList.add('cdk-text-field-autofill-monitored');\n    });\n\n    this._monitoredElements.set(element, {\n      subject: result,\n      unlisten: () => {\n        element.removeEventListener('animationstart', listener, listenerOptions);\n      },\n    });\n\n    return result;\n  }\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: Element): void;\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: ElementRef<Element>): void;\n\n  stopMonitoring(elementOrRef: Element | ElementRef<Element>): void {\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      info.unlisten();\n      info.subject.complete();\n      element.classList.remove('cdk-text-field-autofill-monitored');\n      element.classList.remove('cdk-text-field-autofilled');\n      this._monitoredElements.delete(element);\n    }\n  }\n\n  ngOnDestroy() {\n    this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\n  }\n}\n\n/** A directive that can be used to monitor the autofill state of an input. */\n@Directive({\n  selector: '[cdkAutofill]',\n})\nexport class CdkAutofill implements OnDestroy, OnInit {\n  /** Emits when the autofill state of the element changes. */\n  @Output() readonly cdkAutofill = new EventEmitter<AutofillEvent>();\n\n  constructor(\n    private _elementRef: ElementRef<HTMLElement>,\n    private _autofillMonitor: AutofillMonitor,\n  ) {}\n\n  ngOnInit() {\n    this._autofillMonitor\n      .monitor(this._elementRef)\n      .subscribe(event => this.cdkAutofill.emit(event));\n  }\n\n  ngOnDestroy() {\n    this._autofillMonitor.stopMonitoring(this._elementRef);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {getSupportedInputTypes, Platform} from '@angular/cdk/platform';\nimport {AutofillMonitor} from '@angular/cdk/text-field';\nimport {\n  AfterViewInit,\n  Directive,\n  DoCheck,\n  ElementRef,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Self,\n} from '@angular/core';\nimport {FormGroupDirective, NgControl, NgForm, Validators} from '@angular/forms';\nimport {CanUpdateErrorState, ErrorStateMatcher, mixinErrorState} from '@angular/material/core';\nimport {MatFormFieldControl, MatFormField, MAT_FORM_FIELD} from '@angular/material/form-field';\nimport {Subject} from 'rxjs';\nimport {getMatInputUnsupportedTypeError} from './input-errors';\nimport {MAT_INPUT_VALUE_ACCESSOR} from './input-value-accessor';\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n  'button',\n  'checkbox',\n  'file',\n  'hidden',\n  'image',\n  'radio',\n  'range',\n  'reset',\n  'submit',\n];\n\nlet nextUniqueId = 0;\n\n// Boilerplate for applying mixins to MatInput.\n/** @docs-private */\nconst _MatInputBase = mixinErrorState(\n  class {\n    /**\n     * Emits whenever the component state changes and should cause the parent\n     * form field to update. Implemented as part of `MatFormFieldControl`.\n     * @docs-private\n     */\n    readonly stateChanges = new Subject<void>();\n\n    constructor(\n      public _defaultErrorStateMatcher: ErrorStateMatcher,\n      public _parentForm: NgForm,\n      public _parentFormGroup: FormGroupDirective,\n      /**\n       * Form control bound to the component.\n       * Implemented as part of `MatFormFieldControl`.\n       * @docs-private\n       */\n      public ngControl: NgControl,\n    ) {}\n  },\n);\n\n/** Directive that allows a native input to work inside a `MatFormField`. */\n@Directive({\n  selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n  exportAs: 'matInput',\n  host: {\n    /**\n     * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n     */\n    'class': 'mat-input-element mat-form-field-autofill-control',\n    '[class.mat-input-server]': '_isServer',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[attr.id]': 'id',\n    // At the time of writing, we have a lot of customer tests that look up the input based on its\n    // placeholder. Since we sometimes omit the placeholder attribute from the DOM to prevent screen\n    // readers from reading it twice, we have to keep it somewhere in the DOM for the lookup.\n    '[attr.data-placeholder]': 'placeholder',\n    '[disabled]': 'disabled',\n    '[required]': 'required',\n    '[attr.name]': 'name || null',\n    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n    '[class.mat-native-select-inline]': '_isInlineSelect()',\n    // Only mark the input as invalid for assistive technology if it has a value since the\n    // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n    '[attr.aria-invalid]': '(empty && required) ? null : errorState',\n    '[attr.aria-required]': 'required',\n    '(focus)': '_focusChanged(true)',\n    '(blur)': '_focusChanged(false)',\n    '(input)': '_onInput()',\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatInput}],\n})\nexport class MatInput\n  extends _MatInputBase\n  implements\n    MatFormFieldControl<any>,\n    OnChanges,\n    OnDestroy,\n    AfterViewInit,\n    DoCheck,\n    CanUpdateErrorState\n{\n  protected _uid = `mat-input-${nextUniqueId++}`;\n  protected _previousNativeValue: any;\n  private _inputValueAccessor: {value: any};\n  private _previousPlaceholder: string | null;\n\n  /** Whether the component is being rendered on the server. */\n  readonly _isServer: boolean;\n\n  /** Whether the component is a native html select. */\n  readonly _isNativeSelect: boolean;\n\n  /** Whether the component is a textarea. */\n  readonly _isTextarea: boolean;\n\n  /** Whether the input is inside of a form field. */\n  readonly _isInFormField: boolean;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  focused: boolean = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  override readonly stateChanges: Subject<void> = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  controlType: string = 'mat-input';\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  autofilled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get disabled(): boolean {\n    if (this.ngControl && this.ngControl.disabled !== null) {\n      return this.ngControl.disabled;\n    }\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  protected _disabled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n  }\n  protected _id: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input() placeholder: string;\n\n  /**\n   * Name of the input.\n   * @docs-private\n   */\n  @Input() name: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n  protected _required: boolean | undefined;\n\n  /** Input type of the element. */\n  @Input()\n  get type(): string {\n    return this._type;\n  }\n  set type(value: string) {\n    this._type = value || 'text';\n    this._validateType();\n\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n      (this._elementRef.nativeElement as HTMLInputElement).type = this._type;\n    }\n  }\n  protected _type = 'text';\n\n  /** An object used to control when error messages are shown. */\n  @Input() override errorStateMatcher: ErrorStateMatcher;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get value(): string {\n    return this._inputValueAccessor.value;\n  }\n  set value(value: any) {\n    if (value !== this.value) {\n      this._inputValueAccessor.value = value;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Whether the element is readonly. */\n  @Input()\n  get readonly(): boolean {\n    return this._readonly;\n  }\n  set readonly(value: BooleanInput) {\n    this._readonly = coerceBooleanProperty(value);\n  }\n  private _readonly = false;\n\n  protected _neverEmptyInputTypes = [\n    'date',\n    'datetime',\n    'datetime-local',\n    'month',\n    'time',\n    'week',\n  ].filter(t => getSupportedInputTypes().has(t));\n\n  constructor(\n    protected _elementRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>,\n    protected _platform: Platform,\n    @Optional() @Self() ngControl: NgControl,\n    @Optional() _parentForm: NgForm,\n    @Optional() _parentFormGroup: FormGroupDirective,\n    _defaultErrorStateMatcher: ErrorStateMatcher,\n    @Optional() @Self() @Inject(MAT_INPUT_VALUE_ACCESSOR) inputValueAccessor: any,\n    private _autofillMonitor: AutofillMonitor,\n    ngZone: NgZone,\n    // TODO: Remove this once the legacy appearance has been removed. We only need\n    // to inject the form field for determining whether the placeholder has been promoted.\n    @Optional() @Inject(MAT_FORM_FIELD) private _formField?: MatFormField,\n  ) {\n    super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n\n    const element = this._elementRef.nativeElement;\n    const nodeName = element.nodeName.toLowerCase();\n\n    // If no input value accessor was explicitly specified, use the element as the input value\n    // accessor.\n    this._inputValueAccessor = inputValueAccessor || element;\n\n    this._previousNativeValue = this.value;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (_platform.IOS) {\n      ngZone.runOutsideAngular(() => {\n        _elementRef.nativeElement.addEventListener('keyup', this._iOSKeyupListener);\n      });\n    }\n\n    this._isServer = !this._platform.isBrowser;\n    this._isNativeSelect = nodeName === 'select';\n    this._isTextarea = nodeName === 'textarea';\n    this._isInFormField = !!_formField;\n\n    if (this._isNativeSelect) {\n      this.controlType = (element as HTMLSelectElement).multiple\n        ? 'mat-native-select-multiple'\n        : 'mat-native-select';\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n\n  ngOnDestroy() {\n    this.stateChanges.complete();\n\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n\n    if (this._platform.IOS) {\n      this._elementRef.nativeElement.removeEventListener('keyup', this._iOSKeyupListener);\n    }\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n    }\n\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n\n    // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n    // present or not depends on a query which is prone to \"changed after checked\" errors.\n    this._dirtyCheckPlaceholder();\n  }\n\n  /** Focuses the input. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Callback for the cases where the focused state of the input changes. */\n  _focusChanged(isFocused: boolean) {\n    if (isFocused !== this.focused) {\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n  }\n\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n\n  /** Does some manual dirty checking on the native input `placeholder` attribute. */\n  private _dirtyCheckPlaceholder() {\n    // If we're hiding the native placeholder, it should also be cleared from the DOM, otherwise\n    // screen readers will read it out twice: once from the label and once from the attribute.\n    // TODO: can be removed once we get rid of the `legacy` style for the form field, because it's\n    // the only one that supports promoting the placeholder to a label.\n    const formField = this._formField;\n    const placeholder =\n      formField && formField.appearance === 'legacy' && !formField._hasLabel?.()\n        ? null\n        : this.placeholder;\n    if (placeholder !== this._previousPlaceholder) {\n      const element = this._elementRef.nativeElement;\n      this._previousPlaceholder = placeholder;\n      placeholder\n        ? element.setAttribute('placeholder', placeholder)\n        : element.removeAttribute('placeholder');\n    }\n  }\n\n  /** Does some manual dirty checking on the native input `value` property. */\n  protected _dirtyCheckNativeValue() {\n    const newValue = this._elementRef.nativeElement.value;\n\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Make sure the input is a supported type. */\n  protected _validateType() {\n    if (\n      MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n\n  /** Checks whether the input type is one of the types that are never empty. */\n  protected _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n\n  /** Checks whether the input is invalid based on the native validation. */\n  protected _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let validity = (this._elementRef.nativeElement as HTMLInputElement).validity;\n    return validity && validity.badInput;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get empty(): boolean {\n    return (\n      !this._isNeverEmpty() &&\n      !this._elementRef.nativeElement.value &&\n      !this._isBadInput() &&\n      !this.autofilled\n    );\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    if (this._isNativeSelect) {\n      // For a single-selection `<select>`, the label should float when the selected option has\n      // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n      // overlapping the label with the options.\n      const selectElement = this._elementRef.nativeElement as HTMLSelectElement;\n      const firstOption: HTMLOptionElement | undefined = selectElement.options[0];\n\n      // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n      // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n      return (\n        this.focused ||\n        selectElement.multiple ||\n        !this.empty ||\n        !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label)\n      );\n    } else {\n      return this.focused || !this.empty;\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n    // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n    // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n    if (!this.focused) {\n      this.focus();\n    }\n  }\n\n  /** Whether the form control is a native select that is displayed inline. */\n  _isInlineSelect(): boolean {\n    const element = this._elementRef.nativeElement as HTMLSelectElement;\n    return this._isNativeSelect && (element.multiple || element.size > 1);\n  }\n\n  private _iOSKeyupListener = (event: Event): void => {\n    const el = event.target as HTMLInputElement;\n\n    // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n    // indicate different things. If the value is 0, it means that the caret is at the start\n    // of the input, whereas a value of `null` means that the input doesn't support\n    // manipulating the selection range. Inputs that don't support setting the selection range\n    // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n    // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n      // Note: Just setting `0, 0` doesn't fix the issue. Setting\n      // `1, 1` fixes it for the first time that you type text and\n      // then hold delete. Toggling to `1, 1` and then back to\n      // `0, 0` seems to completely fix it.\n      el.setSelectionRange(1, 1);\n      el.setSelectionRange(0, 0);\n    }\n  };\n}\n"],"names":["TextFieldModule","MatInputModule","ErrorStateMatcher","MatFormFieldModule","MatCommonModule","MAT_INPUT_VALUE_ACCESSOR","InjectionToken","supportedInputTypes","candidateInputTypes","getSupportedInputTypes","document","Set","featureTestInput","createElement","filter","value","setAttribute","type","listenerOptions","normalizePassiveListenerOptions","passive","AutofillMonitor","constructor","_platform","_ngZone","_monitoredElements","Map","monitor","elementOrRef","this","isBrowser","EMPTY","element","coerceElement","info","get","subject","result","Subject","cssClass","listener","event","animationName","classList","contains","remove","run","next","target","isAutofilled","add","runOutsideAngular","addEventListener","set","unlisten","removeEventListener","stopMonitoring","complete","delete","ngOnDestroy","forEach","_info","i1","CdkAutofill","_elementRef","_autofillMonitor","cdkAutofill","EventEmitter","ngOnInit","subscribe","emit","i0","MAT_INPUT_INVALID_TYPES","nextUniqueId","_MatInputBase","mixinErrorState","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","stateChanges","MatInput","inputValueAccessor","ngZone","_formField","super","_uid","focused","controlType","autofilled","_disabled","_type","_readonly","_neverEmptyInputTypes","t","has","_iOSKeyupListener","el","selectionStart","selectionEnd","setSelectionRange","nativeElement","nodeName","toLowerCase","_inputValueAccessor","_previousNativeValue","id","IOS","_isServer","_isNativeSelect","_isTextarea","_isInFormField","multiple","disabled","coerceBooleanProperty","_id","required","_required","control","hasValidator","Validators","_validateType","readonly","ngAfterViewInit","ngOnChanges","ngDoCheck","updateErrorState","_dirtyCheckNativeValue","_dirtyCheckPlaceholder","focus","options","_focusChanged","isFocused","_onInput","formField","placeholder","appearance","_hasLabel","_previousPlaceholder","removeAttribute","newValue","indexOf","_isNeverEmpty","_isBadInput","validity","badInput","empty","shouldLabelFloat","selectElement","firstOption","selectedIndex","label","setDescribedByIds","ids","length","join","onContainerClick","_isInlineSelect","size","i4","MAT_FORM_FIELD","provide","MatFormFieldControl","useExisting"],"sourceRoot":""}