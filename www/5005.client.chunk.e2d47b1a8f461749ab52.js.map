{"version":3,"file":"5005.client.chunk.e2d47b1a8f461749ab52.js","mappings":";mMASM,MAAOA,EAGTC,YAAgDC,GAAA,KAAAA,QAAAA,CAEhD,CASOC,UAAkBC,EAA+CC,GAEpE,OAAGC,EAAAA,EAAAA,IAAQF,GAEA,KAGRA,aAAiBG,EAAAA,GAETH,GAGXI,KAAKN,SAASO,KAAK,iDAEZ,KACX,mCA7BST,GAAiB,IAGMU,EAAAA,GAAM,8CAH7BV,EAAiB,oNCQxB,MAAgBW,UAAkFC,EAAAA,EAgCzFR,UAAMA,GAEb,MAAMS,EAAWL,KAAKJ,MACtBI,KAAKM,YAAcV,EAEfA,IAAUS,GAEVL,KAAKO,SAASC,WAAWZ,EAEjC,CACWA,YAEP,OAAOI,KAAKM,WAChB,CAMWG,aAASb,GAEhBI,KAAKU,UAAYd,GAEH,IAAVA,EAMJI,KAAKO,SAASI,iBAAiBC,EAAAA,GAAAA,UAJ3BZ,KAAKO,SAASM,cAAcD,EAAAA,GAAAA,SAKpC,CACWH,eAEP,OAAOT,KAAKU,SAChB,CAMWI,aAASlB,GAEhBI,KAAKe,UAAYnB,GAEH,IAAVA,EAMJI,KAAKO,SAASS,SAJVhB,KAAKO,SAASU,SAKtB,CACWH,eAEP,OAAOd,KAAKe,SAChB,CAYAtB,YAAYyB,EACAC,EACAC,EACsDC,EAC1B3B,GAEpC4B,MAAMJ,EAAiBC,EAAUC,EAAW1B,GAHkB,KAAA2B,eAAAA,EAnFxD,KAAAd,QAA2B,IAAIR,EAAAA,EAuFzC,CAOmBwB,eAEXvB,KAAKwB,UAKTxB,KAAKyB,qBAAqBC,cAC1B1B,KAAKyB,oBAAsB,KAE3BzB,KAAKO,QAAUP,KAAK2B,gBAAgB3B,KAAKwB,SAASI,YAAa5B,KAAKqB,eAAgBQ,EAAAA,EAAAA,YAAsC7B,KAAKJ,OAC/HI,KAAK8B,uBAEL9B,KAAKyB,oBAAsBzB,KAAKO,SAC1BwB,cACAC,WAAUpC,IAERI,KAAKM,YAAcV,CAAK,IAEpC,CAOUkC,uBACT,CAYOH,gBAAgBC,EAAoCK,EAA0CC,EAA+CL,EAAAA,EAAAA,YAAsCM,GAEvL,IAAI5B,GAAU6B,EAAAA,EAAAA,IAAeR,EAAaK,EAAeC,EAAoBC,GAmB7E,OAjBK5B,IAEDP,KAAKqC,QAAQpC,KAAK,8DAA+D,CAACqC,KAAMV,IAExFrB,GAAUgC,EAAAA,EAAAA,IAAkBL,EAAoBC,IAGhDnC,KAAKS,UAELF,EAAQM,cAAcD,EAAAA,GAAAA,UAGtBZ,KAAKc,UAELP,EAAQU,UAGLV,CACX,mCA9KkBJ,GAAiB,gCAsGfqC,EAAAA,EAAsB,OACtBtC,EAAAA,GAAM,uBAvGRC,EAAiB,iFA8FnCsC,EAAAA,EAAAA,IAAAA,EAACC,EAAAA,EAAAA,MAAe,mGCzGb,MAAMF,EAA2D,aAAIG,GAAgC,2ECEtG,SAAUC,EAAqBC,GAEjC,OAAOC,EAAAA,EAAAA,GAA+ED,EAAgB,uBAC1G,ucCAM,MAAgBzC,EAwBJ2C,cAEV,OAAO/C,KAAKgD,gBAChB,CAKcC,wBAEV,OAAOjD,KAAKwB,OAChB,CAUA/B,YAAsByD,EACAF,EACAG,EAC4Bd,GAH5B,KAAAa,eAAAA,EACA,KAAAF,iBAAAA,EACA,KAAAG,SAAAA,EAC4B,KAAAd,OAAAA,EAzCxC,KAAAe,WAA+C,GAK/C,KAAAC,aAAuB,EAKvB,KAAAC,WAAqB,CAiC/B,CAOOC,cAEH,IAAGvD,KAAKsD,UAAR,CAKAtD,KAAKsD,WAAY,EAEjB,IAAI,MAAME,KAAOxD,KAAKoD,WAElBI,EAAIC,UAGRzD,KAAK0D,YACT,CAOaC,WAAQ,iCAEjB,GAAG,EAAKN,YAEJ,OAGJ,EAAKA,aAAc,EACnB,MAAMJ,EAAoB,EAAKA,kBAK/B,SAHM,EAAKW,eACL,EAAKrC,eAER0B,EAEC,IAAI,MAAMY,KAAa,EAAKT,iBAElBS,EAAUC,WAAW,EAAKX,SAAU,EAAKJ,QAAS,SAI1D,EAAKgB,WAAY,GArBN,EAsBrB,CAKaC,YAAYC,GAAsB,iCAG3C,IAAGC,EAAAA,EAAAA,GAAsC,aAAcD,EACvD,OACU,EAAK1C,eAEX,MAAM0B,EAAoB,EAAKA,kBAG/B,GAAGA,EAEC,IAAI,MAAMY,KAAa,EAAKT,iBAElBS,EAAUM,cAAclB,GAItC,IAAI,EAAKI,YAEL,aAGE,EAAKe,yBAGRH,GAAQC,EAAAA,EAAAA,GAAsC,aAEjDG,EAAAA,EAAAA,IAAcJ,IAEd,EAAKK,UAAUL,EAClB,GA/B0C,EAgC/C,CAKOM,mBAAmBnB,GAEtBpD,KAAKoD,WAAaA,CACtB,CAKOoB,oBAEHxE,KAAKkD,eAAeuB,eACxB,CAOUb,SAEV,CAKUG,YAEV,CAKUK,kBAEV,CAMUE,UAAUI,GAEpB,CAKUnD,eAEV,CAKUmC,YAEV,mCAvMkBtD,GAAmB,gCAgDjBF,EAAAA,GAAM,uBAhDRE,EAAmB,6ECHnC,MAAOuE,UAAkCC,EAAAA,EAcxBhB,SAEf5D,KAAK6E,eACT,CAKmBT,kBAEfpE,KAAK6E,eACT,CAOUA,gBAEN,MAAMrD,EAAUxB,KAAKwB,QACfsD,EAAQ9E,KAAK+C,SAASgC,cAAcD,MAE1C,GAAG9E,KAAK+C,QACR,CACI,IAAGiC,EAAAA,EAAAA,IAAUhF,KAAKiF,cAEd,IAAI,MAAMC,KAAYlF,KAAKiF,aAAaE,MAAM,KAEvCD,GAEClF,KAAK+C,QAAQgC,cAAcK,UAAUC,OAAOH,GAOxD,GAFAlF,KAAKiF,aAAezD,GAAS0D,SAE1B1D,GAAS0D,SAER,IAAI,MAAMA,KAAY1D,EAAQ0D,SAASC,MAAM,KAEtCD,GAEClF,KAAK+C,SAASgC,cAAcK,UAAUE,IAAIJ,IAMvDF,EAAAA,EAAAA,IAAUF,KAENtD,GAAS+D,UAELP,EAAAA,EAAAA,IAAUxD,EAAQ+D,OAAOC,UAExBV,EAAMW,aAAejE,EAAQ+D,OAAOC,SAGrCR,EAAAA,EAAAA,IAAUxD,EAAQ+D,OAAOG,SAExBZ,EAAMa,YAAcnE,EAAQ+D,OAAOG,QAGpCV,EAAAA,EAAAA,IAAUxD,EAAQ+D,OAAOK,OAExBd,EAAMe,UAAYrE,EAAQ+D,OAAOK,MAGlCZ,EAAAA,EAAAA,IAAUxD,EAAQ+D,OAAOO,QAExBhB,EAAMiB,WAAavE,EAAQ+D,OAAOO,OAIvCtE,GAASwE,WAELhB,EAAAA,EAAAA,IAAUxD,EAAQwE,QAAQR,UAEzBV,EAAMmB,cAAgBzE,EAAQwE,QAAQR,SAGvCR,EAAAA,EAAAA,IAAUxD,EAAQwE,QAAQN,SAEzBZ,EAAMoB,aAAe1E,EAAQwE,QAAQN,QAGtCV,EAAAA,EAAAA,IAAUxD,EAAQwE,QAAQJ,OAEzBd,EAAMqB,WAAa3E,EAAQwE,QAAQJ,MAGpCZ,EAAAA,EAAAA,IAAUxD,EAAQwE,QAAQF,QAEzBhB,EAAMsB,YAAc5E,EAAQwE,QAAQF,OAIzCtE,GAAS6E,eAELrB,EAAAA,EAAAA,IAAUxD,EAAQ6E,YAAYC,YAE7BxB,EAAMwB,SAAW9E,EAAQ6E,YAAYC,WAGtCtB,EAAAA,EAAAA,IAAUxD,EAAQ6E,YAAYE,cAE7BzB,EAAMyB,WAAa/E,EAAQ6E,YAAYE,WAAWC,aAIlE,qFCxHE,SAAU9D,EAAclB,GAE1B,OAAO,SAASiF,EAAaC,GAEzB,MAAMC,EAAOD,EAEbE,OAAOC,eAAeJ,EACA,GAAGE,UACH,CACIG,IAAK,WAOD,OALI9G,KAAK,IAAI2G,aAET3G,KAAK,IAAI2G,WAAgB,IAAII,EAAAA,GAG1B/G,KAAK,IAAI2G,UACpB,IAG1BC,OAAOC,eAAeJ,EACAE,EACA,CACIG,IAAK,WAED,OAAO9G,KAAK,IAAI2G,IACpB,EACAK,IAAK,SAASpH,GAKV,GAHAI,KAAK,IAAI2G,KAAU/G,GACnBqH,EAAAA,EAAAA,IAAmBjH,KAAM2G,GAEtBnF,GAAS0F,KAERlH,KAAK,GAAG2G,WAAcQ,WAG1B,CACI,MAAMhE,EAAYnD,KAA+BoH,WAEjD,IAAIjE,EAEA,OAGJ,MAAMkE,EAAmBlE,EAAS2D,IAAIQ,EAAAA,GAChCpE,EAAiBC,EAAS2D,IAAIS,EAAAA,GAC9BC,EAAKH,EAAiBI,MAAMzH,MAElC,IAAIwH,EAEA,OAGJtE,EAAewE,aACf,CACIC,YAAaH,EACbI,WAAYjB,IAGxB,IAGvBnF,GAASqG,WAERC,EAAAA,EAAAA,IAAmBrB,EAAQE,EAEnC,CACJ,kMCzEM,MAAOoB,UAAuCnD,EAAAA,EAApDnF,kCAOc,KAAAuI,mBAA8C,KAK9C,KAAAX,iBAAmD,IAwCjE,CAjC6BzD,SAAM,kCAEvB,EAAKT,UAAa,EAAK8E,UAAa,EAAKC,WAK7C,EAAKF,qBAAL,EAAKA,mBAAuB,EAAK7E,SAAS2D,IAAIqB,EAAAA,EAAoB,OAClE,EAAKd,mBAAL,EAAKA,iBAAqB,EAAKlE,SAAS2D,IAAIQ,EAAAA,EAA2B,OAEnE,EAAKU,oBAAuB,EAAKX,mBAKrC,EAAKA,iBAAiBe,kBAAkB,EAAKH,SAAST,GAAI,EAAKU,gBACzD,EAAKF,mBAAmB3E,YAC9B,EAAK2E,mBAAmBK,gBAAgB,EAAKJ,SAAST,KAAI,kLAC9D,CAKmB9D,YAEX1D,KAAKgI,oBAAuBhI,KAAKqH,kBAAqBrH,KAAKiI,WAK/DjI,KAAKgI,mBAAmBM,iBAAiBtI,KAAKiI,SAAST,IACvDxH,KAAKqH,iBAAiBkB,oBAAoBvI,KAAKiI,SAAST,IAC5D,iWCnDE,MAAgB5C,EA8BlBnF,YAAsBwI,GAAA,KAAAA,SAAAA,EAHZ,KAAA5E,aAAuB,CAKjC,CAOaS,WAAWX,EAAoBJ,EAAkCmF,GAAmB,iCAE7F,EAAK7E,aAAc,EAEnB,EAAKF,SAAWA,EAChB,EAAKJ,QAAUA,EACf,EAAKmF,SAAWA,QAEV,EAAKtE,QAAS,GARyE,EASjG,CAKaO,cAAc3C,GAAiB,iCAExC,EAAKA,QAAUA,EAEX,EAAK6B,oBAKH,EAAKe,kBAAkB,GATW,EAU5C,CAKOX,UAEHzD,KAAK0D,WACT,CAOUE,SAEV,CAKUQ,kBAEV,CAKUV,YAEV,sGC1FE,MAAO8E,EAGX/I,YACYgJ,EAA6CC,GAA7C,KAAAD,kBAAAA,EAA6C,KAAAC,aAAAA,EAHjD,KAAAC,UAAW,CAG0E,CAE7FC,SACE5I,KAAK2I,UAAW,EAChB3I,KAAKyI,kBAAkBI,mBAAmB7I,KAAK0I,aACjD,CAEAjF,UACEzD,KAAK2I,UAAW,EAChB3I,KAAKyI,kBAAkBK,OACzB,CAEAC,aAAaC,GACPA,IAAYhJ,KAAK2I,SACnB3I,KAAK4I,UACKI,GAAWhJ,KAAK2I,UAC1B3I,KAAKyD,SAET,EAyEI,MAAOwF,EAJbxJ,cAKU,KAAAyJ,cAA8B,GAC9B,KAAAC,cAAe,EACf,KAAAC,WAAa,EACb,KAAAC,oBAAsB,EACtB,KAAAC,mBAAoB,EAIxBC,aAASC,GACXxJ,KAAKyJ,UAAYD,EACO,IAApBxJ,KAAKoJ,YACPpJ,KAAK0J,qBAAoB,EAE7B,CAGAC,WACE,OAAO3J,KAAKoJ,YACd,CAGAQ,YAAYC,GACV7J,KAAKkJ,cAAcY,KAAKD,EAC1B,CAGAE,WAAWnK,GACT,MAAMoK,EAAUpK,GAASI,KAAKyJ,UAQ9B,OAPAzJ,KAAKsJ,kBAAoBtJ,KAAKsJ,mBAAqBU,EACnDhK,KAAKqJ,sBACDrJ,KAAKqJ,sBAAwBrJ,KAAKoJ,aACpCpJ,KAAK0J,qBAAqB1J,KAAKsJ,mBAC/BtJ,KAAKqJ,oBAAsB,EAC3BrJ,KAAKsJ,mBAAoB,GAEpBU,CACT,CAEQN,oBAAoBO,GAC1B,GAAIjK,KAAKkJ,cAAcgB,OAAS,GAAKD,IAAejK,KAAKmJ,aAAc,CACrEnJ,KAAKmJ,aAAec,EACpB,IAAK,MAAME,KAAenK,KAAKkJ,cAC7BiB,EAAYpB,aAAakB,GAG/B,uIAwCI,MAAOG,EAOX3K,YACI4K,EAAiCC,EACLf,GAAA,KAAAA,SAAAA,EAK9BA,EAASI,WACT3J,KAAKuK,MAAQ,IAAI/B,EAAW6B,EAAeC,EAC7C,CAMAE,YACExK,KAAKuK,MAAMxB,aAAa/I,KAAKuJ,SAASQ,WAAW/J,KAAKyK,cACxD,sCAxBW,IAAYC,EAAAA,IAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,EAAAA,GAAA,sBAAZ,wFA6CP,MAAOC,EACXlL,YACI4K,EAAiCC,EACbf,GAKtBA,EAASK,YAAY,IAAIpB,EAAW6B,EAAeC,GACrD,sCATW,IAAeI,EAAAA,IAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,EAAAA,GAAA,sBAAf,uEChMP,SAAUE,EACdC,GAEA,OAAO,cAAcA,EAQnBC,mBACE,MAAMC,EAAW/K,KAAKgL,WAChBC,EAASjL,KAAKkL,kBAAoBlL,KAAKmL,YACvCC,EAAUpL,KAAKqL,mBAAqBrL,KAAKsL,0BACzC/K,EAAUP,KAAKuL,UAAavL,KAAKuL,UAAUhL,QAA8B,KACzEiL,EAAWJ,EAAQK,aAAalL,EAAS0K,GAE3CO,IAAaT,IACf/K,KAAKgL,WAAaQ,EAClBxL,KAAK0L,aAAavE,OAEtB,CAEA1H,eAAekM,GACbrK,SAASqK,GApBX,KAAAX,YAAsB,CAqBtB,EAEJ,mEC7DM,MAAOY,EACXH,aAAalL,EAAiCsL,GAC5C,SAAUtL,GAAWA,EAAQuL,UAAYvL,EAAQwL,OAAUF,GAAQA,EAAKG,WAC1E,mCAHWJ,EAA4B,sBAA5BA,EAA4B,QAA5BA,EAA4B,OAQnC,MAAOK,EACXR,aAAalL,EAAiCsL,GAC5C,SAAUtL,GAAWA,EAAQuL,UAAYvL,EAAQ2L,SAAYL,GAAQA,EAAKG,WAC5E,mCAHWC,EAAiB,sBAAjBA,EAAiB,QAAjBA,EAAiB,gBADL,2FCVzB,IAAIE,EAAe,EAab,MAAOC,EAVb3M,cAYW,KAAA4M,MAAyB,QAGzB,KAAA7E,GAAa,gBAAgB2E,sCAL3BC,EAAO,oBAAPA,EAAO,wTCTd,MAAOE,oCAAAA,EAAQ,oBAARA,EAAQ,2GCCd,MAAMC,EAAa,IAAI5J,EAAAA,EAA0B,aAOlD,MAAO6J,EAJb/M,cAUE,KAAAgN,SAAU,EAJNC,oBAAgB9M,GAClBI,KAAKyM,SAAU,CACjB,mCAJWD,EAAS,oBAATA,EAAS,2JAFT,CAAC,CAACG,QAASJ,EAAYK,YAAaJ,yDCN3C,MAAgBK,oCAAAA,EAAmB,oBAAnBA,4KCJtB,IAAIV,EAAe,EAOZ,MAAMW,EAAY,IAAInK,EAAAA,EAAyB,YAYhD,MAAOoK,EAGXtN,YAAoCuN,EAAkBC,GAF7C,KAAAzF,GAAa,iBAAiB2E,IAKhCa,GACHC,EAAWlI,cAAcmI,aAAa,YAAa,SAEvD,mCATWH,GAAQ,IAGI,aAAW,8BAHvBA,EAAQ,uOAFR,CAAC,CAACJ,QAASG,EAAWF,YAAaG,uBCG1C,MAAOI,EAIX1N,YAAoB2N,GAAA,KAAAA,YAAAA,EAFX,KAAAC,UAAoB,CAE8B,CAG3DC,WACE,OAaJ,SAA6BvK,GAK3B,MAAMwK,EAASxK,EACf,GAA4B,OAAxBwK,EAAOC,aACT,OAAOD,EAAOE,YAGhB,MAAMC,EAAQH,EAAOI,WAAU,GAC/BD,EAAM5I,MAAM8I,YAAY,WAAY,YACpCF,EAAM5I,MAAM8I,YAAY,YAAa,+BACrCC,SAASC,gBAAgBC,YAAYL,GACrC,MAAMD,EAAcC,EAAMD,YAE1B,OADAC,EAAMrI,SACCoI,CACT,CA9BWO,CAAoBhO,KAAKoN,YAAYrI,cAC9C,CAGIhC,cACF,OAAO/C,KAAKoN,YAAYrI,aAC1B,mCAdWoI,GAAyB,8BAAzBA,EAAyB,oRCnBtC,MAAMc,EAAiB,0BAGjBC,EAAqB,gCAgBrB,MAAOC,EACX1O,YAAoB2N,EAAsCgB,GAAtC,KAAAhB,YAAAA,EAgBZ,KAAAiB,qBAAwBC,IAC9B,MAAMlJ,EAAYpF,KAAKoN,YAAYrI,cAAcK,UAC3CmJ,EAAiBnJ,EAAUoJ,SAASN,GAEf,YAAvBI,EAAMG,cAA8BF,GACtCnJ,EAAUC,OAAO4I,EAAgBC,IApBnCE,EAAOM,mBAAkB,KACvBtB,EAAYrI,cAAc4J,iBAAiB,gBAAiB3O,KAAKqO,qBAAqB,GAE1F,CAEAO,WACE,MAAMxJ,EAAYpF,KAAKoN,YAAYrI,cAAcK,UACjDA,EAAUC,OAAO6I,GACjB9I,EAAUE,IAAI2I,EAChB,CAEAY,aACE7O,KAAKoN,YAAYrI,cAAcK,UAAUE,IAAI4I,EAC/C,CAWA3K,cACEvD,KAAKoN,YAAYrI,cAAc+J,oBAAoB,gBAAiB9O,KAAKqO,qBAC3E,mCA5BWF,GAAsB,uCAAtBA,EAAsB,sHCM7B,MAAOY,EAOXtP,YAAoB2N,EAA8C4B,GAA9C,KAAA5B,YAAAA,EAA8C,KAAA4B,QAAAA,EALnB,KAAAC,WAAqB,EAG3B,KAAAC,MAAgB,CAE2B,CAEpFC,kBACE,MAAMC,EAAQpP,KAAKoN,YAAYrI,cAAcsK,cAA2B,uBACpED,GACFpP,KAAKoN,YAAYrI,cAAcK,UAAUE,IAAI,iCAER,mBAA1BgK,wBACTF,EAAMtK,MAAMyK,mBAAqB,KACjCvP,KAAKgP,QAAQN,mBAAkB,KAC7BY,uBAAsB,IAAOF,EAAMtK,MAAMyK,mBAAqB,IAAI,MAItEvP,KAAKoN,YAAYrI,cAAcK,UAAUE,IAAI,gCAEjD,CAEAkK,iBACE,GAAIxP,KAAKkP,KAAM,CACb,MAAMO,EAAwB,EACxBC,EAAuB,EAC7B,OAAO1P,KAAKiP,WAAa,EACrB,QAAQjP,KAAKiP,yEACXQ,EAAwBC,OAE1B,MAGN,OAAO,IACT,mCArCWX,GAA0B,uCAA1BA,EAA0B,+SAlBvC,+RCdiD,8CAHuB,sCCcjE,MAAMY,EAAa,IAAIhN,EAAAA,EAA0B,aAOlD,MAAOiN,EAJbnQ,cAUE,KAAAgN,SAAU,EAJNC,oBAAgB9M,GAClBI,KAAKyM,SAAU,CACjB,mCAJWmD,EAAS,oBAATA,EAAS,2JAFT,CAAC,CAACjD,QAASgD,EAAY/C,YAAagD,wDCA1C,MAAMC,EAET,CAEFC,oBAAoBC,EAAAA,EAAAA,IAAQ,qBAAsB,EAEhDC,EAAAA,EAAAA,IAAM,SAASlL,EAAAA,EAAAA,IAAM,CAACmL,QAAS,EAAGtQ,UAAW,qBAC7CuQ,EAAAA,EAAAA,IAAW,gBAAiB,EAC1BpL,EAAAA,EAAAA,IAAM,CAACmL,QAAS,EAAGtQ,UAAW,sBAC9BwQ,EAAAA,EAAAA,IAAQ,6QCmDd,oHC/CqF,kIAdvD,8BAA2B,4CAe/C,8DAjB+B,wFAKR,wFASoB,mBAG3C,GAH2C,8BAG3C,oDAhByB,wCA0BgE,oCAM7B,GAN6B,oCAM7B,oDAAf,mBAE7C,GAF6C,6DAE7C,+EALqD,qGAET,8DAO5C,6DAGA,oCAI4D,GAJ5D,oCAI4D,mDAAf,2DAQ7C,0DAGA,uCAGiD,kBASnD,GATmD,yCASnD,wEAF+C,mBAMqB,GANrB,2CAMqB,qEAAX,mBAIzD,GAJyD,gGAIzD,uGAJsB,gRDLjBC,GAAiB,IAAIzN,EAAAA,EAA6B,gBAMlD0N,GAAiC,IAAI1N,EAAAA,EAChD,kCAGF,IAAIwJ,GAAe,EAGnB,MAAMmE,GAA6C,OAS7CC,GAA4C,QAgD5C,MAAOC,GAoBPC,yBACF,OAAOzQ,KAAK0Q,mBACd,CACID,uBAAmB7Q,GACrBI,KAAK0Q,qBAAsBC,EAAAA,EAAAA,GAAsB/Q,EACnD,CAQIgR,iBACF,OAAO5Q,KAAK6Q,aAAe7Q,KAAK8Q,WAAWF,YArFH,MAsF1C,CACIA,eAAWhR,GACTA,IAAUI,KAAK6Q,cACjB7Q,KAAK6Q,YAAcjR,EAKnBI,KAAK+Q,mBAAmBrJ,eAE5B,CAKIsJ,iBACF,OAAOhR,KAAKiR,WACd,CACID,eAAWpR,GACb,MAAMS,EAAWL,KAAKiR,YAChBC,EAAgBtR,GAASI,KAAK8Q,WAAWE,YAAcV,GAQ7DtQ,KAAKiR,YAAcC,EACM,YAArBlR,KAAKiR,aAA6BjR,KAAKiR,cAAgB5Q,IACzDL,KAAKmR,4BAKLnR,KAAKoR,wCAAyC,EAElD,CASIC,sBACF,OAAOrR,KAAKsR,kBAAoBtR,KAAK8Q,WAAWO,iBAAmBd,EACrE,CACIc,oBAAgBzR,GAClBI,KAAKsR,iBAAmB1R,GAASI,KAAK8Q,WAAWO,iBAAmBd,EACtE,CAKIgB,gBACF,OAAOvR,KAAKwR,UACd,CACID,cAAU3R,GACZI,KAAKwR,WAAa5R,EAClBI,KAAKyR,eACP,CAqBIC,eACF,OAAO1R,KAAK2R,2BAA6B3R,KAAK4R,iBAChD,CACIF,aAAS9R,GACXI,KAAK2R,0BAA4B/R,CACnC,CAOAH,YACS2N,EACC2D,EACA/B,EACA6C,EACAC,EAGAhB,EAC0CiB,EACxBC,GATnB,KAAA5E,YAAAA,EACC,KAAA2D,mBAAAA,EACA,KAAA/B,QAAAA,EACA,KAAA6C,KAAAA,EACA,KAAAC,UAAAA,EAGA,KAAAhB,UAAAA,EAC0C,KAAAiB,eAAAA,EACxB,KAAAC,UAAAA,EAlHpB,KAAAtB,qBAAsB,EAGrB,KAAAuB,MAAsB,UA4CvB,KAAAhB,YAAsCX,GActC,KAAAgB,iBAA2C,KAW3C,KAAAE,WAAa,GAErB,KAAAU,gBAAiB,EACjB,KAAAC,gBAAiB,EACjB,KAAAC,gBAAiB,EACjB,KAAAC,gBAAiB,EAGR,KAAAC,SAAW,4BAA4BnG,KAGvC,KAAAoG,aAAe,gBAAgBpG,KAGxC,KAAAqG,yBAA2B,GAG3B,KAAAC,YAAc,EAUN,KAAAC,WAAa,IAAI3L,EAAAA,EACjB,KAAA4L,WAA6B,KAE7B,KAAAvB,wCAAyC,EAc3CN,IACEA,EAAUE,aACZhR,KAAKgR,WAAaF,EAAUE,YAE9BhR,KAAK0Q,oBAAsBkC,QAAQ9B,GAAWL,oBAC1CK,EAAUmB,QACZjS,KAAKiS,MAAQnB,EAAUmB,OAG7B,CAEA9C,kBAGEnP,KAAK6S,oBAGL7S,KAAKmR,4BAMDnR,KAAKgS,WAAWc,OAAOC,MACzB/S,KAAKgS,UAAUc,MAAMC,MAAMC,MAAK,KAC9BhT,KAAKmR,4BACLnR,KAAK+Q,mBAAmBrJ,cAAc,IAIxCuL,YAAW,IAAMjT,KAAKmR,6BAA6B,KAGrDnR,KAAKwS,yBAA2B,QAGhCxS,KAAK+Q,mBAAmBtM,eAC1B,CAEAyO,qBACElT,KAAKmT,0BACLnT,KAAKoT,qBACLpT,KAAKqT,uBACLrT,KAAKsT,6BACLtT,KAAKuT,4CACP,CAEAC,wBACExT,KAAKmT,yBACP,CAEA5P,cACEvD,KAAK0S,WAAWvL,OAChBnH,KAAK0S,WAAWe,UAClB,CAKAC,aACE,OAAO1T,KAAK2T,oBAAsB3T,KAAKsS,SAAW,IACpD,CAMAsB,4BACE,OAAO5T,KAAK6T,YAAc7T,KAAKoN,WACjC,CAGA0G,uBASM9T,KAAK2T,sBACP3T,KAAK4Q,WAAa,SAEtB,CAGQwC,qBACN,MAAM7S,EAAUP,KAAK0R,SAEjBnR,EAAQwT,aACV/T,KAAKoN,YAAYrI,cAAcK,UAAUE,IACvC,2BAA2B/E,EAAQwT,eAKvCxT,EAAQmL,aAAa1J,WAAU,KAC7BhC,KAAK6S,oBACL7S,KAAKgU,sBACLhU,KAAK+Q,mBAAmBrJ,cAAc,IAIpCnH,EAAQgL,WAAahL,EAAQgL,UAAUxJ,cACzCxB,EAAQgL,UAAUxJ,aACfkS,MAAKC,EAAAA,EAAAA,GAAUlU,KAAK0S,aACpB1Q,WAAU,IAAMhC,KAAK+Q,mBAAmBrJ,gBAE/C,CAEQyM,6BACNnU,KAAKkS,iBAAmBlS,KAAKoU,gBAAgBC,MAAKC,IAAMA,EAAE7H,UAC1DzM,KAAKmS,iBAAmBnS,KAAKoU,gBAAgBC,MAAKC,GAAKA,EAAE7H,UACzDzM,KAAKoS,iBAAmBpS,KAAKuU,gBAAgBF,MAAKG,IAAMA,EAAE/H,UAC1DzM,KAAKqS,iBAAmBrS,KAAKuU,gBAAgBF,MAAKG,GAAKA,EAAE/H,SAC3D,CAGQ6G,6BACNtT,KAAKmU,8BAILM,EAAAA,EAAAA,GAAMzU,KAAKoU,gBAAgBnQ,QAASjE,KAAKuU,gBAAgBtQ,SAASjC,WAAU,KAC1EhC,KAAKmU,6BACLnU,KAAK+Q,mBAAmBrJ,cAAc,GAE1C,CAOQ2L,uBAENrT,KAAK0U,cAAczQ,QAAQjC,WAAU,KACnChC,KAAKyR,gBACLzR,KAAK+Q,mBAAmBrJ,cAAc,IAIxC1H,KAAK2U,eAAe1Q,QAAQjC,WAAU,KACpChC,KAAKgU,sBACLhU,KAAK+Q,mBAAmBrJ,cAAc,IAIxC1H,KAAK4U,iBACL5U,KAAKgU,qBACP,CAGQb,0BACDnT,KAAK0R,QAGZ,CAEQmB,oBAMF7S,KAAK0R,SAASmD,UAAY7U,KAAK2S,YACjC3S,KAAK2S,YAAa,EAClB3S,KAAK8U,aAAalG,YACR5O,KAAK0R,SAASmD,UAAY7U,KAAK2S,YAAkC,OAApB3S,KAAK2S,aAC5D3S,KAAK2S,YAAa,EAClB3S,KAAK8U,aAAajG,cAGpB7O,KAAK6T,YAAY9O,cAAcK,UAAU2P,OACvC,0BACA/U,KAAK0R,SAASmD,QAElB,CAUQtB,6CAENvT,KAAKoU,gBAAgBnQ,QAAQjC,WAC3B,IAAOhC,KAAKoR,wCAAyC,IAKvDpR,KAAKgP,QAAQN,mBAAkB,KAC7B1O,KAAKgP,QAAQgG,SAASf,MAAKC,EAAAA,EAAAA,GAAUlU,KAAK0S,aAAa1Q,WAAU,KAC3DhC,KAAKoR,yCACPpR,KAAKoR,wCAAyC,EAC9CpR,KAAKiV,+BAEP,IAGJjV,KAAK6R,KAAKqD,OACPjB,MAAKC,EAAAA,EAAAA,GAAUlU,KAAK0S,aACpB1Q,WAAU,IAAOhC,KAAKoR,wCAAyC,GACpE,CAGA+D,qBACE,MAA2B,WAApBnV,KAAK4Q,UACd,CAEAwE,cACE,MAA2B,YAApBpV,KAAKgR,UACd,CAUAqE,0BACE,OAAQrV,KAAK8R,UAAUwD,WAAatV,KAAKoU,gBAAgBlK,SAAWlK,KAAKuV,mBAC3E,CAEA5B,oBACE,QAAS3T,KAAKwV,wBAA0BxV,KAAKyV,iBAC/C,CAEAF,oBACE,OAAOvV,KAAK0R,SAASgE,kBAAoB1V,KAAKmV,oBAChD,CAMAQ,eAAehP,GACb,MAAMpG,EAAUP,KAAK0R,SAAW1R,KAAK0R,SAASnG,UAAY,KAC1D,OAAOhL,GAAWA,EAAQoG,EAC5B,CAGAiP,wBACE,OAAO5V,KAAK2U,gBAAkB3U,KAAK2U,eAAezK,OAAS,GAAKlK,KAAK0R,SAAS1G,WAC1E,QACA,MACN,CAGAmG,4BACOnR,KAAKoV,eAAkBpV,KAAK6V,iBAGjC7V,KAAKyS,YAAczS,KAAK6V,eAAevI,WACzC,CAGQmE,gBACNzR,KAAK4U,iBACL5U,KAAKgU,qBACP,CAQQY,iBACF5U,KAAK0U,aAiBX,CAMQV,sBACN,GAAIhU,KAAK0R,SAAU,CACjB,IAAIoE,EAAgB,GAUpB,GANE9V,KAAK0R,SAASqE,qBAC+B,iBAAtC/V,KAAK0R,SAASqE,qBAErBD,EAAIhM,QAAQ9J,KAAK0R,SAASqE,oBAAoB5Q,MAAM,MAGjB,SAAjCnF,KAAK4V,wBAAoC,CAC3C,MAAMI,EAAYhW,KAAK0U,cACnB1U,KAAK0U,cAAcL,MAAK4B,GAAuB,UAAfA,EAAK5J,QACrC,KACE6J,EAAUlW,KAAK0U,cACjB1U,KAAK0U,cAAcL,MAAK4B,GAAuB,QAAfA,EAAK5J,QACrC,KAEA2J,EACFF,EAAIhM,KAAKkM,EAAUxO,IACVxH,KAAKwR,YACdsE,EAAIhM,KAAK9J,KAAKuS,cAGZ2D,GACFJ,EAAIhM,KAAKoM,EAAQ1O,SAEVxH,KAAK2U,gBACdmB,EAAIhM,QAAQ9J,KAAK2U,eAAewB,KAAIC,GAASA,EAAM5O,MAGrDxH,KAAK0R,SAAS2E,kBAAkBP,GAEpC,CAWQb,4BACN,IAAKjV,KAAK8R,UAAUwD,YAActV,KAAKoV,gBAAkBpV,KAAK6V,eAC5D,OAEF,MAAMS,EAAgBtW,KAAK6V,eAAe9S,QAG1C,IAAM/C,KAAKuW,uBAAwBvW,KAAKwW,qBAEtC,YADAF,EAAcxR,MAAMnF,UAAY,IAKlC,IAAKK,KAAKyW,mBAER,YADAzW,KAAKoR,wCAAyC,GAGhD,MAAMsF,EAAsB1W,KAAKuW,sBAAsBxR,cACjD4R,EAAsB3W,KAAKwW,sBAAsBzR,cACjD6R,EAA2BF,GAAqBG,wBAAwBC,OAAS,EACjFC,EAA2BJ,GAAqBE,wBAAwBC,OAAS,EAMjFE,EAAwB,QAHK,QAApBhX,KAAK6R,KAAKjS,MAAkB,KAAO,UAC3BgX,EAA2BG,wDAOlDT,EAAcxR,MAAMnF,UAAY,4FAE4BqX,WAE9D,CAGQP,mBACN,MAAM1T,EAAuB/C,KAAKoN,YAAYrI,cAC9C,GAAIhC,EAAQkU,YAAa,CACvB,MAAMC,EAAWnU,EAAQkU,cAGzB,OAAOC,GAAYA,IAAanU,EAIlC,OAAO8K,SAASC,gBAAiBU,SAASzL,EAC5C,oCAxhBWyN,IAAY,kDAyIbH,GAA8B,OAElB8G,EAAAA,GAAqB,OACjCC,EAAAA,GAAQ,qBA5IP5G,GAAY,8DAgBC,GAhBD,aAUTlE,EAAAA,EAAQ,UACRA,EAAAA,EAAU,UACVO,EAAAA,EAAmB,UAChB8C,EAAY,UACZpD,EAAAA,EAAY,UACZO,EAAW,UACXV,EAAAA,EAAS,IAAF,uUARS,+CAFtBe,EAAyB,QACzB4B,EAA0B,QAC1BZ,EAAsB,8jDAVtB,CAAC,CAACxB,QAASyD,GAAgBxD,YAAa4D,OAAc,mBC/DrC,kMD+DqC,44DC9GxB,8BAAiC,2UAoDtE,6DAzD8C,wtBAkDgB,gBCQpE6G,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,GAAAA,GAAAA,GAAAA,GAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAA,mogCF0Bc,CAACxH,EAAuBC,qBAAmB,gHGrFnD,MAAOwH,oCAAAA,EAAkB,oBAAlBA,0BAdDC,EAAAA,GAAiBC,EAAAA,EAAcC,EAAAA,GACkCF,EAAAA","sources":["webpack://ng-universal-demo/../../../forms/src/modules/formPipes/pipes/asFormControl/asFormControl.pipe.ts","webpack://ng-universal-demo/../../../form/src/components/formComponentBase/formComponentBase.ts","webpack://ng-universal-demo/../../../form/src/misc/tokens.ts","webpack://ng-universal-demo/../../../layout-editor/src/decorators/layoutEditorMetadata/layoutEditorMetadata.decorator.ts","webpack://ng-universal-demo/../../../layout/src/components/layoutComponentBase/layoutComponentBase.ts","webpack://ng-universal-demo/../../../layout/src/extensions/componentStyling/componentStyling.extension.ts","webpack://ng-universal-demo/../../../relations/src/decorators/dynamicOutput/dynamicOutput.decorator.ts","webpack://ng-universal-demo/../../../relations/src/extensions/relationsRegistration/relationsRegistration.extension.ts","webpack://ng-universal-demo/../../../src/misc/dynamicItemExtensionBase.ts","webpack://ng-universal-demo/../../../packages/common/src/directives/ng_switch.ts","webpack://ng-universal-demo/../../../src/material/core/common-behaviors/error-state.ts","webpack://ng-universal-demo/../../../src/material/core/error/error-options.ts","webpack://ng-universal-demo/../../../src/material/form-field/directives/hint.ts","webpack://ng-universal-demo/../../../src/material/form-field/directives/label.ts","webpack://ng-universal-demo/../../../src/material/form-field/directives/suffix.ts","webpack://ng-universal-demo/../../../src/material/form-field/form-field-control.ts","webpack://ng-universal-demo/../../../src/material/form-field/directives/error.ts","webpack://ng-universal-demo/../../../src/material/form-field/directives/floating-label.ts","webpack://ng-universal-demo/../../../src/material/form-field/directives/line-ripple.ts","webpack://ng-universal-demo/../../../src/material/form-field/directives/notched-outline.ts","webpack://ng-universal-demo/../src/material/form-field/directives/notched-outline.html","webpack://ng-universal-demo/../../../src/material/form-field/directives/prefix.ts","webpack://ng-universal-demo/../../../src/material/form-field/form-field-animations.ts","webpack://ng-universal-demo/../../../src/material/form-field/form-field.ts","webpack://ng-universal-demo/../src/material/form-field/form-field.html","webpack://ng-universal-demo/../../../src/material/form-field/form-field.html","webpack://ng-universal-demo/../../../src/material/form-field/module.ts"],"sourcesContent":["import {Inject, Optional, Pipe} from '@angular/core';\nimport {AbstractControl, FormControl} from '@angular/forms';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {isBlank} from '@jscrpt/common';\n\n/**\n * Tries to convert `AbstractControl` to `FormControl`\n */\n@Pipe({name: 'asFormControl'})\nexport class AsFormControlPipe\n{\n    //######################### constructors #########################\n    constructor(@Optional() @Inject(LOGGER) private _logger?: Logger)\n    {\n    }\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Allows casting of `AbstractControl` to `FormControl`\n     * @param value - `AbstractControl` to be cast to `FormControl`\n     * @param _valueHash - Parameter that can be used to change value, indicates that pipe input value has changed\n     */\n    public transform<TModel>(value: AbstractControl<TModel>|null|undefined, _valueHash?: any): FormControl<TModel>|null\n    {\n        if(isBlank(value))\n        {\n            return null;\n        }\n\n        if(value instanceof FormControl)\n        {\n            return value as FormControl<TModel>;\n        }\n\n        this._logger?.warn('Failed to cast AbstractControl to FormControl');\n\n        return null;\n    }\n}","import {ChangeDetectorRef, Directive, ElementRef, Inject, Injector, Input, Optional} from '@angular/core';\nimport {AbstractControl, FormControl, Validators} from '@angular/forms';\nimport {LayoutComponentBase} from '@anglr/dynamic/layout';\nimport {LOGGER, Logger} from '@anglr/common';\nimport {DynamicOutput} from '@anglr/dynamic/relations';\nimport {PromiseOr} from '@jscrpt/common';\nimport {Subscription} from 'rxjs';\n\nimport {FORM_COMPONENT_CONTROL} from '../../misc/tokens';\nimport {FormComponentOptions} from '../../misc/formComponentBase.options';\nimport {FormComponentControlType} from '../../misc/enums';\nimport {getControlForType, getFormControl} from '../../misc/utils';\n\n/**\n * Base component for form component\n */\n@Directive()\nexport abstract class FormComponentBase<TOptions extends FormComponentOptions, TValue = string> extends LayoutComponentBase<TOptions>\n{\n    //######################### private properties #########################\n\n    /**\n     * Indication whether form component is required\n     */\n    private _required: boolean|null|undefined;\n\n    /**\n     * Indication whether form component is disabled\n     */\n    private _disabled: boolean|null|undefined;\n\n    //######################### protected properties #########################\n\n    /**\n     * Form component control\n     */\n    protected control: AbstractControl = new FormControl();\n\n    /**\n     * Form component control subscriptions\n     */\n    protected controlSubscription: Subscription|null|undefined;\n\n    //######################### public properties - inputs #########################\n\n    /**\n     * Form component value\n     */\n    @Input()\n    public set value(value: TValue|null|undefined)\n    {\n        const oldValue = this.value;\n        this.valueOutput = value;\n\n        if (value !== oldValue)\n        {\n            this.control?.patchValue(value);\n        }\n    }\n    public get value(): TValue|null|undefined\n    {\n        return this.valueOutput;\n    }\n\n    /**\n     * Indication whether form component is required\n     */\n    @Input()\n    public set required(value: boolean|null|undefined)\n    {\n        this._required = value;\n\n        if (value === true)\n        {\n            this.control?.addValidators(Validators.required);\n            return;\n        }\n\n        this.control?.removeValidators(Validators.required);\n    }\n    public get required(): boolean|null|undefined\n    {\n        return this._required;\n    }\n\n    /**\n     * Indication whether form component is disabled\n     */\n    @Input()\n    public set disabled(value: boolean|null|undefined)\n    {\n        this._disabled = value;\n\n        if (value === true)\n        {\n            this.control?.disable();\n            return;\n        }\n\n        this.control?.enable();\n    }\n    public get disabled(): boolean|null|undefined\n    {\n        return this._disabled;\n    }\n\n    //######################### public properties - dynamicOutputs #########################\n\n    /**\n     * Form component value\n     */\n    @DynamicOutput()\n    public valueOutput: TValue|null|undefined;\n\n    //######################### constructor #########################\n\n    constructor(_changeDetector: ChangeDetectorRef,\n                _element: ElementRef<HTMLElement>,\n                _injector: Injector,\n                @Inject(FORM_COMPONENT_CONTROL) @Optional() protected _parentControl?: AbstractControl,\n                @Inject(LOGGER) @Optional() _logger?: Logger,)\n    {\n        super(_changeDetector, _element, _injector, _logger);\n    }\n\n    //######################### protected methods - _onOptionsSet implementation #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override onOptionsSet(): PromiseOr<void> \n    {\n        if(!this.options)\n        {\n            return;\n        }\n\n        this.controlSubscription?.unsubscribe();\n        this.controlSubscription = null;\n\n        this.control = this._getFormControl(this.options?.controlName, this._parentControl, FormComponentControlType.FormControl, this.value); \n        this._registerValidations();\n\n        this.controlSubscription = this.control\n            ?.valueChanges\n            ?.subscribe(value => \n            {\n                this.valueOutput = value;\n            });\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Registers component-specific validators\n     */\n    protected _registerValidations(): void\n    {}\n\n    //######################### private methods #########################\n\n    /**\n     * Gets form component control for control name\n     * @param controlName Form component control name\n     * @param parentControl Parent form control\n     * @param defaultControlType Default control type when parent does not exists or not contains control with specified name\n     * @param initValue Initial value for control\n     * @returns Specified type of control\n     */\n    private _getFormControl(controlName: string|null|undefined, parentControl: AbstractControl|undefined, defaultControlType: FormComponentControlType = FormComponentControlType.FormControl, initValue: TValue|null|undefined): AbstractControl\n    {\n        let control = getFormControl(controlName, parentControl, defaultControlType, initValue);\n\n        if (!control)\n        {\n            this.logger?.warn('FormComponentBase: Unable to find control with name {@name}', {name: controlName});\n\n            control = getControlForType(defaultControlType, initValue);\n        }\n\n        if (this.required)\n        {\n            control.addValidators(Validators.required);\n        }\n\n        if (this.disabled)\n        {\n            control.disable();\n        }\n\n        return control;\n    }\n}","import {InjectionToken} from '@angular/core';\nimport {AbstractControl} from '@angular/forms';\n\n/**\n * Injection token for form component control\n */\nexport const FORM_COMPONENT_CONTROL : InjectionToken<AbstractControl> = new InjectionToken<AbstractControl>('FORM_COMPONENT_CONTROL');","import {DynamicClassMetadata, DynamicMetadataLoader} from '@anglr/dynamic';\n\nimport {LayoutEditorMetadataDescriptor, LayoutEditorMetadataType} from '../../decorators';\n\n/**\n * Sets layout editor metadata to class on which is this decorator applied\n * @param metadataLoader - Layout editor metadata loader function used for obtaining metadata\n */\nexport function LayoutEditorMetadata(metadataLoader: DynamicMetadataLoader<LayoutEditorMetadataDescriptor>): ClassDecorator\n{\n    return DynamicClassMetadata<LayoutEditorMetadataDescriptor, LayoutEditorMetadataType>(metadataLoader, 'layoutEditorMetadata');\n}","import {ChangeDetectorRef, Directive, ElementRef, Inject, Injector, OnDestroy, Optional, SimpleChanges} from '@angular/core';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {DynamicItemExtension} from '@anglr/dynamic';\nimport {isEmptyObject, nameof, PromiseOr} from '@jscrpt/common';\n\nimport {LayoutComponent} from '../../interfaces';\n\n/**\n * Base component for layout component\n */\n@Directive()\nexport abstract class LayoutComponentBase<TOptions> implements LayoutComponent<TOptions>, OnDestroy\n{\n    //######################### protected fields #########################\n\n    /**\n     * Array of extensions that are registered for component\n     */\n    protected extensions: DynamicItemExtension<TOptions>[] = [];\n\n    /**\n     * Indication whether initialization was already done\n     */\n    protected initialized: boolean = false;\n\n    /**\n     * Indication whether was component destroyed\n     */\n    protected destroyed: boolean = false;\n\n    //######################### protected properties #########################\n\n    /**\n     * Gets element that is used within extension\n     */\n    protected get element(): ElementRef<HTMLElement>\n    {\n        return this.componentElement;\n    }\n\n    /**\n     * Gets options that are used within extension\n     */\n    protected get extensionsOptions(): any|undefined|null\n    {\n        return this.options;\n    }\n\n    //######################### public properties - implementation of LayoutComponent #########################\n\n    /**\n     * @inheritdoc\n     */\n    public options: TOptions|undefined|null;\n\n    //######################### constructor #########################\n    constructor(protected changeDetector: ChangeDetectorRef,\n                protected componentElement: ElementRef<HTMLElement>,\n                protected injector: Injector,\n                @Inject(LOGGER) @Optional() protected logger?: Logger,)\n    {\n    }\n\n    //######################### public methods - implementation of OnDestroy #########################\n    \n    /**\n     * Called when component is destroyed\n     */\n    public ngOnDestroy(): void\n    {\n        if(this.destroyed)\n        {\n            return;\n        }\n\n        this.destroyed = true;\n\n        for(const ext of this.extensions)\n        {\n            ext.destroy();\n        }\n\n        this.onDestroy();\n    }\n\n    //######################### public methods - implementation of LayoutComponent #########################\n\n    /**\n     * @inheritdoc\n     */\n    public async ngOnInit(): Promise<void>\n    {\n        if(this.initialized)\n        {\n            return;\n        }\n\n        this.initialized = true;\n        const extensionsOptions = this.extensionsOptions;\n        \n        await this.onInit();\n        await this.onOptionsSet();\n\n        if(extensionsOptions)\n        {\n            for(const extension of this.extensions)\n            {\n                await extension.initialize(this.injector, this.element, this);\n            }\n        }\n\n        await this.afterInit();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public async ngOnChanges(changes: SimpleChanges): Promise<void>\n    {\n        //options has changed\n        if(nameof<LayoutComponentBase<TOptions>>('options') in changes)\n        {\n            await this.onOptionsSet();\n\n            const extensionsOptions = this.extensionsOptions;\n\n            //set options in extensions\n            if(extensionsOptions)\n            {\n                for(const extension of this.extensions)\n                {\n                    await extension.optionsChange(extensionsOptions);\n                }\n            }\n\n            if(!this.initialized)\n            {\n                return;\n            }\n\n            await this.onOptionsChange();\n        }\n\n        delete changes[nameof<LayoutComponentBase<TOptions>>('options')];\n\n        if(!isEmptyObject(changes))\n        {\n            this.onChanges(changes);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public registerExtensions(extensions: DynamicItemExtension[]): void\n    {\n        this.extensions = extensions;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public invalidateVisuals(): void\n    {\n        this.changeDetector.detectChanges();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Called on initialzation of component, options are already set\n     */\n    protected onInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called right after initialization finished, including extesions\n     */\n    protected afterInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on change of options, after initialization\n     */\n    protected onOptionsChange(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Occurs when some property changes on component\n     * @param _changes - Changes that occured on component\n     */\n    protected onChanges(_changes: SimpleChanges): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called everytime options are set, after initialization and later\n     */\n    protected onOptionsSet(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called when component is being destroyed\n     */\n    protected onDestroy(): void\n    {\n    }\n}","import {DynamicItemExtension, DynamicItemExtensionBase} from '@anglr/dynamic';\nimport {isPresent} from '@jscrpt/common';\n\nimport {ComponentStylingOptions} from '../../interfaces';\n\n/**\n * Extension that applies common component styling to component\n */\nexport class ComponentStylingExtension extends DynamicItemExtensionBase<ComponentStylingOptions> implements DynamicItemExtension<ComponentStylingOptions>\n{\n    //######################### protected properties #########################\n\n    /**\n     * Value of last css class\n     */\n    protected lastCssClass: string|undefined|null;\n\n    //######################### public methods - overrides #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override onInit(): void\n    {\n        this._applyStyling();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected override onOptionsChange(): void\n    {\n        this._applyStyling();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Applies component styling to element\n     */\n    protected _applyStyling(): void\n    {\n        const options = this.options;\n        const style = this.element?.nativeElement.style;\n\n        if(this.element)\n        {\n            if(isPresent(this.lastCssClass))\n            {\n                for(const cssClass of this.lastCssClass.split(' '))\n                {\n                    if(cssClass)\n                    {\n                        this.element.nativeElement.classList.remove(cssClass);\n                    }\n                }\n            }\n\n            this.lastCssClass = options?.cssClass;\n\n            if(options?.cssClass)\n            {\n                for(const cssClass of options.cssClass.split(' '))\n                {\n                    if(cssClass)\n                    {\n                        this.element?.nativeElement.classList.add(cssClass);\n                    }\n                }\n            }\n        }\n\n        if(isPresent(style))\n        {\n            if(options?.margin)\n            {\n                if(isPresent(options.margin.bottom))\n                {\n                    style.marginBottom = options.margin.bottom;\n                }\n\n                if(isPresent(options.margin.right))\n                {\n                    style.marginRight = options.margin.right;\n                }\n\n                if(isPresent(options.margin.top))\n                {\n                    style.marginTop = options.margin.top;\n                }\n\n                if(isPresent(options.margin.left))\n                {\n                    style.marginLeft = options.margin.left;\n                }\n            }\n\n            if(options?.padding)\n            {\n                if(isPresent(options.padding.bottom))\n                {\n                    style.paddingBottom = options.padding.bottom;\n                }\n\n                if(isPresent(options.padding.right))\n                {\n                    style.paddingRight = options.padding.right;\n                }\n\n                if(isPresent(options.padding.top))\n                {\n                    style.paddingTop = options.padding.top;\n                }\n\n                if(isPresent(options.padding.left))\n                {\n                    style.paddingLeft = options.padding.left;\n                }\n            }\n\n            if(options?.textStyling)\n            {\n                if(isPresent(options.textStyling.fontSize))\n                {\n                    style.fontSize = options.textStyling.fontSize;\n                }\n\n                if(isPresent(options.textStyling.fontWeight))\n                {\n                    style.fontWeight = options.textStyling.fontWeight.toString();\n                }\n            }\n        }\n    }\n}","import {Subject} from 'rxjs';\n\nimport {defineAssignedProp, defineSkipInitProp} from '../../misc/utils';\nimport {RelationsChangeDetector, RelationsComponentManager} from '../../services';\nimport {RelationsWithInjector} from '../../services/relationsChangeDetector/relationsChangeDetector.interface';\n\n/**\n * Creates dynamic output for property\n * @param options - Options that allows configure dynamic output\n *\n * `skipInit` - Means that there will be no initial data transfer for this output\n * `sync` - Means that changes will be transfered synchronously, right away\n */\nexport function DynamicOutput(options?: {skipInit?: boolean; sync?: boolean}): PropertyDecorator\n{\n    return function(target: any, propertyKey: string|symbol)\n    {\n        const prop = propertyKey as string;\n\n        Object.defineProperty(target,\n                              `${prop}Change`,\n                              {\n                                  get: function()\n                                  {\n                                      if(!this[`ɵ${prop}Change`])\n                                      {\n                                          this[`ɵ${prop}Change`] = new Subject<void>();\n                                      }\n\n                                      return this[`ɵ${prop}Change`];\n                                  }\n                              });\n\n        Object.defineProperty(target,\n                              prop,\n                              {\n                                  get: function()\n                                  {\n                                      return this[`ɵ${prop}`];\n                                  },\n                                  set: function(value: any)\n                                  {\n                                      this[`ɵ${prop}`] = value;\n                                      defineAssignedProp(this, prop);\n\n                                      if(options?.sync)\n                                      {\n                                          this[`${prop}Change`].next();\n                                      }\n                                      else\n                                      {\n                                          const injector = (this as RelationsWithInjector).ɵɵinjector;\n\n                                          if(!injector)\n                                          {\n                                              return;\n                                          }\n\n                                          const componentManager = injector.get(RelationsComponentManager);\n                                          const changeDetector = injector.get(RelationsChangeDetector);\n                                          const id = componentManager.getId(this);\n\n                                          if(!id)\n                                          {\n                                              return;\n                                          }\n\n                                          changeDetector.markForCheck(\n                                          {\n                                              componentId: id,\n                                              outputName: prop,\n                                          });\n                                      }\n                                  }\n                              });\n\n        if(options?.skipInit)\n        {\n            defineSkipInitProp(target, prop);\n        }\n    };\n}","import {DynamicItemExtension, DynamicItemExtensionBase} from '@anglr/dynamic';\n\nimport {RelationsComponent} from '../../interfaces';\nimport {RelationsComponentManager, RelationsProcessor} from '../../services';\n\n/**\n * Extension that allows registration of component for relations\n */\nexport class RelationsRegistrationExtension extends DynamicItemExtensionBase<unknown, RelationsComponent> implements DynamicItemExtension<unknown, RelationsComponent>\n{\n    //######################### protected properties #########################\n\n    /**\n     * Instance of relations processor\n     */\n    protected relationsProcessor: RelationsProcessor|null = null;\n\n    /**\n     * Instance of component manager\n     */\n    protected componentManager: RelationsComponentManager|null = null;\n\n    //######################### public methods - overrides #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override async onInit(): Promise<void>\n    {\n        if(!this.injector || !this.metadata || !this.instance)\n        {\n            return;\n        }\n\n        this.relationsProcessor ??= this.injector.get(RelationsProcessor, null);\n        this.componentManager ??= this.injector.get(RelationsComponentManager, null);\n\n        if(!this.relationsProcessor || !this.componentManager)\n        {\n            return;\n        }\n\n        this.componentManager.registerComponent(this.metadata.id, this.instance);\n        await this.relationsProcessor.initialized;\n        this.relationsProcessor.updateRelations(this.metadata.id);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected override onDestroy(): void\n    {\n        if(!this.relationsProcessor || !this.componentManager || !this.metadata)\n        {\n            return;\n        }\n\n        this.relationsProcessor.destroyComponent(this.metadata.id);\n        this.componentManager.unregisterComponent(this.metadata.id);\n    }\n}","import {ElementRef, Injector} from '@angular/core';\nimport {PromiseOr} from '@jscrpt/common';\n\nimport {DynamicItem, DynamicItemExtension, DynamicItemMetadata} from '../interfaces';\n\n/**\n * Dynamic item extension base class\n */\nexport abstract class DynamicItemExtensionBase<TOptions = unknown, TInstance extends DynamicItem = any> implements DynamicItemExtension<TOptions, TInstance>\n{\n    //######################### protected fields #########################\n\n    /**\n     * Injector from extended component\n     */\n    protected injector?: Injector;\n\n    /**\n     * Element that could be extended\n     */\n    protected element?: ElementRef<HTMLElement>;\n\n    /**\n     * Options that stores extension and component data\n     */\n    protected options?: TOptions;\n\n    /**\n     * Instance of dynamic item that is being extended\n     */\n    protected instance?: TInstance;\n\n    /**\n     * Indication whether was extension initialized\n     */\n    protected initialized: boolean = false;\n\n    //######################### constructor #########################\n    constructor(protected metadata: DynamicItemMetadata)\n    {\n    }\n\n    //######################### public methods - implementation of DynamicItemExtension #########################\n\n    /**\n     * @inheritdoc\n     */\n    public async initialize(injector: Injector, element: ElementRef<HTMLElement>, instance: TInstance): Promise<void>\n    {\n        this.initialized = true;\n\n        this.injector = injector;\n        this.element = element;\n        this.instance = instance;\n\n        await this.onInit();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public async optionsChange(options: TOptions): Promise<void>\n    {\n        this.options = options;\n\n        if(!this.initialized)\n        {\n            return;\n        }\n\n        await this.onOptionsChange();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public destroy(): void\n    {\n        this.onDestroy();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Called on initialization of component\n     */\n    protected onInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on change of options of component\n     */\n    protected onOptionsChange(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on destruction of component\n     */\n    protected onDestroy(): void\n    {\n    }\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, DoCheck, Host, Input, Optional, TemplateRef, ViewContainerRef, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nexport class SwitchView {\n  private _created = false;\n\n  constructor(\n      private _viewContainerRef: ViewContainerRef, private _templateRef: TemplateRef<Object>) {}\n\n  create(): void {\n    this._created = true;\n    this._viewContainerRef.createEmbeddedView(this._templateRef);\n  }\n\n  destroy(): void {\n    this._created = false;\n    this._viewContainerRef.clear();\n  }\n\n  enforceState(created: boolean) {\n    if (created && !this._created) {\n      this.create();\n    } else if (!created && this._created) {\n      this.destroy();\n    }\n  }\n}\n\n/**\n * @ngModule CommonModule\n *\n * @description\n * The `[ngSwitch]` directive on a container specifies an expression to match against.\n * The expressions to match are provided by `ngSwitchCase` directives on views within the container.\n * - Every view that matches is rendered.\n * - If there are no matches, a view with the `ngSwitchDefault` directive is rendered.\n * - Elements within the `[NgSwitch]` statement but outside of any `NgSwitchCase`\n * or `ngSwitchDefault` directive are preserved at the location.\n *\n * @usageNotes\n * Define a container element for the directive, and specify the switch expression\n * to match against as an attribute:\n *\n * ```\n * <container-element [ngSwitch]=\"switch_expression\">\n * ```\n *\n * Within the container, `*ngSwitchCase` statements specify the match expressions\n * as attributes. Include `*ngSwitchDefault` as the final case.\n *\n * ```\n * <container-element [ngSwitch]=\"switch_expression\">\n *    <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n * ...\n *    <some-element *ngSwitchDefault>...</some-element>\n * </container-element>\n * ```\n *\n * ### Usage Examples\n *\n * The following example shows how to use more than one case to display the same view:\n *\n * ```\n * <container-element [ngSwitch]=\"switch_expression\">\n *   <!-- the same view can be shown in more than one case -->\n *   <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n *   <some-element *ngSwitchCase=\"match_expression_2\">...</some-element>\n *   <some-other-element *ngSwitchCase=\"match_expression_3\">...</some-other-element>\n *   <!--default case when there are no matches -->\n *   <some-element *ngSwitchDefault>...</some-element>\n * </container-element>\n * ```\n *\n * The following example shows how cases can be nested:\n * ```\n * <container-element [ngSwitch]=\"switch_expression\">\n *       <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n *       <some-element *ngSwitchCase=\"match_expression_2\">...</some-element>\n *       <some-other-element *ngSwitchCase=\"match_expression_3\">...</some-other-element>\n *       <ng-container *ngSwitchCase=\"match_expression_3\">\n *         <!-- use a ng-container to group multiple root nodes -->\n *         <inner-element></inner-element>\n *         <inner-other-element></inner-other-element>\n *       </ng-container>\n *       <some-element *ngSwitchDefault>...</some-element>\n *     </container-element>\n * ```\n *\n * @publicApi\n * @see `NgSwitchCase`\n * @see `NgSwitchDefault`\n * @see [Structural Directives](guide/structural-directives)\n *\n */\n@Directive({\n  selector: '[ngSwitch]',\n  standalone: true,\n})\nexport class NgSwitch {\n  private _defaultViews: SwitchView[] = [];\n  private _defaultUsed = false;\n  private _caseCount = 0;\n  private _lastCaseCheckIndex = 0;\n  private _lastCasesMatched = false;\n  private _ngSwitch: any;\n\n  @Input()\n  set ngSwitch(newValue: any) {\n    this._ngSwitch = newValue;\n    if (this._caseCount === 0) {\n      this._updateDefaultCases(true);\n    }\n  }\n\n  /** @internal */\n  _addCase(): number {\n    return this._caseCount++;\n  }\n\n  /** @internal */\n  _addDefault(view: SwitchView) {\n    this._defaultViews.push(view);\n  }\n\n  /** @internal */\n  _matchCase(value: any): boolean {\n    const matched = value == this._ngSwitch;\n    this._lastCasesMatched = this._lastCasesMatched || matched;\n    this._lastCaseCheckIndex++;\n    if (this._lastCaseCheckIndex === this._caseCount) {\n      this._updateDefaultCases(!this._lastCasesMatched);\n      this._lastCaseCheckIndex = 0;\n      this._lastCasesMatched = false;\n    }\n    return matched;\n  }\n\n  private _updateDefaultCases(useDefault: boolean) {\n    if (this._defaultViews.length > 0 && useDefault !== this._defaultUsed) {\n      this._defaultUsed = useDefault;\n      for (const defaultView of this._defaultViews) {\n        defaultView.enforceState(useDefault);\n      }\n    }\n  }\n}\n\n/**\n * @ngModule CommonModule\n *\n * @description\n * Provides a switch case expression to match against an enclosing `ngSwitch` expression.\n * When the expressions match, the given `NgSwitchCase` template is rendered.\n * If multiple match expressions match the switch expression value, all of them are displayed.\n *\n * @usageNotes\n *\n * Within a switch container, `*ngSwitchCase` statements specify the match expressions\n * as attributes. Include `*ngSwitchDefault` as the final case.\n *\n * ```\n * <container-element [ngSwitch]=\"switch_expression\">\n *   <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n *   ...\n *   <some-element *ngSwitchDefault>...</some-element>\n * </container-element>\n * ```\n *\n * Each switch-case statement contains an in-line HTML template or template reference\n * that defines the subtree to be selected if the value of the match expression\n * matches the value of the switch expression.\n *\n * Unlike JavaScript, which uses strict equality, Angular uses loose equality.\n * This means that the empty string, `\"\"` matches 0.\n *\n * @publicApi\n * @see `NgSwitch`\n * @see `NgSwitchDefault`\n *\n */\n@Directive({\n  selector: '[ngSwitchCase]',\n  standalone: true,\n})\nexport class NgSwitchCase implements DoCheck {\n  private _view: SwitchView;\n  /**\n   * Stores the HTML template to be selected on match.\n   */\n  @Input() ngSwitchCase: any;\n\n  constructor(\n      viewContainer: ViewContainerRef, templateRef: TemplateRef<Object>,\n      @Optional() @Host() private ngSwitch: NgSwitch) {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !ngSwitch) {\n      throwNgSwitchProviderNotFoundError('ngSwitchCase', 'NgSwitchCase');\n    }\n\n    ngSwitch._addCase();\n    this._view = new SwitchView(viewContainer, templateRef);\n  }\n\n  /**\n   * Performs case matching. For internal use only.\n   * @nodoc\n   */\n  ngDoCheck() {\n    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));\n  }\n}\n\n/**\n * @ngModule CommonModule\n *\n * @description\n *\n * Creates a view that is rendered when no `NgSwitchCase` expressions\n * match the `NgSwitch` expression.\n * This statement should be the final case in an `NgSwitch`.\n *\n * @publicApi\n * @see `NgSwitch`\n * @see `NgSwitchCase`\n *\n */\n@Directive({\n  selector: '[ngSwitchDefault]',\n  standalone: true,\n})\nexport class NgSwitchDefault {\n  constructor(\n      viewContainer: ViewContainerRef, templateRef: TemplateRef<Object>,\n      @Optional() @Host() ngSwitch: NgSwitch) {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !ngSwitch) {\n      throwNgSwitchProviderNotFoundError('ngSwitchDefault', 'NgSwitchDefault');\n    }\n\n    ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));\n  }\n}\n\nfunction throwNgSwitchProviderNotFoundError(attrName: string, directiveName: string): never {\n  throw new RuntimeError(\n      RuntimeErrorCode.PARENT_NG_SWITCH_NOT_FOUND,\n      `An element with the \"${attrName}\" attribute ` +\n          `(matching the \"${\n              directiveName}\" directive) must be located inside an element with the \"ngSwitch\" attribute ` +\n          `(matching \"NgSwitch\" directive)`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractControl, FormGroupDirective, NgControl, NgForm} from '@angular/forms';\nimport {Subject} from 'rxjs';\nimport {ErrorStateMatcher} from '../error/error-options';\nimport {AbstractConstructor, Constructor} from './constructor';\n\n/** @docs-private */\nexport interface CanUpdateErrorState {\n  /** Updates the error state based on the provided error state matcher. */\n  updateErrorState(): void;\n  /** Whether the component is in an error state. */\n  errorState: boolean;\n  /** An object used to control the error state of the component. */\n  errorStateMatcher: ErrorStateMatcher;\n}\n\ntype CanUpdateErrorStateCtor = Constructor<CanUpdateErrorState> &\n  AbstractConstructor<CanUpdateErrorState>;\n\n/** @docs-private */\nexport interface HasErrorState {\n  _parentFormGroup: FormGroupDirective;\n  _parentForm: NgForm;\n  _defaultErrorStateMatcher: ErrorStateMatcher;\n\n  // These properties are defined as per the `MatFormFieldControl` interface. Since\n  // this mixin is commonly used with custom form-field controls, we respect the\n  // properties (also with the public name they need according to `MatFormFieldControl`).\n  ngControl: NgControl;\n  stateChanges: Subject<void>;\n}\n\n/**\n * Mixin to augment a directive with updateErrorState method.\n * For component with `errorState` and need to update `errorState`.\n */\nexport function mixinErrorState<T extends AbstractConstructor<HasErrorState>>(\n  base: T,\n): CanUpdateErrorStateCtor & T;\nexport function mixinErrorState<T extends Constructor<HasErrorState>>(\n  base: T,\n): CanUpdateErrorStateCtor & T {\n  return class extends base {\n    /** Whether the component is in an error state. */\n    errorState: boolean = false;\n\n    /** An object used to control the error state of the component. */\n    errorStateMatcher: ErrorStateMatcher;\n\n    /** Updates the error state based on the provided error state matcher. */\n    updateErrorState() {\n      const oldState = this.errorState;\n      const parent = this._parentFormGroup || this._parentForm;\n      const matcher = this.errorStateMatcher || this._defaultErrorStateMatcher;\n      const control = this.ngControl ? (this.ngControl.control as AbstractControl) : null;\n      const newState = matcher.isErrorState(control, parent);\n\n      if (newState !== oldState) {\n        this.errorState = newState;\n        this.stateChanges.next();\n      }\n    }\n\n    constructor(...args: any[]) {\n      super(...args);\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {FormGroupDirective, NgForm, AbstractControl} from '@angular/forms';\n\n/** Error state matcher that matches when a control is invalid and dirty. */\n@Injectable()\nexport class ShowOnDirtyErrorStateMatcher implements ErrorStateMatcher {\n  isErrorState(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean {\n    return !!(control && control.invalid && (control.dirty || (form && form.submitted)));\n  }\n}\n\n/** Provider that defines how form controls behave with regards to displaying error messages. */\n@Injectable({providedIn: 'root'})\nexport class ErrorStateMatcher {\n  isErrorState(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean {\n    return !!(control && control.invalid && (control.touched || (form && form.submitted)));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, Input} from '@angular/core';\n\nlet nextUniqueId = 0;\n\n/** Hint text to be shown underneath the form field control. */\n@Directive({\n  selector: 'mat-hint',\n  host: {\n    'class': 'mat-mdc-form-field-hint mat-mdc-form-field-bottom-align',\n    '[class.mat-mdc-form-field-hint-end]': 'align === \"end\"',\n    '[id]': 'id',\n    // Remove align attribute to prevent it from interfering with layout.\n    '[attr.align]': 'null',\n  },\n})\nexport class MatHint {\n  /** Whether to align the hint label at the start or end of the line. */\n  @Input() align: 'start' | 'end' = 'start';\n\n  /** Unique ID for the hint. Used for the aria-describedby on the form field control. */\n  @Input() id: string = `mat-mdc-hint-${nextUniqueId++}`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive} from '@angular/core';\n\n/** The floating label for a `mat-form-field`. */\n@Directive({\n  selector: 'mat-label',\n})\nexport class MatLabel {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, InjectionToken, Input} from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `MatSuffix`. It serves as\n * alternative token to the actual `MatSuffix` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_SUFFIX = new InjectionToken<MatSuffix>('MatSuffix');\n\n/** Suffix to be placed at the end of the form field. */\n@Directive({\n  selector: '[matSuffix], [matIconSuffix], [matTextSuffix]',\n  providers: [{provide: MAT_SUFFIX, useExisting: MatSuffix}],\n})\nexport class MatSuffix {\n  @Input('matTextSuffix')\n  set _isTextSelector(value: '') {\n    this._isText = true;\n  }\n\n  _isText = false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\nimport {AbstractControlDirective, NgControl} from '@angular/forms';\nimport {Directive} from '@angular/core';\n\n/** An interface which allows a control to work inside of a `MatFormField`. */\n@Directive()\nexport abstract class MatFormFieldControl<T> {\n  /** The value of the control. */\n  value: T | null;\n\n  /**\n   * Stream that emits whenever the state of the control changes such that the parent `MatFormField`\n   * needs to run change detection.\n   */\n  readonly stateChanges: Observable<void>;\n\n  /** The element ID for this control. */\n  readonly id: string;\n\n  /** The placeholder for this control. */\n  readonly placeholder: string;\n\n  /** Gets the AbstractControlDirective for this control. */\n  readonly ngControl: NgControl | AbstractControlDirective | null;\n\n  /** Whether the control is focused. */\n  readonly focused: boolean;\n\n  /** Whether the control is empty. */\n  readonly empty: boolean;\n\n  /** Whether the `MatFormField` label should try to float. */\n  readonly shouldLabelFloat: boolean;\n\n  /** Whether the control is required. */\n  readonly required: boolean;\n\n  /** Whether the control is disabled. */\n  readonly disabled: boolean;\n\n  /** Whether the control is in an error state. */\n  readonly errorState: boolean;\n\n  /**\n   * An optional name for the control type that can be used to distinguish `mat-form-field` elements\n   * based on their control type. The form field will add a class,\n   * `mat-form-field-type-{{controlType}}` to its root element.\n   */\n  readonly controlType?: string;\n\n  /**\n   * Whether the input is currently in an autofilled state. If property is not present on the\n   * control it is assumed to be false.\n   */\n  readonly autofilled?: boolean;\n\n  /**\n   * Value of `aria-describedby` that should be merged with the described-by ids\n   * which are set by the form-field.\n   */\n  readonly userAriaDescribedBy?: string;\n\n  /** Sets the list of element IDs that currently describe this control. */\n  abstract setDescribedByIds(ids: string[]): void;\n\n  /** Handles a click on the control's container. */\n  abstract onContainerClick(event: MouseEvent): void;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Attribute, Directive, ElementRef, InjectionToken, Input} from '@angular/core';\n\nlet nextUniqueId = 0;\n\n/**\n * Injection token that can be used to reference instances of `MatError`. It serves as\n * alternative token to the actual `MatError` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_ERROR = new InjectionToken<MatError>('MatError');\n\n/** Single error message to be shown underneath the form-field. */\n@Directive({\n  selector: 'mat-error, [matError]',\n  host: {\n    'class': 'mat-mdc-form-field-error mat-mdc-form-field-bottom-align',\n    'aria-atomic': 'true',\n    '[id]': 'id',\n  },\n  providers: [{provide: MAT_ERROR, useExisting: MatError}],\n})\nexport class MatError {\n  @Input() id: string = `mat-mdc-error-${nextUniqueId++}`;\n\n  constructor(@Attribute('aria-live') ariaLive: string, elementRef: ElementRef) {\n    // If no aria-live value is set add 'polite' as a default. This is preferred over setting\n    // role='alert' so that screen readers do not interrupt the current task to read this aloud.\n    if (!ariaLive) {\n      elementRef.nativeElement.setAttribute('aria-live', 'polite');\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, Input} from '@angular/core';\n\n/**\n * Internal directive that maintains a MDC floating label. This directive does not\n * use the `MDCFloatingLabelFoundation` class, as it is not worth the size cost of\n * including it just to measure the label width and toggle some classes.\n *\n * The use of a directive allows us to conditionally render a floating label in the\n * template without having to manually manage instantiation and destruction of the\n * floating label component based on.\n *\n * The component is responsible for setting up the floating label styles, measuring label\n * width for the outline notch, and providing inputs that can be used to toggle the\n * label's floating or required state.\n */\n@Directive({\n  selector: 'label[matFormFieldFloatingLabel]',\n  host: {\n    'class': 'mdc-floating-label mat-mdc-floating-label',\n    '[class.mdc-floating-label--float-above]': 'floating',\n  },\n})\nexport class MatFormFieldFloatingLabel {\n  /** Whether the label is floating. */\n  @Input() floating: boolean = false;\n\n  constructor(private _elementRef: ElementRef<HTMLElement>) {}\n\n  /** Gets the width of the label. Used for the outline notch. */\n  getWidth(): number {\n    return estimateScrollWidth(this._elementRef.nativeElement);\n  }\n\n  /** Gets the HTML element for the floating label. */\n  get element(): HTMLElement {\n    return this._elementRef.nativeElement;\n  }\n}\n\n/**\n * Estimates the scroll width of an element.\n * via https://github.com/material-components/material-components-web/blob/c0a11ef0d000a098fd0c372be8f12d6a99302855/packages/mdc-dom/ponyfill.ts\n */\nfunction estimateScrollWidth(element: HTMLElement): number {\n  // Check the offsetParent. If the element inherits display: none from any\n  // parent, the offsetParent property will be null (see\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).\n  // This check ensures we only clone the node when necessary.\n  const htmlEl = element as HTMLElement;\n  if (htmlEl.offsetParent !== null) {\n    return htmlEl.scrollWidth;\n  }\n\n  const clone = htmlEl.cloneNode(true) as HTMLElement;\n  clone.style.setProperty('position', 'absolute');\n  clone.style.setProperty('transform', 'translate(-9999px, -9999px)');\n  document.documentElement.appendChild(clone);\n  const scrollWidth = clone.scrollWidth;\n  clone.remove();\n  return scrollWidth;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, NgZone, OnDestroy} from '@angular/core';\n\n/** Class added when the line ripple is active. */\nconst ACTIVATE_CLASS = 'mdc-line-ripple--active';\n\n/** Class added when the line ripple is being deactivated. */\nconst DEACTIVATING_CLASS = 'mdc-line-ripple--deactivating';\n\n/**\n * Internal directive that creates an instance of the MDC line-ripple component. Using a\n * directive allows us to conditionally render a line-ripple in the template without having\n * to manually create and destroy the `MDCLineRipple` component whenever the condition changes.\n *\n * The directive sets up the styles for the line-ripple and provides an API for activating\n * and deactivating the line-ripple.\n */\n@Directive({\n  selector: 'div[matFormFieldLineRipple]',\n  host: {\n    'class': 'mdc-line-ripple',\n  },\n})\nexport class MatFormFieldLineRipple implements OnDestroy {\n  constructor(private _elementRef: ElementRef<HTMLElement>, ngZone: NgZone) {\n    ngZone.runOutsideAngular(() => {\n      _elementRef.nativeElement.addEventListener('transitionend', this._handleTransitionEnd);\n    });\n  }\n\n  activate() {\n    const classList = this._elementRef.nativeElement.classList;\n    classList.remove(DEACTIVATING_CLASS);\n    classList.add(ACTIVATE_CLASS);\n  }\n\n  deactivate() {\n    this._elementRef.nativeElement.classList.add(DEACTIVATING_CLASS);\n  }\n\n  private _handleTransitionEnd = (event: TransitionEvent) => {\n    const classList = this._elementRef.nativeElement.classList;\n    const isDeactivating = classList.contains(DEACTIVATING_CLASS);\n\n    if (event.propertyName === 'opacity' && isDeactivating) {\n      classList.remove(ACTIVATE_CLASS, DEACTIVATING_CLASS);\n    }\n  };\n\n  ngOnDestroy() {\n    this._elementRef.nativeElement.removeEventListener('transitionend', this._handleTransitionEnd);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  Input,\n  NgZone,\n  ViewEncapsulation,\n} from '@angular/core';\n\n/**\n * Internal component that creates an instance of the MDC notched-outline component.\n *\n * The component sets up the HTML structure and styles for the notched-outline. It provides\n * inputs to toggle the notch state and width.\n */\n@Component({\n  selector: 'div[matFormFieldNotchedOutline]',\n  templateUrl: './notched-outline.html',\n  host: {\n    'class': 'mdc-notched-outline',\n    // Besides updating the notch state through the MDC component, we toggle this class through\n    // a host binding in order to ensure that the notched-outline renders correctly on the server.\n    '[class.mdc-notched-outline--notched]': 'open',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\nexport class MatFormFieldNotchedOutline implements AfterViewInit {\n  /** Width of the label (original scale) */\n  @Input('matFormFieldNotchedOutlineLabelWidth') labelWidth: number = 0;\n\n  /** Whether the notch should be opened. */\n  @Input('matFormFieldNotchedOutlineOpen') open: boolean = false;\n\n  constructor(private _elementRef: ElementRef<HTMLElement>, private _ngZone: NgZone) {}\n\n  ngAfterViewInit(): void {\n    const label = this._elementRef.nativeElement.querySelector<HTMLElement>('.mdc-floating-label');\n    if (label) {\n      this._elementRef.nativeElement.classList.add('mdc-notched-outline--upgraded');\n\n      if (typeof requestAnimationFrame === 'function') {\n        label.style.transitionDuration = '0s';\n        this._ngZone.runOutsideAngular(() => {\n          requestAnimationFrame(() => (label.style.transitionDuration = ''));\n        });\n      }\n    } else {\n      this._elementRef.nativeElement.classList.add('mdc-notched-outline--no-label');\n    }\n  }\n\n  _getNotchWidth() {\n    if (this.open) {\n      const NOTCH_ELEMENT_PADDING = 8;\n      const NOTCH_ELEMENT_BORDER = 1;\n      return this.labelWidth > 0\n        ? `calc(${this.labelWidth}px * var(--mat-mdc-form-field-floating-label-scale, 0.75) + ${\n            NOTCH_ELEMENT_PADDING + NOTCH_ELEMENT_BORDER\n          }px)`\n        : '0px';\n    }\n\n    return null;\n  }\n}\n",null,"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, InjectionToken, Input} from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `MatPrefix`. It serves as\n * alternative token to the actual `MatPrefix` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_PREFIX = new InjectionToken<MatPrefix>('MatPrefix');\n\n/** Prefix to be placed in front of the form field. */\n@Directive({\n  selector: '[matPrefix], [matIconPrefix], [matTextPrefix]',\n  providers: [{provide: MAT_PREFIX, useExisting: MatPrefix}],\n})\nexport class MatPrefix {\n  @Input('matTextPrefix')\n  set _isTextSelector(value: '') {\n    this._isText = true;\n  }\n\n  _isText = false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  animate,\n  state,\n  style,\n  transition,\n  trigger,\n  AnimationTriggerMetadata,\n} from '@angular/animations';\n\n/**\n * Animations used by the MatFormField.\n * @docs-private\n */\nexport const matFormFieldAnimations: {\n  readonly transitionMessages: AnimationTriggerMetadata;\n} = {\n  /** Animation that transitions the form field's error and hint messages. */\n  transitionMessages: trigger('transitionMessages', [\n    // TODO(mmalerba): Use angular animations for label animation as well.\n    state('enter', style({opacity: 1, transform: 'translateY(0%)'})),\n    transition('void => enter', [\n      style({opacity: 0, transform: 'translateY(-5px)'}),\n      animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'),\n    ]),\n  ]),\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Directionality} from '@angular/cdk/bidi';\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  AfterContentChecked,\n  AfterContentInit,\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  ElementRef,\n  Inject,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {AbstractControlDirective} from '@angular/forms';\nimport {ThemePalette} from '@angular/material/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {merge, Subject} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {MAT_ERROR, MatError} from './directives/error';\nimport {MatFormFieldFloatingLabel} from './directives/floating-label';\nimport {MatHint} from './directives/hint';\nimport {MatLabel} from './directives/label';\nimport {MatFormFieldLineRipple} from './directives/line-ripple';\nimport {MatFormFieldNotchedOutline} from './directives/notched-outline';\nimport {MAT_PREFIX, MatPrefix} from './directives/prefix';\nimport {MAT_SUFFIX, MatSuffix} from './directives/suffix';\nimport {DOCUMENT} from '@angular/common';\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {matFormFieldAnimations} from './form-field-animations';\nimport {MatFormFieldControl} from './form-field-control';\nimport {\n  getMatFormFieldDuplicatedHintError,\n  getMatFormFieldMissingControlError,\n} from './form-field-errors';\n\n/** Type for the available floatLabel values. */\nexport type FloatLabelType = 'always' | 'auto';\n\n/** Possible appearance styles for the form field. */\nexport type MatFormFieldAppearance = 'fill' | 'outline';\n\n/** Behaviors for how the subscript height is set. */\nexport type SubscriptSizing = 'fixed' | 'dynamic';\n\n/**\n * Represents the default options for the form field that can be configured\n * using the `MAT_FORM_FIELD_DEFAULT_OPTIONS` injection token.\n */\nexport interface MatFormFieldDefaultOptions {\n  /** Default form field appearance style. */\n  appearance?: MatFormFieldAppearance;\n  /** Default color of the form field. */\n  color?: ThemePalette;\n  /** Whether the required marker should be hidden by default. */\n  hideRequiredMarker?: boolean;\n  /**\n   * Whether the label for form fields should by default float `always`,\n   * `never`, or `auto` (only when necessary).\n   */\n  floatLabel?: FloatLabelType;\n  /** Whether the form field should reserve space for one line by default. */\n  subscriptSizing?: SubscriptSizing;\n}\n\n/**\n * Injection token that can be used to inject an instances of `MatFormField`. It serves\n * as alternative token to the actual `MatFormField` class which would cause unnecessary\n * retention of the `MatFormField` class and its component metadata.\n */\nexport const MAT_FORM_FIELD = new InjectionToken<MatFormField>('MatFormField');\n\n/**\n * Injection token that can be used to configure the\n * default options for all form field within an app.\n */\nexport const MAT_FORM_FIELD_DEFAULT_OPTIONS = new InjectionToken<MatFormFieldDefaultOptions>(\n  'MAT_FORM_FIELD_DEFAULT_OPTIONS',\n);\n\nlet nextUniqueId = 0;\n\n/** Default appearance used by the form field. */\nconst DEFAULT_APPEARANCE: MatFormFieldAppearance = 'fill';\n\n/**\n * Whether the label for form fields should by default float `always`,\n * `never`, or `auto`.\n */\nconst DEFAULT_FLOAT_LABEL: FloatLabelType = 'auto';\n\n/** Default way that the subscript element height is set. */\nconst DEFAULT_SUBSCRIPT_SIZING: SubscriptSizing = 'fixed';\n\n/**\n * Default transform for docked floating labels in a MDC text-field. This value has been\n * extracted from the MDC text-field styles because we programmatically modify the docked\n * label transform, but do not want to accidentally discard the default label transform.\n */\nconst FLOATING_LABEL_DEFAULT_DOCKED_TRANSFORM = `translateY(-50%)`;\n\n/** Container for form controls that applies Material Design styling and behavior. */\n@Component({\n  selector: 'mat-form-field',\n  exportAs: 'matFormField',\n  templateUrl: './form-field.html',\n  styleUrls: ['./form-field.css'],\n  animations: [matFormFieldAnimations.transitionMessages],\n  host: {\n    'class': 'mat-mdc-form-field',\n    '[class.mat-mdc-form-field-label-always-float]': '_shouldAlwaysFloat()',\n    '[class.mat-mdc-form-field-has-icon-prefix]': '_hasIconPrefix',\n    '[class.mat-mdc-form-field-has-icon-suffix]': '_hasIconSuffix',\n\n    // Note that these classes reuse the same names as the non-MDC version, because they can be\n    // considered a public API since custom form controls may use them to style themselves.\n    // See https://github.com/angular/components/pull/20502#discussion_r486124901.\n    '[class.mat-form-field-invalid]': '_control.errorState',\n    '[class.mat-form-field-disabled]': '_control.disabled',\n    '[class.mat-form-field-autofilled]': '_control.autofilled',\n    '[class.mat-form-field-no-animations]': '_animationMode === \"NoopAnimations\"',\n    '[class.mat-form-field-appearance-fill]': 'appearance == \"fill\"',\n    '[class.mat-form-field-appearance-outline]': 'appearance == \"outline\"',\n    '[class.mat-form-field-hide-placeholder]': '_hasFloatingLabel() && !_shouldLabelFloat()',\n    '[class.mat-focused]': '_control.focused',\n    '[class.mat-primary]': 'color !== \"accent\" && color !== \"warn\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    '[class.ng-untouched]': '_shouldForward(\"untouched\")',\n    '[class.ng-touched]': '_shouldForward(\"touched\")',\n    '[class.ng-pristine]': '_shouldForward(\"pristine\")',\n    '[class.ng-dirty]': '_shouldForward(\"dirty\")',\n    '[class.ng-valid]': '_shouldForward(\"valid\")',\n    '[class.ng-invalid]': '_shouldForward(\"invalid\")',\n    '[class.ng-pending]': '_shouldForward(\"pending\")',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  providers: [{provide: MAT_FORM_FIELD, useExisting: MatFormField}],\n})\nexport class MatFormField\n  implements AfterContentInit, AfterContentChecked, AfterViewInit, OnDestroy\n{\n  @ViewChild('textField') _textField: ElementRef<HTMLElement>;\n  @ViewChild('iconPrefixContainer') _iconPrefixContainer: ElementRef<HTMLElement>;\n  @ViewChild('textPrefixContainer') _textPrefixContainer: ElementRef<HTMLElement>;\n  @ViewChild(MatFormFieldFloatingLabel) _floatingLabel: MatFormFieldFloatingLabel | undefined;\n  @ViewChild(MatFormFieldNotchedOutline) _notchedOutline: MatFormFieldNotchedOutline | undefined;\n  @ViewChild(MatFormFieldLineRipple) _lineRipple: MatFormFieldLineRipple | undefined;\n\n  @ContentChild(MatLabel) _labelChildNonStatic: MatLabel | undefined;\n  @ContentChild(MatLabel, {static: true}) _labelChildStatic: MatLabel | undefined;\n  @ContentChild(MatFormFieldControl) _formFieldControl: MatFormFieldControl<any>;\n  @ContentChildren(MAT_PREFIX, {descendants: true}) _prefixChildren: QueryList<MatPrefix>;\n  @ContentChildren(MAT_SUFFIX, {descendants: true}) _suffixChildren: QueryList<MatSuffix>;\n  @ContentChildren(MAT_ERROR, {descendants: true}) _errorChildren: QueryList<MatError>;\n  @ContentChildren(MatHint, {descendants: true}) _hintChildren: QueryList<MatHint>;\n\n  /** Whether the required marker should be hidden. */\n  @Input()\n  get hideRequiredMarker(): boolean {\n    return this._hideRequiredMarker;\n  }\n  set hideRequiredMarker(value: BooleanInput) {\n    this._hideRequiredMarker = coerceBooleanProperty(value);\n  }\n  private _hideRequiredMarker = false;\n\n  /** The color palette for the form field. */\n  @Input() color: ThemePalette = 'primary';\n\n  /** Whether the label should always float or float as the user types. */\n  @Input()\n  get floatLabel(): FloatLabelType {\n    return this._floatLabel || this._defaults?.floatLabel || DEFAULT_FLOAT_LABEL;\n  }\n  set floatLabel(value: FloatLabelType) {\n    if (value !== this._floatLabel) {\n      this._floatLabel = value;\n      // For backwards compatibility. Custom form field controls or directives might set\n      // the \"floatLabel\" input and expect the form field view to be updated automatically.\n      // e.g. autocomplete trigger. Ideally we'd get rid of this and the consumers would just\n      // emit the \"stateChanges\" observable. TODO(devversion): consider removing.\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  private _floatLabel: FloatLabelType;\n\n  /** The form field appearance style. */\n  @Input()\n  get appearance(): MatFormFieldAppearance {\n    return this._appearance;\n  }\n  set appearance(value: MatFormFieldAppearance) {\n    const oldValue = this._appearance;\n    const newAppearance = value || this._defaults?.appearance || DEFAULT_APPEARANCE;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (newAppearance !== 'fill' && newAppearance !== 'outline') {\n        throw new Error(\n          `MatFormField: Invalid appearance \"${newAppearance}\", valid values are \"fill\" or \"outline\".`,\n        );\n      }\n    }\n    this._appearance = newAppearance;\n    if (this._appearance === 'outline' && this._appearance !== oldValue) {\n      this._refreshOutlineNotchWidth();\n\n      // If the appearance has been switched to `outline`, the label offset needs to be updated.\n      // The update can happen once the view has been re-checked, but not immediately because\n      // the view has not been updated and the notched-outline floating label is not present.\n      this._needsOutlineLabelOffsetUpdateOnStable = true;\n    }\n  }\n  private _appearance: MatFormFieldAppearance = DEFAULT_APPEARANCE;\n\n  /**\n   * Whether the form field should reserve space for one line of hint/error text (default)\n   * or to have the spacing grow from 0px as needed based on the size of the hint/error content.\n   * Note that when using dynamic sizing, layout shifts will occur when hint/error text changes.\n   */\n  @Input()\n  get subscriptSizing(): SubscriptSizing {\n    return this._subscriptSizing || this._defaults?.subscriptSizing || DEFAULT_SUBSCRIPT_SIZING;\n  }\n  set subscriptSizing(value: SubscriptSizing) {\n    this._subscriptSizing = value || this._defaults?.subscriptSizing || DEFAULT_SUBSCRIPT_SIZING;\n  }\n  private _subscriptSizing: SubscriptSizing | null = null;\n\n  /** Text for the form field hint. */\n  @Input()\n  get hintLabel(): string {\n    return this._hintLabel;\n  }\n  set hintLabel(value: string) {\n    this._hintLabel = value;\n    this._processHints();\n  }\n  private _hintLabel = '';\n\n  _hasIconPrefix = false;\n  _hasTextPrefix = false;\n  _hasIconSuffix = false;\n  _hasTextSuffix = false;\n\n  // Unique id for the internal form field label.\n  readonly _labelId = `mat-mdc-form-field-label-${nextUniqueId++}`;\n\n  // Unique id for the hint label.\n  readonly _hintLabelId = `mat-mdc-hint-${nextUniqueId++}`;\n\n  /** State of the mat-hint and mat-error animations. */\n  _subscriptAnimationState = '';\n\n  /** Width of the label element (at scale=1). */\n  _labelWidth = 0;\n\n  /** Gets the current form field control */\n  get _control(): MatFormFieldControl<any> {\n    return this._explicitFormFieldControl || this._formFieldControl;\n  }\n  set _control(value) {\n    this._explicitFormFieldControl = value;\n  }\n\n  private _destroyed = new Subject<void>();\n  private _isFocused: boolean | null = null;\n  private _explicitFormFieldControl: MatFormFieldControl<any>;\n  private _needsOutlineLabelOffsetUpdateOnStable = false;\n\n  constructor(\n    public _elementRef: ElementRef,\n    private _changeDetectorRef: ChangeDetectorRef,\n    private _ngZone: NgZone,\n    private _dir: Directionality,\n    private _platform: Platform,\n    @Optional()\n    @Inject(MAT_FORM_FIELD_DEFAULT_OPTIONS)\n    private _defaults?: MatFormFieldDefaultOptions,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) public _animationMode?: string,\n    @Inject(DOCUMENT) private _document?: any,\n  ) {\n    if (_defaults) {\n      if (_defaults.appearance) {\n        this.appearance = _defaults.appearance;\n      }\n      this._hideRequiredMarker = Boolean(_defaults?.hideRequiredMarker);\n      if (_defaults.color) {\n        this.color = _defaults.color;\n      }\n    }\n  }\n\n  ngAfterViewInit() {\n    // Initial focus state sync. This happens rarely, but we want to account for\n    // it in case the form field control has \"focused\" set to true on init.\n    this._updateFocusState();\n    // Initial notch width update. This is needed in case the text-field label floats\n    // on initialization, and renders inside of the notched outline.\n    this._refreshOutlineNotchWidth();\n    // Make sure fonts are loaded before calculating the width.\n    // zone.js currently doesn't patch the FontFaceSet API so two calls to\n    // _refreshOutlineNotchWidth is needed for this to work properly in async tests.\n    // Furthermore if the font takes a long time to load we want the outline notch to be close\n    // to the correct width from the start then correct itself when the fonts load.\n    if (this._document?.fonts?.ready) {\n      this._document.fonts.ready.then(() => {\n        this._refreshOutlineNotchWidth();\n        this._changeDetectorRef.markForCheck();\n      });\n    } else {\n      // FontFaceSet is not supported in IE\n      setTimeout(() => this._refreshOutlineNotchWidth(), 100);\n    }\n    // Enable animations now. This ensures we don't animate on initial render.\n    this._subscriptAnimationState = 'enter';\n    // Because the above changes a value used in the template after it was checked, we need\n    // to trigger CD or the change might not be reflected if there is no other CD scheduled.\n    this._changeDetectorRef.detectChanges();\n  }\n\n  ngAfterContentInit() {\n    this._assertFormFieldControl();\n    this._initializeControl();\n    this._initializeSubscript();\n    this._initializePrefixAndSuffix();\n    this._initializeOutlineLabelOffsetSubscriptions();\n  }\n\n  ngAfterContentChecked() {\n    this._assertFormFieldControl();\n  }\n\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /**\n   * Gets the id of the label element. If no label is present, returns `null`.\n   */\n  getLabelId(): string | null {\n    return this._hasFloatingLabel() ? this._labelId : null;\n  }\n\n  /**\n   * Gets an ElementRef for the element that a overlay attached to the form field\n   * should be positioned relative to.\n   */\n  getConnectedOverlayOrigin(): ElementRef {\n    return this._textField || this._elementRef;\n  }\n\n  /** Animates the placeholder up and locks it in position. */\n  _animateAndLockLabel(): void {\n    // This is for backwards compatibility only. Consumers of the form field might use\n    // this method. e.g. the autocomplete trigger. This method has been added to the non-MDC\n    // form field because setting \"floatLabel\" to \"always\" caused the label to float without\n    // animation. This is different in MDC where the label always animates, so this method\n    // is no longer necessary. There doesn't seem any benefit in adding logic to allow changing\n    // the floating label state without animations. The non-MDC implementation was inconsistent\n    // because it always animates if \"floatLabel\" is set away from \"always\".\n    // TODO(devversion): consider removing this method when releasing the MDC form field.\n    if (this._hasFloatingLabel()) {\n      this.floatLabel = 'always';\n    }\n  }\n\n  /** Initializes the registered form field control. */\n  private _initializeControl() {\n    const control = this._control;\n\n    if (control.controlType) {\n      this._elementRef.nativeElement.classList.add(\n        `mat-mdc-form-field-type-${control.controlType}`,\n      );\n    }\n\n    // Subscribe to changes in the child control state in order to update the form field UI.\n    control.stateChanges.subscribe(() => {\n      this._updateFocusState();\n      this._syncDescribedByIds();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    // Run change detection if the value changes.\n    if (control.ngControl && control.ngControl.valueChanges) {\n      control.ngControl.valueChanges\n        .pipe(takeUntil(this._destroyed))\n        .subscribe(() => this._changeDetectorRef.markForCheck());\n    }\n  }\n\n  private _checkPrefixAndSuffixTypes() {\n    this._hasIconPrefix = !!this._prefixChildren.find(p => !p._isText);\n    this._hasTextPrefix = !!this._prefixChildren.find(p => p._isText);\n    this._hasIconSuffix = !!this._suffixChildren.find(s => !s._isText);\n    this._hasTextSuffix = !!this._suffixChildren.find(s => s._isText);\n  }\n\n  /** Initializes the prefix and suffix containers. */\n  private _initializePrefixAndSuffix() {\n    this._checkPrefixAndSuffixTypes();\n    // Mark the form field as dirty whenever the prefix or suffix children change. This\n    // is necessary because we conditionally display the prefix/suffix containers based\n    // on whether there is projected content.\n    merge(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => {\n      this._checkPrefixAndSuffixTypes();\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n\n  /**\n   * Initializes the subscript by validating hints and synchronizing \"aria-describedby\" ids\n   * with the custom form field control. Also subscribes to hint and error changes in order\n   * to be able to validate and synchronize ids on change.\n   */\n  private _initializeSubscript() {\n    // Re-validate when the number of hints changes.\n    this._hintChildren.changes.subscribe(() => {\n      this._processHints();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    // Update the aria-described by when the number of errors changes.\n    this._errorChildren.changes.subscribe(() => {\n      this._syncDescribedByIds();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    // Initial mat-hint validation and subscript describedByIds sync.\n    this._validateHints();\n    this._syncDescribedByIds();\n  }\n\n  /** Throws an error if the form field's control is missing. */\n  private _assertFormFieldControl() {\n    if (!this._control && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatFormFieldMissingControlError();\n    }\n  }\n\n  private _updateFocusState() {\n    // Usually the MDC foundation would call \"activateFocus\" and \"deactivateFocus\" whenever\n    // certain DOM events are emitted. This is not possible in our implementation of the\n    // form field because we support abstract form field controls which are not necessarily\n    // of type input, nor do we have a reference to a native form field control element. Instead\n    // we handle the focus by checking if the abstract form field control focused state changes.\n    if (this._control.focused && !this._isFocused) {\n      this._isFocused = true;\n      this._lineRipple?.activate();\n    } else if (!this._control.focused && (this._isFocused || this._isFocused === null)) {\n      this._isFocused = false;\n      this._lineRipple?.deactivate();\n    }\n\n    this._textField?.nativeElement.classList.toggle(\n      'mdc-text-field--focused',\n      this._control.focused,\n    );\n  }\n\n  /**\n   * The floating label in the docked state needs to account for prefixes. The horizontal offset\n   * is calculated whenever the appearance changes to `outline`, the prefixes change, or when the\n   * form field is added to the DOM. This method sets up all subscriptions which are needed to\n   * trigger the label offset update. In general, we want to avoid performing measurements often,\n   * so we rely on the `NgZone` as indicator when the offset should be recalculated, instead of\n   * checking every change detection cycle.\n   */\n  private _initializeOutlineLabelOffsetSubscriptions() {\n    // Whenever the prefix changes, schedule an update of the label offset.\n    this._prefixChildren.changes.subscribe(\n      () => (this._needsOutlineLabelOffsetUpdateOnStable = true),\n    );\n\n    // Note that we have to run outside of the `NgZone` explicitly, in order to avoid\n    // throwing users into an infinite loop if `zone-patch-rxjs` is included.\n    this._ngZone.runOutsideAngular(() => {\n      this._ngZone.onStable.pipe(takeUntil(this._destroyed)).subscribe(() => {\n        if (this._needsOutlineLabelOffsetUpdateOnStable) {\n          this._needsOutlineLabelOffsetUpdateOnStable = false;\n          this._updateOutlineLabelOffset();\n        }\n      });\n    });\n\n    this._dir.change\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => (this._needsOutlineLabelOffsetUpdateOnStable = true));\n  }\n\n  /** Whether the floating label should always float or not. */\n  _shouldAlwaysFloat() {\n    return this.floatLabel === 'always';\n  }\n\n  _hasOutline() {\n    return this.appearance === 'outline';\n  }\n\n  /**\n   * Whether the label should display in the infix. Labels in the outline appearance are\n   * displayed as part of the notched-outline and are horizontally offset to account for\n   * form field prefix content. This won't work in server side rendering since we cannot\n   * measure the width of the prefix container. To make the docked label appear as if the\n   * right offset has been calculated, we forcibly render the label inside the infix. Since\n   * the label is part of the infix, the label cannot overflow the prefix content.\n   */\n  _forceDisplayInfixLabel() {\n    return !this._platform.isBrowser && this._prefixChildren.length && !this._shouldLabelFloat();\n  }\n\n  _hasFloatingLabel() {\n    return !!this._labelChildNonStatic || !!this._labelChildStatic;\n  }\n\n  _shouldLabelFloat() {\n    return this._control.shouldLabelFloat || this._shouldAlwaysFloat();\n  }\n\n  /**\n   * Determines whether a class from the AbstractControlDirective\n   * should be forwarded to the host element.\n   */\n  _shouldForward(prop: keyof AbstractControlDirective): boolean {\n    const control = this._control ? this._control.ngControl : null;\n    return control && control[prop];\n  }\n\n  /** Determines whether to display hints or errors. */\n  _getDisplayedMessages(): 'error' | 'hint' {\n    return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState\n      ? 'error'\n      : 'hint';\n  }\n\n  /** Refreshes the width of the outline-notch, if present. */\n  _refreshOutlineNotchWidth() {\n    if (!this._hasOutline() || !this._floatingLabel) {\n      return;\n    }\n    this._labelWidth = this._floatingLabel.getWidth();\n  }\n\n  /** Does any extra processing that is required when handling the hints. */\n  private _processHints() {\n    this._validateHints();\n    this._syncDescribedByIds();\n  }\n\n  /**\n   * Ensure that there is a maximum of one of each \"mat-hint\" alignment specified. The hint\n   * label specified set through the input is being considered as \"start\" aligned.\n   *\n   * This method is a noop if Angular runs in production mode.\n   */\n  private _validateHints() {\n    if (this._hintChildren && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      let startHint: MatHint;\n      let endHint: MatHint;\n      this._hintChildren.forEach((hint: MatHint) => {\n        if (hint.align === 'start') {\n          if (startHint || this.hintLabel) {\n            throw getMatFormFieldDuplicatedHintError('start');\n          }\n          startHint = hint;\n        } else if (hint.align === 'end') {\n          if (endHint) {\n            throw getMatFormFieldDuplicatedHintError('end');\n          }\n          endHint = hint;\n        }\n      });\n    }\n  }\n\n  /**\n   * Sets the list of element IDs that describe the child control. This allows the control to update\n   * its `aria-describedby` attribute accordingly.\n   */\n  private _syncDescribedByIds() {\n    if (this._control) {\n      let ids: string[] = [];\n\n      // TODO(wagnermaciel): Remove the type check when we find the root cause of this bug.\n      if (\n        this._control.userAriaDescribedBy &&\n        typeof this._control.userAriaDescribedBy === 'string'\n      ) {\n        ids.push(...this._control.userAriaDescribedBy.split(' '));\n      }\n\n      if (this._getDisplayedMessages() === 'hint') {\n        const startHint = this._hintChildren\n          ? this._hintChildren.find(hint => hint.align === 'start')\n          : null;\n        const endHint = this._hintChildren\n          ? this._hintChildren.find(hint => hint.align === 'end')\n          : null;\n\n        if (startHint) {\n          ids.push(startHint.id);\n        } else if (this._hintLabel) {\n          ids.push(this._hintLabelId);\n        }\n\n        if (endHint) {\n          ids.push(endHint.id);\n        }\n      } else if (this._errorChildren) {\n        ids.push(...this._errorChildren.map(error => error.id));\n      }\n\n      this._control.setDescribedByIds(ids);\n    }\n  }\n\n  /**\n   * Updates the horizontal offset of the label in the outline appearance. In the outline\n   * appearance, the notched-outline and label are not relative to the infix container because\n   * the outline intends to surround prefixes, suffixes and the infix. This means that the\n   * floating label by default overlaps prefixes in the docked state. To avoid this, we need to\n   * horizontally offset the label by the width of the prefix container. The MDC text-field does\n   * not need to do this because they use a fixed width for prefixes. Hence, they can simply\n   * incorporate the horizontal offset into their default text-field styles.\n   */\n  private _updateOutlineLabelOffset() {\n    if (!this._platform.isBrowser || !this._hasOutline() || !this._floatingLabel) {\n      return;\n    }\n    const floatingLabel = this._floatingLabel.element;\n    // If no prefix is displayed, reset the outline label offset from potential\n    // previous label offset updates.\n    if (!(this._iconPrefixContainer || this._textPrefixContainer)) {\n      floatingLabel.style.transform = '';\n      return;\n    }\n    // If the form field is not attached to the DOM yet (e.g. in a tab), we defer\n    // the label offset update until the zone stabilizes.\n    if (!this._isAttachedToDom()) {\n      this._needsOutlineLabelOffsetUpdateOnStable = true;\n      return;\n    }\n    const iconPrefixContainer = this._iconPrefixContainer?.nativeElement;\n    const textPrefixContainer = this._textPrefixContainer?.nativeElement;\n    const iconPrefixContainerWidth = iconPrefixContainer?.getBoundingClientRect().width ?? 0;\n    const textPrefixContainerWidth = textPrefixContainer?.getBoundingClientRect().width ?? 0;\n    // If the directionality is RTL, the x-axis transform needs to be inverted. This\n    // is because `transformX` does not change based on the page directionality.\n    const negate = this._dir.value === 'rtl' ? '-1' : '1';\n    const prefixWidth = `${iconPrefixContainerWidth + textPrefixContainerWidth}px`;\n    const labelOffset = `var(--mat-mdc-form-field-label-offset-x, 0px)`;\n    const labelHorizontalOffset = `calc(${negate} * (${prefixWidth} + ${labelOffset}))`;\n\n    // Update the translateX of the floating label to account for the prefix container,\n    // but allow the CSS to override this setting via a CSS variable when the label is\n    // floating.\n    floatingLabel.style.transform = `var(\n        --mat-mdc-form-field-label-transform,\n        ${FLOATING_LABEL_DEFAULT_DOCKED_TRANSFORM} translateX(${labelHorizontalOffset})\n    )`;\n  }\n\n  /** Checks whether the form field is attached to the DOM. */\n  private _isAttachedToDom(): boolean {\n    const element: HTMLElement = this._elementRef.nativeElement;\n    if (element.getRootNode) {\n      const rootNode = element.getRootNode();\n      // If the element is inside the DOM the root node will be either the document\n      // or the closest shadow root, otherwise it'll be the element itself.\n      return rootNode && rootNode !== element;\n    }\n    // Otherwise fall back to checking if it's in the document. This doesn't account for\n    // shadow DOM, however browser that support shadow DOM should support `getRootNode` as well.\n    return document.documentElement!.contains(element);\n  }\n}\n",null,"<ng-template #labelTemplate>\n  <!--\n    MDC recommends that the text-field is a `<label>` element. This rather complicates the\n    setup because it would require every form-field control to explicitly set `aria-labelledby`.\n    This is because the `<label>` itself contains more than the actual label (e.g. prefix, suffix\n    or other projected content), and screen readers could potentially read out undesired content.\n    Excluding elements from being printed out requires them to be marked with `aria-hidden`, or\n    the form control is set to a scoped element for the label (using `aria-labelledby`). Both of\n    these options seem to complicate the setup because we know exactly what content is rendered\n    as part of the label, and we don't want to spend resources on walking through projected content\n    to set `aria-hidden`. Nor do we want to set `aria-labelledby` on every form control if we could\n    simply link the label to the control using the label `for` attribute.\n\n    *Note*: We add aria-owns as a workaround for an issue in JAWS & NVDA where the label isn't\n    read if it comes before the control in the DOM.\n  -->\n  <label matFormFieldFloatingLabel\n         [floating]=\"_shouldLabelFloat()\"\n         *ngIf=\"_hasFloatingLabel()\"\n         (cdkObserveContent)=\"_refreshOutlineNotchWidth()\"\n         [cdkObserveContentDisabled]=\"!_hasOutline()\"\n         [id]=\"_labelId\"\n         [attr.for]=\"_control.id\"\n         [attr.aria-owns]=\"_control.id\">\n    <ng-content select=\"mat-label\"></ng-content>\n    <!--\n      We set the required marker as a separate element, in order to make it easier to target if\n      apps want to override it and to be able to set `aria-hidden` so that screen readers don't\n      pick it up.\n     -->\n    <span\n      *ngIf=\"!hideRequiredMarker && _control.required\"\n      aria-hidden=\"true\"\n      class=\"mat-mdc-form-field-required-marker mdc-floating-label--required\"></span>\n  </label>\n</ng-template>\n\n<div class=\"mat-mdc-text-field-wrapper mdc-text-field\" #textField\n     [class.mdc-text-field--filled]=\"!_hasOutline()\"\n     [class.mdc-text-field--outlined]=\"_hasOutline()\"\n     [class.mdc-text-field--no-label]=\"!_hasFloatingLabel()\"\n     [class.mdc-text-field--disabled]=\"_control.disabled\"\n     [class.mdc-text-field--invalid]=\"_control.errorState\"\n     (click)=\"_control.onContainerClick && _control.onContainerClick($event)\">\n  <div class=\"mat-mdc-form-field-focus-overlay\" *ngIf=\"!_hasOutline() && !_control.disabled\"></div>\n  <div class=\"mat-mdc-form-field-flex\">\n    <div *ngIf=\"_hasOutline()\" matFormFieldNotchedOutline\n         [matFormFieldNotchedOutlineOpen]=\"_shouldLabelFloat()\"\n         [matFormFieldNotchedOutlineLabelWidth]=\"_labelWidth\">\n      <ng-template [ngIf]=\"!_forceDisplayInfixLabel()\">\n        <ng-template [ngTemplateOutlet]=\"labelTemplate\"></ng-template>\n      </ng-template>\n    </div>\n\n    <div class=\"mat-mdc-form-field-icon-prefix\" *ngIf=\"_hasIconPrefix\" #iconPrefixContainer>\n      <ng-content select=\"[matPrefix], [matIconPrefix]\"></ng-content>\n    </div>\n    <div class=\"mat-mdc-form-field-text-prefix\" *ngIf=\"_hasTextPrefix\" #textPrefixContainer>\n      <ng-content select=\"[matTextPrefix]\"></ng-content>\n    </div>\n\n    <div class=\"mat-mdc-form-field-infix\">\n      <ng-template [ngIf]=\"!_hasOutline() || _forceDisplayInfixLabel()\">\n        <ng-template [ngTemplateOutlet]=\"labelTemplate\"></ng-template>\n      </ng-template>\n\n      <ng-content></ng-content>\n    </div>\n\n    <div class=\"mat-mdc-form-field-text-suffix\" *ngIf=\"_hasTextSuffix\">\n      <ng-content select=\"[matTextSuffix]\"></ng-content>\n    </div>\n    <div class=\"mat-mdc-form-field-icon-suffix\" *ngIf=\"_hasIconSuffix\">\n      <ng-content select=\"[matSuffix], [matIconSuffix]\"></ng-content>\n    </div>\n  </div>\n\n  <div matFormFieldLineRipple *ngIf=\"!_hasOutline()\"></div>\n</div>\n\n<div class=\"mat-mdc-form-field-subscript-wrapper mat-mdc-form-field-bottom-align\"\n     [class.mat-mdc-form-field-subscript-dynamic-size]=\"subscriptSizing === 'dynamic'\"\n     [ngSwitch]=\"_getDisplayedMessages()\">\n  <div class=\"mat-mdc-form-field-error-wrapper\" *ngSwitchCase=\"'error'\"\n       [@transitionMessages]=\"_subscriptAnimationState\">\n    <ng-content select=\"mat-error, [matError]\"></ng-content>\n  </div>\n\n  <div class=\"mat-mdc-form-field-hint-wrapper\" *ngSwitchCase=\"'hint'\"\n       [@transitionMessages]=\"_subscriptAnimationState\">\n    <mat-hint *ngIf=\"hintLabel\" [id]=\"_hintLabelId\">{{hintLabel}}</mat-hint>\n    <ng-content select=\"mat-hint:not([align='end'])\"></ng-content>\n    <div class=\"mat-mdc-form-field-hint-spacer\"></div>\n    <ng-content select=\"mat-hint[align='end']\"></ng-content>\n  </div>\n</div>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ObserversModule} from '@angular/cdk/observers';\nimport {CommonModule} from '@angular/common';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule} from '@angular/material/core';\nimport {MatError} from './directives/error';\nimport {MatFormFieldFloatingLabel} from './directives/floating-label';\nimport {MatHint} from './directives/hint';\nimport {MatLabel} from './directives/label';\nimport {MatFormFieldLineRipple} from './directives/line-ripple';\nimport {MatFormFieldNotchedOutline} from './directives/notched-outline';\nimport {MatPrefix} from './directives/prefix';\nimport {MatSuffix} from './directives/suffix';\nimport {MatFormField} from './form-field';\n\n@NgModule({\n  imports: [MatCommonModule, CommonModule, ObserversModule],\n  exports: [MatFormField, MatLabel, MatHint, MatError, MatPrefix, MatSuffix, MatCommonModule],\n  declarations: [\n    MatFormField,\n    MatLabel,\n    MatError,\n    MatHint,\n    MatPrefix,\n    MatSuffix,\n    MatFormFieldFloatingLabel,\n    MatFormFieldNotchedOutline,\n    MatFormFieldLineRipple,\n  ],\n})\nexport class MatFormFieldModule {}\n"],"names":["AsFormControlPipe","constructor","_logger","transform","value","_valueHash","isBlank","FormControl","this","warn","LOGGER","FormComponentBase","LayoutComponentBase","oldValue","valueOutput","control","patchValue","required","_required","removeValidators","Validators","addValidators","disabled","_disabled","enable","disable","_changeDetector","_element","_injector","_parentControl","super","onOptionsSet","options","controlSubscription","unsubscribe","_getFormControl","controlName","FormComponentControlType","_registerValidations","valueChanges","subscribe","parentControl","defaultControlType","initValue","getFormControl","logger","name","getControlForType","FORM_COMPONENT_CONTROL","__decorate","DynamicOutput","InjectionToken","LayoutEditorMetadata","metadataLoader","DynamicClassMetadata","element","componentElement","extensionsOptions","changeDetector","injector","extensions","initialized","destroyed","ngOnDestroy","ext","destroy","onDestroy","ngOnInit","onInit","extension","initialize","afterInit","ngOnChanges","changes","nameof","optionsChange","onOptionsChange","isEmptyObject","onChanges","registerExtensions","invalidateVisuals","detectChanges","_changes","ComponentStylingExtension","DynamicItemExtensionBase","_applyStyling","style","nativeElement","isPresent","lastCssClass","cssClass","split","classList","remove","add","margin","bottom","marginBottom","right","marginRight","top","marginTop","left","marginLeft","padding","paddingBottom","paddingRight","paddingTop","paddingLeft","textStyling","fontSize","fontWeight","toString","target","propertyKey","prop","Object","defineProperty","get","Subject","set","defineAssignedProp","sync","next","ɵɵinjector","componentManager","RelationsComponentManager","RelationsChangeDetector","id","getId","markForCheck","componentId","outputName","skipInit","defineSkipInitProp","RelationsRegistrationExtension","relationsProcessor","metadata","instance","RelationsProcessor","registerComponent","updateRelations","destroyComponent","unregisterComponent","SwitchView","_viewContainerRef","_templateRef","_created","create","createEmbeddedView","clear","enforceState","created","NgSwitch","_defaultViews","_defaultUsed","_caseCount","_lastCaseCheckIndex","_lastCasesMatched","ngSwitch","newValue","_ngSwitch","_updateDefaultCases","_addCase","_addDefault","view","push","_matchCase","matched","useDefault","length","defaultView","NgSwitchCase","viewContainer","templateRef","_view","ngDoCheck","ngSwitchCase","i0","NgSwitchDefault","mixinErrorState","base","updateErrorState","oldState","errorState","parent","_parentFormGroup","_parentForm","matcher","errorStateMatcher","_defaultErrorStateMatcher","ngControl","newState","isErrorState","stateChanges","args","ShowOnDirtyErrorStateMatcher","form","invalid","dirty","submitted","ErrorStateMatcher","touched","nextUniqueId","MatHint","align","MatLabel","MAT_SUFFIX","MatSuffix","_isText","_isTextSelector","provide","useExisting","MatFormFieldControl","MAT_ERROR","MatError","ariaLive","elementRef","setAttribute","MatFormFieldFloatingLabel","_elementRef","floating","getWidth","htmlEl","offsetParent","scrollWidth","clone","cloneNode","setProperty","document","documentElement","appendChild","estimateScrollWidth","ACTIVATE_CLASS","DEACTIVATING_CLASS","MatFormFieldLineRipple","ngZone","_handleTransitionEnd","event","isDeactivating","contains","propertyName","runOutsideAngular","addEventListener","activate","deactivate","removeEventListener","MatFormFieldNotchedOutline","_ngZone","labelWidth","open","ngAfterViewInit","label","querySelector","requestAnimationFrame","transitionDuration","_getNotchWidth","NOTCH_ELEMENT_PADDING","NOTCH_ELEMENT_BORDER","MAT_PREFIX","MatPrefix","matFormFieldAnimations","transitionMessages","trigger","state","opacity","transition","animate","MAT_FORM_FIELD","MAT_FORM_FIELD_DEFAULT_OPTIONS","DEFAULT_APPEARANCE","DEFAULT_SUBSCRIPT_SIZING","MatFormField","hideRequiredMarker","_hideRequiredMarker","coerceBooleanProperty","floatLabel","_floatLabel","_defaults","_changeDetectorRef","appearance","_appearance","newAppearance","_refreshOutlineNotchWidth","_needsOutlineLabelOffsetUpdateOnStable","subscriptSizing","_subscriptSizing","hintLabel","_hintLabel","_processHints","_control","_explicitFormFieldControl","_formFieldControl","_dir","_platform","_animationMode","_document","color","_hasIconPrefix","_hasTextPrefix","_hasIconSuffix","_hasTextSuffix","_labelId","_hintLabelId","_subscriptAnimationState","_labelWidth","_destroyed","_isFocused","Boolean","_updateFocusState","fonts","ready","then","setTimeout","ngAfterContentInit","_assertFormFieldControl","_initializeControl","_initializeSubscript","_initializePrefixAndSuffix","_initializeOutlineLabelOffsetSubscriptions","ngAfterContentChecked","complete","getLabelId","_hasFloatingLabel","getConnectedOverlayOrigin","_textField","_animateAndLockLabel","controlType","_syncDescribedByIds","pipe","takeUntil","_checkPrefixAndSuffixTypes","_prefixChildren","find","p","_suffixChildren","s","merge","_hintChildren","_errorChildren","_validateHints","focused","_lineRipple","toggle","onStable","_updateOutlineLabelOffset","change","_shouldAlwaysFloat","_hasOutline","_forceDisplayInfixLabel","isBrowser","_shouldLabelFloat","_labelChildNonStatic","_labelChildStatic","shouldLabelFloat","_shouldForward","_getDisplayedMessages","_floatingLabel","ids","userAriaDescribedBy","startHint","hint","endHint","map","error","setDescribedByIds","floatingLabel","_iconPrefixContainer","_textPrefixContainer","_isAttachedToDom","iconPrefixContainer","textPrefixContainer","iconPrefixContainerWidth","getBoundingClientRect","width","textPrefixContainerWidth","labelHorizontalOffset","getRootNode","rootNode","ANIMATION_MODULE_TYPE","DOCUMENT","i3","MatFormFieldModule","MatCommonModule","CommonModule","ObserversModule"],"sourceRoot":""}