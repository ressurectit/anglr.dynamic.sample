{"version":3,"file":"5640.client.chunk.8411187b4e709d958300.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../forms/src/modules/formPipes/pipes/asFormControl/asFormControl.pipe.ts","webpack://ng-universal-demo/../../../form/src/components/formComponentBase/formComponentBase.ts","webpack://ng-universal-demo/../../../form/src/misc/tokens.ts","webpack://ng-universal-demo/../../../layout-editor/src/decorators/layoutEditorMetadata/layoutEditorMetadata.decorator.ts","webpack://ng-universal-demo/../../../layout/src/components/layoutComponentBase/layoutComponentBase.ts","webpack://ng-universal-demo/../../../layout/src/extensions/componentStyling/componentStyling.extension.ts","webpack://ng-universal-demo/../../../src/material/checkbox/checkbox-module.ts","webpack://ng-universal-demo/../../../material-components/src/dynamicItems/checkbox/checkbox.metadata.ts","webpack://ng-universal-demo/../../../src/material/checkbox/checkbox-config.ts","webpack://ng-universal-demo/../../../src/material/checkbox/checkbox.ts","webpack://ng-universal-demo/../src/material/checkbox/checkbox.html","webpack://ng-universal-demo/../../../src/material/checkbox/checkbox.html","webpack://ng-universal-demo/../../../material-components/src/dynamicItems/checkbox/checkbox.component.ts","webpack://ng-universal-demo/./node_modules/@anglr/dynamic/material-components/src/dynamicItems/checkbox/checkbox.component.html","webpack://ng-universal-demo/../../../material-components/src/dynamicItems/checkbox/type.ts","webpack://ng-universal-demo/../../../relations/src/decorators/dynamicOutput/dynamicOutput.decorator.ts","webpack://ng-universal-demo/../../../relations/src/extensions/relationsRegistration/relationsRegistration.extension.ts","webpack://ng-universal-demo/../../../src/misc/dynamicItemExtensionBase.ts"],"sourcesContent":["import {Inject, Optional, Pipe} from '@angular/core';\nimport {AbstractControl, FormControl} from '@angular/forms';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {isBlank} from '@jscrpt/common';\n\n/**\n * Tries to convert `AbstractControl` to `FormControl`\n */\n@Pipe({name: 'asFormControl'})\nexport class AsFormControlPipe\n{\n    //######################### constructors #########################\n    constructor(@Optional() @Inject(LOGGER) private _logger?: Logger)\n    {\n    }\n\n    //######################### public methods - implementation of PipeTransform #########################\n\n    /**\n     * Allows casting of `AbstractControl` to `FormControl`\n     * @param value - `AbstractControl` to be cast to `FormControl`\n     * @param _valueHash - Parameter that can be used to change value, indicates that pipe input value has changed\n     */\n    public transform<TModel>(value: AbstractControl<TModel>|null|undefined, _valueHash?: any): FormControl<TModel>|null\n    {\n        if(isBlank(value))\n        {\n            return null;\n        }\n\n        if(value instanceof FormControl)\n        {\n            return value as FormControl<TModel>;\n        }\n\n        this._logger?.warn('Failed to cast AbstractControl to FormControl');\n\n        return null;\n    }\n}","import {ChangeDetectorRef, Directive, ElementRef, Inject, Injector, Input, Optional} from '@angular/core';\nimport {AbstractControl, FormControl, Validators} from '@angular/forms';\nimport {LayoutComponentBase} from '@anglr/dynamic/layout';\nimport {LOGGER, Logger} from '@anglr/common';\nimport {DynamicOutput} from '@anglr/dynamic/relations';\nimport {PromiseOr} from '@jscrpt/common';\nimport {Subscription} from 'rxjs';\n\nimport {FORM_COMPONENT_CONTROL} from '../../misc/tokens';\nimport {FormComponentOptions} from '../../misc/formComponentBase.options';\nimport {FormComponentControlType} from '../../misc/enums';\nimport {getControlForType, getFormControl} from '../../misc/utils';\n\n/**\n * Base component for form component\n */\n@Directive()\nexport abstract class FormComponentBase<TOptions extends FormComponentOptions, TValue = string> extends LayoutComponentBase<TOptions>\n{\n    //######################### private properties #########################\n\n    /**\n     * Indication whether form component is required\n     */\n    private _required: boolean|null|undefined;\n\n    /**\n     * Indication whether form component is disabled\n     */\n    private _disabled: boolean|null|undefined;\n\n    //######################### protected properties #########################\n\n    /**\n     * Form component control\n     */\n    protected control: AbstractControl = new FormControl();\n\n    /**\n     * Form component control subscriptions\n     */\n    protected controlSubscription: Subscription|null|undefined;\n\n    //######################### public properties - inputs #########################\n\n    /**\n     * Form component value\n     */\n    @Input()\n    public set value(value: TValue|null|undefined)\n    {\n        const oldValue = this.value;\n        this.valueOutput = value;\n\n        if (value !== oldValue)\n        {\n            this.control?.patchValue(value);\n        }\n    }\n    public get value(): TValue|null|undefined\n    {\n        return this.valueOutput;\n    }\n\n    /**\n     * Indication whether form component is required\n     */\n    @Input()\n    public set required(value: boolean|null|undefined)\n    {\n        this._required = value;\n\n        if (value === true)\n        {\n            this.control?.addValidators(Validators.required);\n            return;\n        }\n\n        this.control?.removeValidators(Validators.required);\n    }\n    public get required(): boolean|null|undefined\n    {\n        return this._required;\n    }\n\n    /**\n     * Indication whether form component is disabled\n     */\n    @Input()\n    public set disabled(value: boolean|null|undefined)\n    {\n        this._disabled = value;\n\n        if (value === true)\n        {\n            this.control?.disable();\n            return;\n        }\n\n        this.control?.enable();\n    }\n    public get disabled(): boolean|null|undefined\n    {\n        return this._disabled;\n    }\n\n    //######################### public properties - dynamicOutputs #########################\n\n    /**\n     * Form component value\n     */\n    @DynamicOutput()\n    public valueOutput: TValue|null|undefined;\n\n    //######################### constructor #########################\n\n    constructor(_changeDetector: ChangeDetectorRef,\n                _element: ElementRef<HTMLElement>,\n                _injector: Injector,\n                @Inject(FORM_COMPONENT_CONTROL) @Optional() protected _parentControl?: AbstractControl,\n                @Inject(LOGGER) @Optional() _logger?: Logger,)\n    {\n        super(_changeDetector, _element, _injector, _logger);\n    }\n\n    //######################### protected methods - _onOptionsSet implementation #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override onOptionsSet(): PromiseOr<void> \n    {\n        if(!this.options)\n        {\n            return;\n        }\n\n        this.controlSubscription?.unsubscribe();\n        this.controlSubscription = null;\n\n        this.control = this._getFormControl(this.options?.controlName, this._parentControl, FormComponentControlType.FormControl, this.value); \n        this._registerValidations();\n\n        this.controlSubscription = this.control\n            ?.valueChanges\n            ?.subscribe(value => \n            {\n                this.valueOutput = value;\n            });\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Registers component-specific validators\n     */\n    protected _registerValidations(): void\n    {}\n\n    //######################### private methods #########################\n\n    /**\n     * Gets form component control for control name\n     * @param controlName Form component control name\n     * @param parentControl Parent form control\n     * @param defaultControlType Default control type when parent does not exists or not contains control with specified name\n     * @param initValue Initial value for control\n     * @returns Specified type of control\n     */\n    private _getFormControl(controlName: string|null|undefined, parentControl: AbstractControl|undefined, defaultControlType: FormComponentControlType = FormComponentControlType.FormControl, initValue: TValue|null|undefined): AbstractControl\n    {\n        let control = getFormControl(controlName, parentControl, defaultControlType, initValue);\n\n        if (!control)\n        {\n            this.logger?.warn('FormComponentBase: Unable to find control with name {@name}', {name: controlName});\n\n            control = getControlForType(defaultControlType, initValue);\n        }\n\n        if (this.required)\n        {\n            control.addValidators(Validators.required);\n        }\n\n        if (this.disabled)\n        {\n            control.disable();\n        }\n\n        return control;\n    }\n}","import {InjectionToken} from '@angular/core';\nimport {AbstractControl} from '@angular/forms';\n\n/**\n * Injection token for form component control\n */\nexport const FORM_COMPONENT_CONTROL : InjectionToken<AbstractControl> = new InjectionToken<AbstractControl>('FORM_COMPONENT_CONTROL');","import {DynamicClassMetadata, DynamicMetadataLoader} from '@anglr/dynamic';\n\nimport {LayoutEditorMetadataDescriptor, LayoutEditorMetadataType} from '../../decorators';\n\n/**\n * Sets layout editor metadata to class on which is this decorator applied\n * @param metadataLoader - Layout editor metadata loader function used for obtaining metadata\n */\nexport function LayoutEditorMetadata(metadataLoader: DynamicMetadataLoader<LayoutEditorMetadataDescriptor>): ClassDecorator\n{\n    return DynamicClassMetadata<LayoutEditorMetadataDescriptor, LayoutEditorMetadataType>(metadataLoader, 'layoutEditorMetadata');\n}","import {ChangeDetectorRef, Directive, ElementRef, Inject, Injector, OnDestroy, Optional, SimpleChanges} from '@angular/core';\nimport {Logger, LOGGER} from '@anglr/common';\nimport {DynamicItemExtension} from '@anglr/dynamic';\nimport {isEmptyObject, nameof, PromiseOr} from '@jscrpt/common';\n\nimport {LayoutComponent} from '../../interfaces';\n\n/**\n * Base component for layout component\n */\n@Directive()\nexport abstract class LayoutComponentBase<TOptions> implements LayoutComponent<TOptions>, OnDestroy\n{\n    //######################### protected fields #########################\n\n    /**\n     * Array of extensions that are registered for component\n     */\n    protected extensions: DynamicItemExtension<TOptions>[] = [];\n\n    /**\n     * Indication whether initialization was already done\n     */\n    protected initialized: boolean = false;\n\n    /**\n     * Indication whether was component destroyed\n     */\n    protected destroyed: boolean = false;\n\n    //######################### protected properties #########################\n\n    /**\n     * Gets element that is used within extension\n     */\n    protected get element(): ElementRef<HTMLElement>\n    {\n        return this.componentElement;\n    }\n\n    /**\n     * Gets options that are used within extension\n     */\n    protected get extensionsOptions(): any|undefined|null\n    {\n        return this.options;\n    }\n\n    //######################### public properties - implementation of LayoutComponent #########################\n\n    /**\n     * @inheritdoc\n     */\n    public options: TOptions|undefined|null;\n\n    //######################### constructor #########################\n    constructor(protected changeDetector: ChangeDetectorRef,\n                protected componentElement: ElementRef<HTMLElement>,\n                protected injector: Injector,\n                @Inject(LOGGER) @Optional() protected logger?: Logger,)\n    {\n    }\n\n    //######################### public methods - implementation of OnDestroy #########################\n    \n    /**\n     * Called when component is destroyed\n     */\n    public ngOnDestroy(): void\n    {\n        if(this.destroyed)\n        {\n            return;\n        }\n\n        this.destroyed = true;\n\n        for(const ext of this.extensions)\n        {\n            ext.destroy();\n        }\n\n        this.onDestroy();\n    }\n\n    //######################### public methods - implementation of LayoutComponent #########################\n\n    /**\n     * @inheritdoc\n     */\n    public async ngOnInit(): Promise<void>\n    {\n        if(this.initialized)\n        {\n            return;\n        }\n\n        this.initialized = true;\n        const extensionsOptions = this.extensionsOptions;\n        \n        await this.onInit();\n        await this.onOptionsSet();\n\n        if(extensionsOptions)\n        {\n            for(const extension of this.extensions)\n            {\n                await extension.initialize(this.injector, this.element, this);\n            }\n        }\n\n        await this.afterInit();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public async ngOnChanges(changes: SimpleChanges): Promise<void>\n    {\n        //options has changed\n        if(nameof<LayoutComponentBase<TOptions>>('options') in changes)\n        {\n            await this.onOptionsSet();\n\n            const extensionsOptions = this.extensionsOptions;\n\n            //set options in extensions\n            if(extensionsOptions)\n            {\n                for(const extension of this.extensions)\n                {\n                    await extension.optionsChange(extensionsOptions);\n                }\n            }\n\n            if(!this.initialized)\n            {\n                return;\n            }\n\n            await this.onOptionsChange();\n        }\n\n        delete changes[nameof<LayoutComponentBase<TOptions>>('options')];\n\n        if(!isEmptyObject(changes))\n        {\n            this.onChanges(changes);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public registerExtensions(extensions: DynamicItemExtension[]): void\n    {\n        this.extensions = extensions;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public invalidateVisuals(): void\n    {\n        this.changeDetector.detectChanges();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Called on initialzation of component, options are already set\n     */\n    protected onInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called right after initialization finished, including extesions\n     */\n    protected afterInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on change of options, after initialization\n     */\n    protected onOptionsChange(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Occurs when some property changes on component\n     * @param _changes - Changes that occured on component\n     */\n    protected onChanges(_changes: SimpleChanges): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called everytime options are set, after initialization and later\n     */\n    protected onOptionsSet(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called when component is being destroyed\n     */\n    protected onDestroy(): void\n    {\n    }\n}","import {DynamicItemExtension, DynamicItemExtensionBase} from '@anglr/dynamic';\nimport {isPresent} from '@jscrpt/common';\n\nimport {ComponentStylingOptions} from '../../interfaces';\n\n/**\n * Extension that applies common component styling to component\n */\nexport class ComponentStylingExtension extends DynamicItemExtensionBase<ComponentStylingOptions> implements DynamicItemExtension<ComponentStylingOptions>\n{\n    //######################### protected properties #########################\n\n    /**\n     * Value of last css class\n     */\n    protected lastCssClass: string|undefined|null;\n\n    //######################### public methods - overrides #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override onInit(): void\n    {\n        this._applyStyling();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected override onOptionsChange(): void\n    {\n        this._applyStyling();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Applies component styling to element\n     */\n    protected _applyStyling(): void\n    {\n        const options = this.options;\n        const style = this.element?.nativeElement.style;\n\n        if(this.element)\n        {\n            if(isPresent(this.lastCssClass))\n            {\n                for(const cssClass of this.lastCssClass.split(' '))\n                {\n                    if(cssClass)\n                    {\n                        this.element.nativeElement.classList.remove(cssClass);\n                    }\n                }\n            }\n\n            this.lastCssClass = options?.cssClass;\n\n            if(options?.cssClass)\n            {\n                for(const cssClass of options.cssClass.split(' '))\n                {\n                    if(cssClass)\n                    {\n                        this.element?.nativeElement.classList.add(cssClass);\n                    }\n                }\n            }\n        }\n\n        if(isPresent(style))\n        {\n            if(options?.margin)\n            {\n                if(isPresent(options.margin.bottom))\n                {\n                    style.marginBottom = options.margin.bottom;\n                }\n\n                if(isPresent(options.margin.right))\n                {\n                    style.marginRight = options.margin.right;\n                }\n\n                if(isPresent(options.margin.top))\n                {\n                    style.marginTop = options.margin.top;\n                }\n\n                if(isPresent(options.margin.left))\n                {\n                    style.marginLeft = options.margin.left;\n                }\n            }\n\n            if(options?.padding)\n            {\n                if(isPresent(options.padding.bottom))\n                {\n                    style.paddingBottom = options.padding.bottom;\n                }\n\n                if(isPresent(options.padding.right))\n                {\n                    style.paddingRight = options.padding.right;\n                }\n\n                if(isPresent(options.padding.top))\n                {\n                    style.paddingTop = options.padding.top;\n                }\n\n                if(isPresent(options.padding.left))\n                {\n                    style.paddingLeft = options.padding.left;\n                }\n            }\n\n            if(options?.textStyling)\n            {\n                if(isPresent(options.textStyling.fontSize))\n                {\n                    style.fontSize = options.textStyling.fontSize;\n                }\n\n                if(isPresent(options.textStyling.fontWeight))\n                {\n                    style.fontWeight = options.textStyling.fontWeight.toString();\n                }\n            }\n        }\n    }\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ObserversModule} from '@angular/cdk/observers';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule, MatRippleModule} from '@angular/material/core';\nimport {MatCheckbox} from './checkbox';\nimport {MatCheckboxRequiredValidator} from './checkbox-required-validator';\n\n/** This module is used by both original and MDC-based checkbox implementations. */\n@NgModule({\n  exports: [MatCheckboxRequiredValidator],\n  declarations: [MatCheckboxRequiredValidator],\n})\nexport class _MatCheckboxRequiredValidatorModule {}\n\n@NgModule({\n  imports: [MatRippleModule, MatCommonModule, ObserversModule, _MatCheckboxRequiredValidatorModule],\n  exports: [MatCheckbox, MatCommonModule, _MatCheckboxRequiredValidatorModule],\n  declarations: [MatCheckbox],\n})\nexport class MatCheckboxModule {}\n","import {DynamicMetadataLoader} from '@anglr/dynamic';\nimport {LayoutEditorMetadataDescriptor} from '@anglr/dynamic/layout-editor';\nimport {RelationsEditorMetadataDescriptor} from '@anglr/dynamic/relations-editor';\n\nimport {MaterialCheckboxComponentOptions} from './checkbox.options';\n\n/**\n * Material checkbox layout metadata loader\n */\nexport const MaterialCheckboxLayoutMetadataLoader: DynamicMetadataLoader<LayoutEditorMetadataDescriptor<MaterialCheckboxComponentOptions>> = async () => new (await import('./metadata/checkbox.layoutMetadata')).MaterialCheckboxLayoutEditorMetadata();\n\n/**\n * Material checkbox relations metadata loader\n */\nexport const MaterialCheckboxRelationsMetadataLoader: DynamicMetadataLoader<RelationsEditorMetadataDescriptor> = async () => new (await import('./metadata/checkbox.relationsMetadata')).MaterialCheckboxRelationsEditorMetadata();","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectionToken} from '@angular/core';\nimport {ThemePalette} from '@angular/material/core';\n\n/** Default `mat-checkbox` options that can be overridden. */\nexport interface MatCheckboxDefaultOptions {\n  /** Default theme color palette to be used for checkboxes. */\n  color?: ThemePalette;\n  /** Default checkbox click action for checkboxes. */\n  clickAction?: MatCheckboxClickAction;\n}\n\n/** Injection token to be used to override the default options for `mat-checkbox`. */\nexport const MAT_CHECKBOX_DEFAULT_OPTIONS = new InjectionToken<MatCheckboxDefaultOptions>(\n  'mat-checkbox-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\n/** @docs-private */\nexport function MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY(): MatCheckboxDefaultOptions {\n  return {\n    color: 'accent',\n    clickAction: 'check-indeterminate',\n  };\n}\n\n/**\n * Checkbox click action when user click on input element.\n * noop: Do not toggle checked or indeterminate.\n * check: Only toggle checked status, ignore indeterminate.\n * check-indeterminate: Toggle checked status, set indeterminate to false. Default behavior.\n * undefined: Same as `check-indeterminate`.\n */\nexport type MatCheckboxClickAction = 'noop' | 'check' | 'check-indeterminate' | undefined;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusableOption, FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n  Output,\n  ViewChild,\n  ViewEncapsulation,\n  Directive,\n  AfterViewInit,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {\n  CanColor,\n  CanDisable,\n  CanDisableRipple,\n  HasTabIndex,\n  MatRipple,\n  mixinColor,\n  mixinDisabled,\n  mixinDisableRipple,\n  mixinTabIndex,\n} from '@angular/material/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {\n  MAT_CHECKBOX_DEFAULT_OPTIONS,\n  MatCheckboxDefaultOptions,\n  MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY,\n} from './checkbox-config';\n\n// Increasing integer for generating unique ids for checkbox components.\nlet nextUniqueId = 0;\n\n// Default checkbox configuration.\nconst defaults = MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY();\n\n/**\n * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * @docs-private\n */\nexport const MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatCheckbox),\n  multi: true,\n};\n\n/**\n * Represents the different states that require custom transitions between them.\n * @docs-private\n */\nexport const enum TransitionCheckState {\n  /** The initial state of the component before any user interaction. */\n  Init,\n  /** The state representing the component when it's becoming checked. */\n  Checked,\n  /** The state representing the component when it's becoming unchecked. */\n  Unchecked,\n  /** The state representing the component when it's becoming indeterminate. */\n  Indeterminate,\n}\n\n/** Change event object emitted by MatCheckbox. */\nexport class MatCheckboxChange {\n  /** The source MatCheckbox of the event. */\n  source: MatCheckbox;\n  /** The new `checked` value of the checkbox. */\n  checked: boolean;\n}\n\n// Boilerplate for applying mixins to MatCheckbox.\n/** @docs-private */\nconst _MatCheckboxMixinBase = mixinTabIndex(\n  mixinColor(\n    mixinDisableRipple(\n      mixinDisabled(\n        class {\n          constructor(public _elementRef: ElementRef) {}\n        },\n      ),\n    ),\n  ),\n);\n\n@Directive()\nexport abstract class _MatCheckboxBase<E>\n  extends _MatCheckboxMixinBase\n  implements\n    AfterViewInit,\n    ControlValueAccessor,\n    CanColor,\n    CanDisable,\n    HasTabIndex,\n    CanDisableRipple,\n    FocusableOption\n{\n  /** Focuses the checkbox. */\n  abstract focus(origin?: FocusOrigin): void;\n\n  /** Creates the change event that will be emitted by the checkbox. */\n  protected abstract _createChangeEvent(isChecked: boolean): E;\n\n  /** Gets the element on which to add the animation CSS classes. */\n  protected abstract _getAnimationTargetElement(): HTMLElement | null;\n\n  /** CSS classes to add when transitioning between the different checkbox states. */\n  protected abstract _animationClasses: {\n    uncheckedToChecked: string;\n    uncheckedToIndeterminate: string;\n    checkedToUnchecked: string;\n    checkedToIndeterminate: string;\n    indeterminateToChecked: string;\n    indeterminateToUnchecked: string;\n  };\n\n  /**\n   * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will\n   * take precedence so this may be omitted.\n   */\n  @Input('aria-label') ariaLabel: string = '';\n\n  /**\n   * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n   */\n  @Input('aria-labelledby') ariaLabelledby: string | null = null;\n\n  /** The 'aria-describedby' attribute is read after the element's label and field type. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  private _uniqueId: string;\n\n  /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */\n  @Input() id: string;\n\n  /** Returns the unique id for the visual hidden input. */\n  get inputId(): string {\n    return `${this.id || this._uniqueId}-input`;\n  }\n\n  /** Whether the checkbox is required. */\n  @Input()\n  get required(): boolean {\n    return this._required;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n  private _required: boolean;\n\n  /** Whether the label should appear after or before the checkbox. Defaults to 'after' */\n  @Input() labelPosition: 'before' | 'after' = 'after';\n\n  /** Name value will be applied to the input element if present */\n  @Input() name: string | null = null;\n\n  /** Event emitted when the checkbox's `checked` value changes. */\n  @Output() readonly change: EventEmitter<E> = new EventEmitter<E>();\n\n  /** Event emitted when the checkbox's `indeterminate` value changes. */\n  @Output() readonly indeterminateChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  /** The value attribute of the native input element */\n  @Input() value: string;\n\n  /** The native `<input type=\"checkbox\">` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** The native `<label>` element */\n  @ViewChild('label') _labelElement: ElementRef<HTMLInputElement>;\n\n  /** Reference to the ripple instance of the checkbox. */\n  @ViewChild(MatRipple) ripple: MatRipple;\n\n  /**\n   * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\n   * @docs-private\n   */\n  _onTouched: () => any = () => {};\n\n  private _currentAnimationClass: string = '';\n\n  private _currentCheckState: TransitionCheckState = TransitionCheckState.Init;\n\n  private _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  constructor(\n    idPrefix: string,\n    elementRef: ElementRef<HTMLElement>,\n    protected _changeDetectorRef: ChangeDetectorRef,\n    protected _ngZone: NgZone,\n    tabIndex: string,\n    public _animationMode?: string,\n    protected _options?: MatCheckboxDefaultOptions,\n  ) {\n    super(elementRef);\n    this._options = this._options || defaults;\n    this.color = this.defaultColor = this._options.color || defaults.color;\n    this.tabIndex = parseInt(tabIndex) || 0;\n    this.id = this._uniqueId = `${idPrefix}${++nextUniqueId}`;\n  }\n\n  ngAfterViewInit() {\n    this._syncIndeterminate(this._indeterminate);\n  }\n\n  /** Whether the checkbox is checked. */\n  @Input()\n  get checked(): boolean {\n    return this._checked;\n  }\n  set checked(value: BooleanInput) {\n    const checked = coerceBooleanProperty(value);\n\n    if (checked != this.checked) {\n      this._checked = checked;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  private _checked: boolean = false;\n\n  /**\n   * Whether the checkbox is disabled. This fully overrides the implementation provided by\n   * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.\n   */\n  @Input()\n  override get disabled(): boolean {\n    return this._disabled;\n  }\n  override set disabled(value: BooleanInput) {\n    const newValue = coerceBooleanProperty(value);\n\n    if (newValue !== this.disabled) {\n      this._disabled = newValue;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  private _disabled: boolean = false;\n\n  /**\n   * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\n   * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\n   * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\n   * set to false.\n   */\n  @Input()\n  get indeterminate(): boolean {\n    return this._indeterminate;\n  }\n  set indeterminate(value: BooleanInput) {\n    const changed = value != this._indeterminate;\n    this._indeterminate = coerceBooleanProperty(value);\n\n    if (changed) {\n      if (this._indeterminate) {\n        this._transitionCheckState(TransitionCheckState.Indeterminate);\n      } else {\n        this._transitionCheckState(\n          this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked,\n        );\n      }\n      this.indeterminateChange.emit(this._indeterminate);\n    }\n\n    this._syncIndeterminate(this._indeterminate);\n  }\n  private _indeterminate: boolean = false;\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  /** Method being called whenever the label text changes. */\n  _onLabelTextChange() {\n    // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox\n    // component will be only marked for check, but no actual change detection runs automatically.\n    // Instead of going back into the zone in order to trigger a change detection which causes\n    // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger\n    // an explicit change detection for the checkbox view and its children.\n    this._changeDetectorRef.detectChanges();\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  writeValue(value: any) {\n    this.checked = !!value;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnTouched(fn: any) {\n    this._onTouched = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n  }\n\n  _getAriaChecked(): 'true' | 'false' | 'mixed' {\n    if (this.checked) {\n      return 'true';\n    }\n\n    return this.indeterminate ? 'mixed' : 'false';\n  }\n\n  private _transitionCheckState(newState: TransitionCheckState) {\n    let oldState = this._currentCheckState;\n    let element = this._getAnimationTargetElement();\n\n    if (oldState === newState || !element) {\n      return;\n    }\n    if (this._currentAnimationClass) {\n      element.classList.remove(this._currentAnimationClass);\n    }\n\n    this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(\n      oldState,\n      newState,\n    );\n    this._currentCheckState = newState;\n\n    if (this._currentAnimationClass.length > 0) {\n      element.classList.add(this._currentAnimationClass);\n\n      // Remove the animation class to avoid animation when the checkbox is moved between containers\n      const animationClass = this._currentAnimationClass;\n\n      this._ngZone.runOutsideAngular(() => {\n        setTimeout(() => {\n          element!.classList.remove(animationClass);\n        }, 1000);\n      });\n    }\n  }\n\n  private _emitChangeEvent() {\n    this._controlValueAccessorChangeFn(this.checked);\n    this.change.emit(this._createChangeEvent(this.checked));\n\n    // Assigning the value again here is redundant, but we have to do it in case it was\n    // changed inside the `change` listener which will cause the input to be out of sync.\n    if (this._inputElement) {\n      this._inputElement.nativeElement.checked = this.checked;\n    }\n  }\n\n  /** Toggles the `checked` state of the checkbox. */\n  toggle(): void {\n    this.checked = !this.checked;\n    this._controlValueAccessorChangeFn(this.checked);\n  }\n\n  protected _handleInputClick() {\n    const clickAction = this._options?.clickAction;\n\n    // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click\n    if (!this.disabled && clickAction !== 'noop') {\n      // When user manually click on the checkbox, `indeterminate` is set to false.\n      if (this.indeterminate && clickAction !== 'check') {\n        Promise.resolve().then(() => {\n          this._indeterminate = false;\n          this.indeterminateChange.emit(this._indeterminate);\n        });\n      }\n\n      this._checked = !this._checked;\n      this._transitionCheckState(\n        this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked,\n      );\n\n      // Emit our custom change event if the native input emitted one.\n      // It is important to only emit it, if the native input triggered one, because\n      // we don't want to trigger a change event, when the `checked` variable changes for example.\n      this._emitChangeEvent();\n    } else if (!this.disabled && clickAction === 'noop') {\n      // Reset native input when clicked with noop. The native checkbox becomes checked after\n      // click, reset it to be align with `checked` value of `mat-checkbox`.\n      this._inputElement.nativeElement.checked = this.checked;\n      this._inputElement.nativeElement.indeterminate = this.indeterminate;\n    }\n  }\n\n  _onInteractionEvent(event: Event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n  }\n\n  _onBlur() {\n    // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n    // Angular does not expect events to be raised during change detection, so any state change\n    // (such as a form control's 'ng-touched') will cause a changed-after-checked error.\n    // See https://github.com/angular/angular/issues/17793. To work around this, we defer\n    // telling the form control it has been touched until the next tick.\n    Promise.resolve().then(() => {\n      this._onTouched();\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n\n  private _getAnimationClassForCheckStateTransition(\n    oldState: TransitionCheckState,\n    newState: TransitionCheckState,\n  ): string {\n    // Don't transition if animations are disabled.\n    if (this._animationMode === 'NoopAnimations') {\n      return '';\n    }\n\n    switch (oldState) {\n      case TransitionCheckState.Init:\n        // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or\n        // [checked] bound to it.\n        if (newState === TransitionCheckState.Checked) {\n          return this._animationClasses.uncheckedToChecked;\n        } else if (newState == TransitionCheckState.Indeterminate) {\n          return this._checked\n            ? this._animationClasses.checkedToIndeterminate\n            : this._animationClasses.uncheckedToIndeterminate;\n        }\n        break;\n      case TransitionCheckState.Unchecked:\n        return newState === TransitionCheckState.Checked\n          ? this._animationClasses.uncheckedToChecked\n          : this._animationClasses.uncheckedToIndeterminate;\n      case TransitionCheckState.Checked:\n        return newState === TransitionCheckState.Unchecked\n          ? this._animationClasses.checkedToUnchecked\n          : this._animationClasses.checkedToIndeterminate;\n      case TransitionCheckState.Indeterminate:\n        return newState === TransitionCheckState.Checked\n          ? this._animationClasses.indeterminateToChecked\n          : this._animationClasses.indeterminateToUnchecked;\n    }\n\n    return '';\n  }\n\n  /**\n   * Syncs the indeterminate value with the checkbox DOM node.\n   *\n   * We sync `indeterminate` directly on the DOM node, because in Ivy the check for whether a\n   * property is supported on an element boils down to `if (propName in element)`. Domino's\n   * HTMLInputElement doesn't have an `indeterminate` property so Ivy will warn during\n   * server-side rendering.\n   */\n  private _syncIndeterminate(value: boolean) {\n    const nativeCheckbox = this._inputElement;\n\n    if (nativeCheckbox) {\n      nativeCheckbox.nativeElement.indeterminate = value;\n    }\n  }\n}\n\n/**\n * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,\n * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or\n * disabled. Note that all additional accessibility attributes are taken care of by the component,\n * so there is no need to provide them yourself. However, if you want to omit a label and still\n * have the checkbox be accessible, you may supply an [aria-label] input.\n * See: https://material.io/design/components/selection-controls.html\n */\n@Component({\n  selector: 'mat-checkbox',\n  templateUrl: 'checkbox.html',\n  styleUrls: ['checkbox.css'],\n  exportAs: 'matCheckbox',\n  host: {\n    'class': 'mat-checkbox',\n    '[id]': 'id',\n    '[attr.tabindex]': 'null',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[class.mat-checkbox-indeterminate]': 'indeterminate',\n    '[class.mat-checkbox-checked]': 'checked',\n    '[class.mat-checkbox-disabled]': 'disabled',\n    '[class.mat-checkbox-label-before]': 'labelPosition == \"before\"',\n    '[class._mat-animation-noopable]': `_animationMode === 'NoopAnimations'`,\n  },\n  providers: [MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR],\n  inputs: ['disableRipple', 'color', 'tabIndex'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatCheckbox\n  extends _MatCheckboxBase<MatCheckboxChange>\n  implements AfterViewInit, OnDestroy\n{\n  protected _animationClasses = {\n    uncheckedToChecked: 'mat-checkbox-anim-unchecked-checked',\n    uncheckedToIndeterminate: 'mat-checkbox-anim-unchecked-indeterminate',\n    checkedToUnchecked: 'mat-checkbox-anim-checked-unchecked',\n    checkedToIndeterminate: 'mat-checkbox-anim-checked-indeterminate',\n    indeterminateToChecked: 'mat-checkbox-anim-indeterminate-checked',\n    indeterminateToUnchecked: 'mat-checkbox-anim-indeterminate-unchecked',\n  };\n\n  constructor(\n    elementRef: ElementRef<HTMLElement>,\n    changeDetectorRef: ChangeDetectorRef,\n    private _focusMonitor: FocusMonitor,\n    ngZone: NgZone,\n    @Attribute('tabindex') tabIndex: string,\n    @Optional() @Inject(ANIMATION_MODULE_TYPE) animationMode?: string,\n    @Optional()\n    @Inject(MAT_CHECKBOX_DEFAULT_OPTIONS)\n    options?: MatCheckboxDefaultOptions,\n  ) {\n    super('mat-checkbox-', elementRef, changeDetectorRef, ngZone, tabIndex, animationMode, options);\n  }\n\n  protected _createChangeEvent(isChecked: boolean) {\n    const event = new MatCheckboxChange();\n    event.source = this;\n    event.checked = isChecked;\n    return event;\n  }\n\n  protected _getAnimationTargetElement() {\n    return this._elementRef.nativeElement;\n  }\n\n  override ngAfterViewInit() {\n    super.ngAfterViewInit();\n\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin) {\n        this._onBlur();\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n  }\n\n  /**\n   * Event handler for checkbox input element.\n   * Toggles checked state if element is not disabled.\n   * Do not toggle on (change) event since IE doesn't fire change event when\n   *   indeterminate checkbox is clicked.\n   * @param event\n   */\n  _onInputClick(event: Event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `checkbox` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n    super._handleInputClick();\n  }\n\n  /** Focuses the checkbox. */\n  focus(origin?: FocusOrigin, options?: FocusOptions): void {\n    if (origin) {\n      this._focusMonitor.focusVia(this._inputElement, origin, options);\n    } else {\n      this._inputElement.nativeElement.focus(options);\n    }\n  }\n}\n",null,"<label [attr.for]=\"inputId\" class=\"mat-checkbox-layout\" #label>\n  <span class=\"mat-checkbox-inner-container\"\n       [class.mat-checkbox-inner-container-no-side-margin]=\"!checkboxLabel.textContent || !checkboxLabel.textContent.trim()\">\n    <input #input\n           class=\"mat-checkbox-input cdk-visually-hidden\" type=\"checkbox\"\n           [id]=\"inputId\"\n           [required]=\"required\"\n           [checked]=\"checked\"\n           [attr.value]=\"value\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [tabIndex]=\"tabIndex\"\n           [attr.aria-label]=\"ariaLabel || null\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-checked]=\"_getAriaChecked()\"\n           [attr.aria-describedby]=\"ariaDescribedby\"\n           (change)=\"_onInteractionEvent($event)\"\n           (click)=\"_onInputClick($event)\">\n    <span matRipple class=\"mat-checkbox-ripple mat-focus-indicator\"\n         [matRippleTrigger]=\"label\"\n         [matRippleDisabled]=\"_isRippleDisabled()\"\n         [matRippleRadius]=\"20\"\n         [matRippleCentered]=\"true\"\n         [matRippleAnimation]=\"{enterDuration: _animationMode === 'NoopAnimations' ? 0 : 150}\">\n      <span class=\"mat-ripple-element mat-checkbox-persistent-ripple\"></span>\n    </span>\n    <span class=\"mat-checkbox-frame\"></span>\n    <span class=\"mat-checkbox-background\">\n      <svg version=\"1.1\"\n           focusable=\"false\"\n           class=\"mat-checkbox-checkmark\"\n           viewBox=\"0 0 24 24\"\n           aria-hidden=\"true\">\n        <path class=\"mat-checkbox-checkmark-path\"\n              fill=\"none\"\n              stroke=\"white\"\n              d=\"M4.1,12.7 9,17.6 20.3,6.3\"/>\n      </svg>\n      <!-- Element for rendering the indeterminate state checkbox. -->\n      <span class=\"mat-checkbox-mixedmark\"></span>\n    </span>\n  </span>\n  <span class=\"mat-checkbox-label\" #checkboxLabel (cdkObserveContent)=\"_onLabelTextChange()\">\n    <!-- Add an invisible span so JAWS can read the label -->\n    <span style=\"display:none\">&nbsp;</span>\n    <ng-content></ng-content>\n  </span>\n</label>\n","import {Component, ChangeDetectionStrategy} from '@angular/core';\nimport {MatCheckboxModule} from '@angular/material/checkbox';\nimport {ReactiveFormsModule} from '@angular/forms';\nimport {LayoutEditorMetadata} from '@anglr/dynamic/layout-editor';\nimport {CastPipesModule, HostDisplayBlockStyle} from '@anglr/common';\nimport {FormPipesModule} from '@anglr/common/forms';\nimport {FormComponent, FormComponentBase, FormComponentControlSAPipe} from '@anglr/dynamic/form';\nimport {RelationsEditorMetadata} from '@anglr/dynamic/relations-editor';\n\nimport {MaterialCheckboxLayoutMetadataLoader, MaterialCheckboxRelationsMetadataLoader} from './checkbox.metadata';\nimport {MaterialCheckboxComponentOptions} from './checkbox.options';\n\n/**\n * Component used for displaying material checkbox\n */\n@Component(\n{\n    selector: 'material-checkbox',\n    templateUrl: 'checkbox.component.html',\n    styles: [HostDisplayBlockStyle],\n    standalone: true,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    imports:\n    [\n        FormPipesModule,\n        CastPipesModule,\n        FormComponentControlSAPipe,\n        MatCheckboxModule,\n        ReactiveFormsModule,\n    ]\n})\n@RelationsEditorMetadata(MaterialCheckboxRelationsMetadataLoader)\n@LayoutEditorMetadata(MaterialCheckboxLayoutMetadataLoader)\nexport class MaterialCheckboxSAComponent extends FormComponentBase<MaterialCheckboxComponentOptions, boolean> implements FormComponent<MaterialCheckboxComponentOptions>\n{}",null,"import {ComponentStylingExtension} from '@anglr/dynamic/layout';\nimport {RelationsRegistrationExtension} from '@anglr/dynamic/relations';\n\nimport {MaterialCheckboxSAComponent} from './checkbox.component';\n\n\nexport default MaterialCheckboxSAComponent;\n\nexport const extensions = [ComponentStylingExtension, RelationsRegistrationExtension];","import {Subject} from 'rxjs';\n\n/**\n * Creates dynamic output for property\n */\nexport function DynamicOutput(): PropertyDecorator\n{\n    return function(target: any, propertyKey: string|symbol)\n    {\n        const prop = propertyKey as string;\n\n        Object.defineProperty(target,\n                              `${prop}Change`,\n                              {\n                                  get: function()\n                                  {\n                                      if(!this[`ɵ${prop}Change`])\n                                      {\n                                          this[`ɵ${prop}Change`] = new Subject<void>();\n                                      }\n\n                                      return this[`ɵ${prop}Change`];\n                                  }\n                              });\n\n        Object.defineProperty(target,\n                              prop,\n                              {\n                                  get: function()\n                                  {\n                                      return this[`ɵ${prop}`];\n                                  },\n                                  set: function(value:any)\n                                  {\n                                      this[`ɵ${prop}`] = value;\n                                      this[`${prop}Change`].next();\n                                  }\n                              });\n    };\n}","import {DynamicItemExtension, DynamicItemExtensionBase} from '@anglr/dynamic';\n\nimport {RelationsComponent} from '../../interfaces';\nimport {RelationsComponentManager, RelationsProcessor} from '../../services';\n\n/**\n * Extension that allows registration of component for relations\n */\nexport class RelationsRegistrationExtension extends DynamicItemExtensionBase<unknown, RelationsComponent> implements DynamicItemExtension<unknown, RelationsComponent>\n{\n    //######################### protected properties #########################\n\n    /**\n     * Instance of relations processor\n     */\n    protected relationsProcessor: RelationsProcessor|null = null;\n\n    /**\n     * Instance of component manager\n     */\n    protected componentManager: RelationsComponentManager|null = null;\n\n    //######################### public methods - overrides #########################\n\n    /**\n     * @inheritdoc\n     */\n    protected override async onInit(): Promise<void>\n    {\n        if(!this.injector || !this.metadata || !this.instance)\n        {\n            return;\n        }\n\n        this.relationsProcessor ??= this.injector.get(RelationsProcessor, null);\n        this.componentManager ??= this.injector.get(RelationsComponentManager, null);\n\n        if(!this.relationsProcessor || !this.componentManager)\n        {\n            return;\n        }\n\n        this.componentManager.registerComponent(this.metadata.id, this.instance);\n        await this.relationsProcessor.initialized;\n        this.relationsProcessor.updateRelations(this.metadata.id);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected override onDestroy(): void\n    {\n        if(!this.relationsProcessor || !this.componentManager || !this.metadata)\n        {\n            return;\n        }\n\n        this.relationsProcessor.destroyComponent(this.metadata.id);\n        this.componentManager.unregisterComponent(this.metadata.id);\n    }\n}","import {ElementRef, Injector} from '@angular/core';\nimport {PromiseOr} from '@jscrpt/common';\n\nimport {DynamicItem, DynamicItemExtension, DynamicItemMetadata} from '../interfaces';\n\n/**\n * Dynamic item extension base class\n */\nexport abstract class DynamicItemExtensionBase<TOptions = unknown, TInstance extends DynamicItem = any> implements DynamicItemExtension<TOptions, TInstance>\n{\n    //######################### protected fields #########################\n\n    /**\n     * Injector from extended component\n     */\n    protected injector?: Injector;\n\n    /**\n     * Element that could be extended\n     */\n    protected element?: ElementRef<HTMLElement>;\n\n    /**\n     * Options that stores extension and component data\n     */\n    protected options?: TOptions;\n\n    /**\n     * Instance of dynamic item that is being extended\n     */\n    protected instance?: TInstance;\n\n    /**\n     * Indication whether was extension initialized\n     */\n    protected initialized: boolean = false;\n\n    //######################### constructor #########################\n    constructor(protected metadata: DynamicItemMetadata)\n    {\n    }\n\n    //######################### public methods - implementation of DynamicItemExtension #########################\n\n    /**\n     * @inheritdoc\n     */\n    public async initialize(injector: Injector, element: ElementRef<HTMLElement>, instance: TInstance): Promise<void>\n    {\n        this.initialized = true;\n\n        this.injector = injector;\n        this.element = element;\n        this.instance = instance;\n\n        await this.onInit();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public async optionsChange(options: TOptions): Promise<void>\n    {\n        this.options = options;\n\n        if(!this.initialized)\n        {\n            return;\n        }\n\n        await this.onOptionsChange();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public destroy(): void\n    {\n        this.onDestroy();\n    }\n\n    //######################### protected methods #########################\n\n    /**\n     * Called on initialization of component\n     */\n    protected onInit(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on change of options of component\n     */\n    protected onOptionsChange(): PromiseOr<void>\n    {\n    }\n\n    /**\n     * Called on destruction of component\n     */\n    protected onDestroy(): void\n    {\n    }\n}"],"names":["AsFormControlPipe","constructor","_logger","transform","value","_valueHash","isBlank","FormControl","this","warn","LOGGER","FormComponentBase","LayoutComponentBase","_changeDetector","_element","_injector","_parentControl","super","control","oldValue","valueOutput","patchValue","required","_required","removeValidators","Validators","addValidators","disabled","_disabled","enable","disable","onOptionsSet","options","controlSubscription","unsubscribe","_getFormControl","controlName","FormComponentControlType","_registerValidations","valueChanges","subscribe","parentControl","defaultControlType","initValue","getFormControl","logger","name","getControlForType","i0","FORM_COMPONENT_CONTROL","__decorate","DynamicOutput","InjectionToken","LayoutEditorMetadata","metadataLoader","DynamicClassMetadata","changeDetector","componentElement","injector","extensions","initialized","destroyed","element","extensionsOptions","ngOnDestroy","ext","destroy","onDestroy","ngOnInit","onInit","extension","initialize","afterInit","ngOnChanges","changes","nameof","optionsChange","onOptionsChange","isEmptyObject","onChanges","registerExtensions","invalidateVisuals","detectChanges","_changes","ComponentStylingExtension","DynamicItemExtensionBase","_applyStyling","style","nativeElement","isPresent","lastCssClass","cssClass","split","classList","remove","add","margin","bottom","marginBottom","right","marginRight","top","marginTop","left","marginLeft","padding","paddingBottom","paddingRight","paddingTop","paddingLeft","textStyling","fontSize","fontWeight","toString","_MatCheckboxRequiredValidatorModule","MatCheckboxModule","MatRippleModule","MatCommonModule","ObserversModule","MaterialCheckboxLayoutMetadataLoader","MaterialCheckboxLayoutEditorMetadata","MaterialCheckboxRelationsMetadataLoader","MaterialCheckboxRelationsEditorMetadata","MAT_CHECKBOX_DEFAULT_OPTIONS","providedIn","factory","color","clickAction","nextUniqueId","defaults","MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","MatCheckbox","multi","MatCheckboxChange","_MatCheckboxMixinBase","mixinTabIndex","mixinColor","mixinDisableRipple","mixinDisabled","_elementRef","_MatCheckboxBase","idPrefix","elementRef","_changeDetectorRef","_ngZone","tabIndex","_animationMode","_options","ariaLabel","ariaLabelledby","labelPosition","change","EventEmitter","indeterminateChange","_onTouched","_currentAnimationClass","_currentCheckState","_controlValueAccessorChangeFn","_checked","_indeterminate","defaultColor","parseInt","id","_uniqueId","inputId","coerceBooleanProperty","ngAfterViewInit","_syncIndeterminate","checked","markForCheck","newValue","indeterminate","changed","_transitionCheckState","emit","_isRippleDisabled","disableRipple","_onLabelTextChange","writeValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","_getAriaChecked","newState","oldState","_getAnimationTargetElement","_getAnimationClassForCheckStateTransition","length","animationClass","runOutsideAngular","setTimeout","_emitChangeEvent","_createChangeEvent","_inputElement","toggle","_handleInputClick","Promise","resolve","then","_onInteractionEvent","event","stopPropagation","_onBlur","_animationClasses","uncheckedToChecked","checkedToIndeterminate","uncheckedToIndeterminate","checkedToUnchecked","indeterminateToChecked","indeterminateToUnchecked","nativeCheckbox","MatRipple","changeDetectorRef","_focusMonitor","ngZone","animationMode","isChecked","source","monitor","focusOrigin","stopMonitoring","_onInputClick","focus","origin","focusVia","ANIMATION_MODULE_TYPE","i2","MaterialCheckboxSAComponent","FormPipesModule","i1","CastPipesModule","i3","ReactiveFormsModule","i4","RelationsEditorMetadata","RelationsRegistrationExtension","target","propertyKey","prop","Object","defineProperty","get","Subject","set","next","relationsProcessor","componentManager","metadata","instance","RelationsProcessor","RelationsComponentManager","registerComponent","updateRelations","destroyComponent","unregisterComponent"],"sourceRoot":""}