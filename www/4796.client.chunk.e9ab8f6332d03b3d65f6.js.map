{"version":3,"file":"4796.client.chunk.e9ab8f6332d03b3d65f6.js","mappings":"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","sources":["webpack://ng-universal-demo/../../../packages/core/src/reflection/reflection_capabilities.ts","webpack://ng-universal-demo/../../../packages/core/src/di/metadata_attr.ts","webpack://ng-universal-demo/../../../packages/core/src/di/jit/util.ts","webpack://ng-universal-demo/../../../packages/core/src/linker/ng_module_registration.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/features/host_directives_feature.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/features/copy_definition_feature.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/interfaces/i18n.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/node_manipulation_i18n.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/i18n/i18n_insert_before_index.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/i18n/i18n_util.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/i18n/i18n_apply.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/i18n_icu_container_visitor.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/i18n/i18n_parse.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/i18n/i18n_postprocess.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/i18n.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/jit/environment.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/attribute_interpolation.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/style_map_interpolation.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/style_prop_interpolation.ts","webpack://ng-universal-demo/../../../packages/core/src/sanitization/iframe_attrs_validation.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/jit/util.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/jit/module.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/jit/directive.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/jit/pipe.ts","webpack://ng-universal-demo/../../../packages/core/src/metadata/directives.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/class_map_interpolation.ts","webpack://ng-universal-demo/../../../packages/core/src/render3/instructions/property_interpolation.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isType, Type} from '../interface/type';\nimport {newArray} from '../util/array_utils';\nimport {ANNOTATIONS, PARAMETERS, PROP_METADATA} from '../util/decorators';\nimport {global} from '../util/global';\n\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\n\n\n\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nexport const ES5_DELEGATE_CTOR =\n    /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nexport const ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nexport const ES2015_INHERITED_CLASS_WITH_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nexport const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nexport function isDelegateCtor(typeStr: string): boolean {\n  return ES5_DELEGATE_CTOR.test(typeStr) ||\n      ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\n      (ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr));\n}\n\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\n  private _reflect: any;\n\n  constructor(reflect?: any) {\n    this._reflect = reflect || global['Reflect'];\n  }\n\n  factory<T>(t: Type<T>): (args: any[]) => T {\n    return (...args: any[]) => new t(...args);\n  }\n\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = newArray(paramAnnotations.length);\n    } else {\n      result = newArray(paramTypes.length);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] && paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n\n  private _ownParameters(type: Type<any>, parentCtor: any): any[][]|null {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (isDelegateCtor(typeStr)) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if ((<any>type).parameters && (<any>type).parameters !== parentCtor.parameters) {\n      return (<any>type).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = (<any>type).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && (type as any)[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n        this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return newArray<any[]>(type.length);\n  }\n\n  parameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n\n  private _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[]|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).annotations && (<any>typeOrFunc).annotations !== parentCtor.annotations) {\n      let annotations = (<any>typeOrFunc).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).decorators && (<any>typeOrFunc).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata((<any>typeOrFunc).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return (typeOrFunc as any)[ANNOTATIONS];\n    }\n    return null;\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n\n  private _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]}|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).propMetadata &&\n        (<any>typeOrFunc).propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = (<any>typeOrFunc).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).propDecorators &&\n        (<any>typeOrFunc).propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = (<any>typeOrFunc).propDecorators;\n      const propMetadata = <{[key: string]: any[]}>{};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return (typeOrFunc as any)[PROP_METADATA];\n    }\n    return null;\n  }\n\n  propMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n\n  ownPropMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n}\n\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n\nfunction getParentCtor(ctor: Function): Type<any> {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵɵinjectAttribute} from '../render3/instructions/di_attr';\nimport {makeParamDecorator} from '../util/decorators';\n\n\n/**\n * Type of the Attribute decorator / constructor function.\n *\n * @publicApi\n */\nexport interface AttributeDecorator {\n  /**\n   * Parameter decorator for a directive constructor that designates\n   * a host-element attribute whose value is injected as a constant string literal.\n   *\n   * @usageNotes\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * The following example uses the decorator to inject the string literal `text` in a directive.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n   *\n   * The following example uses the decorator in a component constructor.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\n   *\n   */\n  (name: string): any;\n  new(name: string): Attribute;\n}\n\n/**\n * Type of the Attribute metadata.\n *\n * @publicApi\n */\nexport interface Attribute {\n  /**\n   * The name of the attribute whose value can be injected.\n   */\n  attributeName: string;\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Attribute: AttributeDecorator = makeParamDecorator(\n    'Attribute',\n    (attributeName?: string) =>\n        ({attributeName, __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName!)}));\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3DependencyMetadataFacade} from '../../compiler/compiler_facade';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type} from '../../interface/type';\nimport {ReflectionCapabilities} from '../../reflection/reflection_capabilities';\nimport {Host, Inject, Optional, Self, SkipSelf} from '../metadata';\nimport {Attribute} from '../metadata_attr';\n\nlet _reflect: ReflectionCapabilities|null = null;\n\nexport function getReflect(): ReflectionCapabilities {\n  return (_reflect = _reflect || new ReflectionCapabilities());\n}\n\nexport function reflectDependencies(type: Type<any>): R3DependencyMetadataFacade[] {\n  return convertDependencies(getReflect().parameters(type));\n}\n\nexport function convertDependencies(deps: any[]): R3DependencyMetadataFacade[] {\n  return deps.map(dep => reflectDependency(dep));\n}\n\nfunction reflectDependency(dep: any|any[]): R3DependencyMetadataFacade {\n  const meta: R3DependencyMetadataFacade = {\n    token: null,\n    attribute: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false,\n  };\n\n  if (Array.isArray(dep) && dep.length > 0) {\n    for (let j = 0; j < dep.length; j++) {\n      const param = dep[j];\n      if (param === undefined) {\n        // param may be undefined if type of dep is not set by ngtsc\n        continue;\n      }\n\n      const proto = Object.getPrototypeOf(param);\n\n      if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n        meta.optional = true;\n      } else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n        meta.skipSelf = true;\n      } else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n        meta.self = true;\n      } else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n        meta.host = true;\n      } else if (param instanceof Inject) {\n        meta.token = param.token;\n      } else if (param instanceof Attribute) {\n        if (param.attributeName === undefined) {\n          throw new RuntimeError(\n              RuntimeErrorCode.INVALID_INJECTION_TOKEN,\n              ngDevMode && `Attribute name must be defined.`);\n        }\n        meta.attribute = param.attributeName;\n      } else {\n        meta.token = param;\n      }\n    }\n  } else if (dep === undefined || (Array.isArray(dep) && dep.length === 0)) {\n    meta.token = null;\n  } else {\n    meta.token = dep;\n  }\n  return meta;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Type} from '../interface/type';\nimport {NgModuleType} from '../metadata/ng_module_def';\nimport {getNgModuleDef} from '../render3/definition';\nimport {stringify} from '../util/stringify';\n\n/**\n * Map of module-id to the corresponding NgModule.\n */\nconst modules = new Map<string, NgModuleType>();\n\n/**\n * Whether to check for duplicate NgModule registrations.\n *\n * This can be disabled for testing.\n */\nlet checkForDuplicateNgModules = true;\n\nfunction assertSameOrNotExisting(id: string, type: Type<any>|null, incoming: Type<any>): void {\n  if (type && type !== incoming && checkForDuplicateNgModules) {\n    throw new Error(\n        `Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n  }\n}\n\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\nexport function registerNgModuleType(ngModuleType: NgModuleType, id: string): void {\n  const existing = modules.get(id) || null;\n  assertSameOrNotExisting(id, existing, ngModuleType);\n  modules.set(id, ngModuleType);\n}\n\nexport function clearModulesForTest(): void {\n  modules.clear();\n}\n\nexport function getRegisteredNgModuleType(id: string): NgModuleType|undefined {\n  return modules.get(id);\n}\n\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\nexport function setAllowDuplicateNgModuleIdsForTest(allowDuplicates: boolean): void {\n  checkForDuplicateNgModules = !allowDuplicates;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {resolveForwardRef} from '../../di';\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {Type} from '../../interface/type';\nimport {assertEqual} from '../../util/assert';\nimport {EMPTY_OBJ} from '../../util/empty';\nimport {getComponentDef, getDirectiveDef} from '../definition';\nimport {DirectiveDef, HostDirectiveBindingMap, HostDirectiveDef, HostDirectiveDefs} from '../interfaces/definition';\n\n/** Values that can be used to define a host directive through the `HostDirectivesFeature`. */\ntype HostDirectiveConfig = Type<unknown>|{\n  directive: Type<unknown>;\n  inputs?: string[];\n  outputs?: string[];\n};\n\n/**\n * This feature adds the host directives behavior to a directive definition by patching a\n * function onto it. The expectation is that the runtime will invoke the function during\n * directive matching.\n *\n * For example:\n * ```ts\n * class ComponentWithHostDirective {\n *   static ɵcmp = defineComponent({\n *    type: ComponentWithHostDirective,\n *    features: [ɵɵHostDirectivesFeature([\n *      SimpleHostDirective,\n *      {directive: AdvancedHostDirective, inputs: ['foo: alias'], outputs: ['bar']},\n *    ])]\n *  });\n * }\n * ```\n *\n * @codeGenApi\n */\nexport function ɵɵHostDirectivesFeature(rawHostDirectives: HostDirectiveConfig[]|\n                                        (() => HostDirectiveConfig[])) {\n  return (definition: DirectiveDef<unknown>) => {\n    definition.findHostDirectiveDefs = findHostDirectiveDefs;\n    definition.hostDirectives =\n        (Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives()).map(dir => {\n          return typeof dir === 'function' ?\n              {directive: resolveForwardRef(dir), inputs: EMPTY_OBJ, outputs: EMPTY_OBJ} :\n              {\n                directive: resolveForwardRef(dir.directive),\n                inputs: bindingArrayToMap(dir.inputs),\n                outputs: bindingArrayToMap(dir.outputs)\n              };\n        });\n  };\n}\n\nfunction findHostDirectiveDefs(\n    currentDef: DirectiveDef<unknown>, matchedDefs: DirectiveDef<unknown>[],\n    hostDirectiveDefs: HostDirectiveDefs): void {\n  if (currentDef.hostDirectives !== null) {\n    for (const hostDirectiveConfig of currentDef.hostDirectives) {\n      const hostDirectiveDef = getDirectiveDef(hostDirectiveConfig.directive)!;\n\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        validateHostDirective(hostDirectiveConfig, hostDirectiveDef, matchedDefs);\n      }\n\n      // We need to patch the `declaredInputs` so that\n      // `ngOnChanges` can map the properties correctly.\n      patchDeclaredInputs(hostDirectiveDef.declaredInputs, hostDirectiveConfig.inputs);\n\n      // Host directives execute before the host so that its host bindings can be overwritten.\n      findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);\n      hostDirectiveDefs.set(hostDirectiveDef, hostDirectiveConfig);\n      matchedDefs.push(hostDirectiveDef);\n    }\n  }\n}\n\n/**\n * Converts an array in the form of `['publicName', 'alias', 'otherPublicName', 'otherAlias']` into\n * a map in the form of `{publicName: 'alias', otherPublicName: 'otherAlias'}`.\n */\nfunction bindingArrayToMap(bindings: string[]|undefined): HostDirectiveBindingMap {\n  if (bindings === undefined || bindings.length === 0) {\n    return EMPTY_OBJ;\n  }\n\n  const result: HostDirectiveBindingMap = {};\n\n  for (let i = 0; i < bindings.length; i += 2) {\n    result[bindings[i]] = bindings[i + 1];\n  }\n\n  return result;\n}\n\n/**\n * `ngOnChanges` has some leftover legacy ViewEngine behavior where the keys inside the\n * `SimpleChanges` event refer to the *declared* name of the input, not its public name or its\n * minified name. E.g. in `@Input('alias') foo: string`, the name in the `SimpleChanges` object\n * will always be `foo`, and not `alias` or the minified name of `foo` in apps using property\n * minification.\n *\n * This is achieved through the `DirectiveDef.declaredInputs` map that is constructed when the\n * definition is declared. When a property is written to the directive instance, the\n * `NgOnChangesFeature` will try to remap the property name being written to using the\n * `declaredInputs`.\n *\n * Since the host directive input remapping happens during directive matching, `declaredInputs`\n * won't contain the new alias that the input is available under. This function addresses the\n * issue by patching the host directive aliases to the `declaredInputs`. There is *not* a risk of\n * this patching accidentally introducing new inputs to the host directive, because `declaredInputs`\n * is used *only* by the `NgOnChangesFeature` when determining what name is used in the\n * `SimpleChanges` object which won't be reached if an input doesn't exist.\n */\nfunction patchDeclaredInputs(\n    declaredInputs: Record<string, string>, exposedInputs: HostDirectiveBindingMap): void {\n  for (const publicName in exposedInputs) {\n    if (exposedInputs.hasOwnProperty(publicName)) {\n      const remappedPublicName = exposedInputs[publicName];\n      const privateName = declaredInputs[publicName];\n\n      // We *technically* shouldn't be able to hit this case because we can't have multiple\n      // inputs on the same property and we have validations against conflicting aliases in\n      // `validateMappings`. If we somehow did, it would lead to `ngOnChanges` being invoked\n      // with the wrong name so we have a non-user-friendly assertion here just in case.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n          declaredInputs.hasOwnProperty(remappedPublicName)) {\n        assertEqual(\n            declaredInputs[remappedPublicName], declaredInputs[publicName],\n            `Conflicting host directive input alias ${publicName}.`);\n      }\n\n      declaredInputs[remappedPublicName] = privateName;\n    }\n  }\n}\n\n/**\n * Verifies that the host directive has been configured correctly.\n * @param hostDirectiveConfig Host directive configuration object.\n * @param directiveDef Directive definition of the host directive.\n * @param matchedDefs Directives that have been matched so far.\n */\nfunction validateHostDirective(\n    hostDirectiveConfig: HostDirectiveDef<unknown>, directiveDef: DirectiveDef<any>|null,\n    matchedDefs: DirectiveDef<unknown>[]): asserts directiveDef is DirectiveDef<unknown> {\n  const type = hostDirectiveConfig.directive;\n\n  if (directiveDef === null) {\n    if (getComponentDef(type) !== null) {\n      throw new RuntimeError(\n          RuntimeErrorCode.HOST_DIRECTIVE_COMPONENT,\n          `Host directive ${type.name} cannot be a component.`);\n    }\n\n    throw new RuntimeError(\n        RuntimeErrorCode.HOST_DIRECTIVE_UNRESOLVABLE,\n        `Could not resolve metadata for host directive ${type.name}. ` +\n            `Make sure that the ${type.name} class is annotated with an @Directive decorator.`);\n  }\n\n  if (!directiveDef.standalone) {\n    throw new RuntimeError(\n        RuntimeErrorCode.HOST_DIRECTIVE_NOT_STANDALONE,\n        `Host directive ${directiveDef.type.name} must be standalone.`);\n  }\n\n  if (matchedDefs.indexOf(directiveDef) > -1) {\n    throw new RuntimeError(\n        RuntimeErrorCode.DUPLICATE_DIRECTITVE,\n        `Directive ${directiveDef.type.name} matches multiple times on the same element. ` +\n            `Directives can only match an element once.`);\n  }\n\n  validateMappings('input', directiveDef, hostDirectiveConfig.inputs);\n  validateMappings('output', directiveDef, hostDirectiveConfig.outputs);\n}\n\n/**\n * Checks that the host directive inputs/outputs configuration is valid.\n * @param bindingType Kind of binding that is being validated. Used in the error message.\n * @param def Definition of the host directive that is being validated against.\n * @param hostDirectiveBindings Host directive mapping object that shold be validated.\n */\nfunction validateMappings(\n    bindingType: 'input'|'output', def: DirectiveDef<unknown>,\n    hostDirectiveBindings: HostDirectiveBindingMap) {\n  const className = def.type.name;\n  const bindings: Record<string, string> = bindingType === 'input' ? def.inputs : def.outputs;\n\n  for (const publicName in hostDirectiveBindings) {\n    if (hostDirectiveBindings.hasOwnProperty(publicName)) {\n      if (!bindings.hasOwnProperty(publicName)) {\n        throw new RuntimeError(\n            RuntimeErrorCode.HOST_DIRECTIVE_UNDEFINED_BINDING,\n            `Directive ${className} does not have an ${bindingType} with a public name of ${\n                publicName}.`);\n      }\n\n      const remappedPublicName = hostDirectiveBindings[publicName];\n\n      if (bindings.hasOwnProperty(remappedPublicName) &&\n          bindings[remappedPublicName] !== publicName) {\n        throw new RuntimeError(\n            RuntimeErrorCode.HOST_DIRECTIVE_CONFLICTING_ALIAS,\n            `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${\n                remappedPublicName}, because it already has a different ${\n                bindingType} with the same public name.`);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentDef, DirectiveDef} from '../interfaces/definition';\nimport {isComponentDef} from '../interfaces/type_checks';\n\nimport {getSuperType} from './inherit_definition_feature';\n\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `ɵɵCopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS: (keyof DirectiveDef<unknown>)[] = [\n  // The child class should use the providers of its parent.\n  'providersResolver',\n\n  // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such\n  // as inputs, outputs, and host binding functions.\n];\n\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `ɵɵCopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS: Exclude<keyof ComponentDef<unknown>, keyof DirectiveDef<unknown>>[] = [\n  // The child class should use the template function of its parent, including all template\n  // semantics.\n  'template',\n  'decls',\n  'consts',\n  'vars',\n  'onPush',\n  'ngContentSelectors',\n\n  // The child class should use the CSS styles of its parent, including all styling semantics.\n  'styles',\n  'encapsulation',\n\n  // The child class should be checked by the runtime in the same way as its parent.\n  'schemas',\n];\n\n/**\n * Copies the fields not handled by the `ɵɵInheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `ɵɵCopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nexport function ɵɵCopyDefinitionFeature(definition: DirectiveDef<any>|ComponentDef<any>): void {\n  let superType = getSuperType(definition.type)!;\n\n  let superDef: DirectiveDef<any>|ComponentDef<any>|undefined = undefined;\n  if (isComponentDef(definition)) {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵcmp!;\n  } else {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵdir!;\n  }\n\n  // Needed because `definition` fields are readonly.\n  const defAny = (definition as any);\n\n  // Copy over any fields that apply to either directives or components.\n  for (const field of COPY_DIRECTIVE_FIELDS) {\n    defAny[field] = superDef[field];\n  }\n\n  if (isComponentDef(superDef)) {\n    // Copy over any component-specific fields.\n    for (const field of COPY_COMPONENT_FIELDS) {\n      defAny[field] = superDef[field];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SanitizerFn} from './sanitization';\n\n\n/**\n * Stores a list of nodes which need to be removed.\n *\n * Numbers are indexes into the `LView`\n * - index > 0: `removeRNode(lView[0])`\n * - index < 0: `removeICU(~lView[0])`\n */\nexport interface I18nRemoveOpCodes extends Array<number> {\n  __brand__: 'I18nRemoveOpCodes';\n}\n\n/**\n * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n *\n * OpCodes are efficient operations which can be applied to the DOM to update it. (For example to\n * update to a new ICU case requires that we clean up previous elements and create new ones.)\n *\n * OpCodes contain three parts:\n *  1) Parent node index offset. (p)\n *  2) Reference node index offset. (r)\n *  3) The instruction to execute. (i)\n *\n * pppp pppp pppp pppp rrrr rrrr rrrr riii\n * 3322 2222 2222 1111 1111 1110 0000 0000\n * 1098 7654 3210 9876 5432 1098 7654 3210\n *\n * ```\n * var parent = lView[opCode >>> SHIFT_PARENT];\n * var refNode = lView[((opCode & MASK_REF) >>> SHIFT_REF)];\n * var instruction = opCode & MASK_OPCODE;\n * ```\n *\n * See: `I18nCreateOpCodes` for example of usage.\n */\nexport const enum IcuCreateOpCode {\n  /**\n   * Stores shift amount for bits 17-3 that contain reference index.\n   */\n  SHIFT_REF = 1,\n  /**\n   * Stores shift amount for bits 31-17 that contain parent index.\n   */\n  SHIFT_PARENT = 17,\n  /**\n   * Mask for OpCode\n   */\n  MASK_INSTRUCTION = 0b1,\n\n  /**\n   * Mask for the Reference node (bits 16-3)\n   */\n  MASK_REF = 0b11111111111111110,\n  //           11111110000000000\n  //           65432109876543210\n\n  /**\n   * Instruction to append the current node to `PARENT`.\n   */\n  AppendChild = 0b0,\n\n  /**\n   * Instruction to set the attribute of a node.\n   */\n  Attr = 0b1,\n}\n\n\n/**\n * Array storing OpCode for dynamically creating `i18n` blocks.\n *\n * Example:\n * ```ts\n * <I18nCreateOpCode>[\n *   // For adding text nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createTextNode('xyz'));\n *   'xyz', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding element nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createElement('div'));\n *   ELEMENT_MARKER, 'div', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For adding comment nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   lView[1].appendChild(lView[0] = document.createComment(''));\n *   ICU_MARKER, '', 0, 1 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For moving existing nodes to a different location\n *   // --------------------------------------------------\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].appendChild(node);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 0 << SHIFT_REF | AppendChild,\n *\n *   // For removing existing nodes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   removeChild(tView.data(1), node, lView);\n *   1 << SHIFT_REF | Remove,\n *\n *   // For writing attributes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   node.setAttribute('attr', 'value');\n *   1 << SHIFT_REF | Attr, 'attr', 'value'\n * ];\n * ```\n */\nexport interface IcuCreateOpCodes extends Array<number|string|ELEMENT_MARKER|ICU_MARKER|null>,\n                                          I18nDebug {\n  __brand__: 'I18nCreateOpCodes';\n}\n\nexport const enum I18nUpdateOpCode {\n  /**\n   * Stores shift amount for bits 17-2 that contain reference index.\n   */\n  SHIFT_REF = 2,\n  /**\n   * Mask for OpCode\n   */\n  MASK_OPCODE = 0b11,\n\n  /**\n   * Instruction to update a text node.\n   */\n  Text = 0b00,\n  /**\n   * Instruction to update a attribute of a node.\n   */\n  Attr = 0b01,\n  /**\n   * Instruction to switch the current ICU case.\n   */\n  IcuSwitch = 0b10,\n  /**\n   * Instruction to update the current ICU case.\n   */\n  IcuUpdate = 0b11,\n}\n\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ELEMENT_MARKER: ELEMENT_MARKER = {\n  marker: 'element'\n};\nexport interface ELEMENT_MARKER {\n  marker: 'element';\n}\n\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ICU_MARKER: ICU_MARKER = {\n  marker: 'ICU'\n};\n\nexport interface ICU_MARKER {\n  marker: 'ICU';\n}\n\nexport interface I18nDebug {\n  /**\n   * Human readable representation of the OpCode arrays.\n   *\n   * NOTE: This property only exists if `ngDevMode` is set to `true` and it is not present in\n   * production. Its presence is purely to help debug issue in development, and should not be relied\n   * on in production application.\n   */\n  debug?: string[];\n}\n\n/**\n * Array storing OpCode for dynamically creating `i18n` translation DOM elements.\n *\n * This array creates a sequence of `Text` and `Comment` (as ICU anchor) DOM elements. It consists\n * of a pair of `number` and `string` pairs which encode the operations for the creation of the\n * translated block.\n *\n * The number is shifted and encoded according to `I18nCreateOpCode`\n *\n * Pseudocode:\n * ```\n * const i18nCreateOpCodes = [\n *   10 << I18nCreateOpCode.SHIFT, \"Text Node add to DOM\",\n *   11 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.COMMENT, \"Comment Node add to DOM\",\n *   12 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.APPEND_LATER, \"Text Node added later\"\n * ];\n *\n * for(var i=0; i<i18nCreateOpCodes.length; i++) {\n *   const opcode = i18NCreateOpCodes[i++];\n *   const index = opcode >> I18nCreateOpCode.SHIFT;\n *   const text = i18NCreateOpCodes[i];\n *   let node: Text|Comment;\n *   if (opcode & I18nCreateOpCode.COMMENT === I18nCreateOpCode.COMMENT) {\n *     node = lView[~index] = document.createComment(text);\n *   } else {\n *     node = lView[index] = document.createText(text);\n *   }\n *   if (opcode & I18nCreateOpCode.APPEND_EAGERLY !== I18nCreateOpCode.APPEND_EAGERLY) {\n *     parentNode.appendChild(node);\n *   }\n * }\n * ```\n */\nexport interface I18nCreateOpCodes extends Array<number|string>, I18nDebug {\n  __brand__: 'I18nCreateOpCodes';\n}\n\n/**\n * See `I18nCreateOpCodes`\n */\nexport enum I18nCreateOpCode {\n  /**\n   * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n   * `COMMENT`.\n   */\n  SHIFT = 2,\n\n  /**\n   * Should the node be appended to parent immediately after creation.\n   */\n  APPEND_EAGERLY = 0b01,\n\n  /**\n   * If set the node should be comment (rather than a text) node.\n   */\n  COMMENT = 0b10,\n}\n\n\n/**\n * Stores DOM operations which need to be applied to update DOM render tree due to changes in\n * expressions.\n *\n * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change\n * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and\n * higher.) The OpCodes then compare its own change mask against the expression change mask to\n * determine if the OpCodes should execute.\n *\n * NOTE: 32nd bit is special as it says 32nd or higher. This way if we have more than 32 bindings\n * the code still works, but with lower efficiency. (it is unlikely that a translation would have\n * more than 32 bindings.)\n *\n * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n *\n * ## Example\n *\n * Assume\n * ```ts\n *   if (rf & RenderFlags.Update) {\n *    i18nExp(ctx.exp1); // If changed set mask bit 1\n *    i18nExp(ctx.exp2); // If changed set mask bit 2\n *    i18nExp(ctx.exp3); // If changed set mask bit 3\n *    i18nExp(ctx.exp4); // If changed set mask bit 4\n *    i18nApply(0);            // Apply all changes by executing the OpCodes.\n *  }\n * ```\n * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the\n * index of `i18nExp`.\n *\n * ### OpCodes\n * ```ts\n * <I18nUpdateOpCodes>[\n *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n *   // If `changeMask & 0b11`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `8` values and start processing next OpCodes.\n *   0b11, 8,\n *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.\n *   'pre', -4, 'in', -3, 'post',\n *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,\n *\n *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!\">`\n *   // If `changeMask & 0b100`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b100, 4,\n *   // Concatenate `newValue = 'Hello ' + lView[bindIndex -2] + '!';`.\n *   'Hello ', -2, '!',\n *   // Update text: `lView[1].textContent = newValue;`\n *   1 << SHIFT_REF | Text,\n *\n *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n *   // If `changeMask & 0b1000`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `2` values and start processing next OpCodes.\n *   0b1000, 2,\n *   // Concatenate `newValue = lView[bindIndex -1];`.\n *   -1,\n *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,\n *\n *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.\n *   -1, 1,\n *   // Update ICU: `icuUpdateCase(lView[1], 0);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,\n *\n * ];\n * ```\n *\n */\nexport interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null>, I18nDebug {\n  __brand__: 'I18nUpdateOpCodes';\n}\n\n/**\n * Store information for the i18n translation block.\n */\nexport interface TI18n {\n  /**\n   * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n   *\n   * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n   */\n  create: I18nCreateOpCodes;\n\n  /**\n   * A set of OpCodes which will be executed on each change detection to determine if any changes to\n   * DOM are required.\n   */\n  update: I18nUpdateOpCodes;\n}\n\n/**\n * Defines the ICU type of `select` or `plural`\n */\nexport const enum IcuType {\n  select = 0,\n  plural = 1,\n}\n\nexport interface TIcu {\n  /**\n   * Defines the ICU type of `select` or `plural`\n   */\n  type: IcuType;\n\n  /**\n   * Index in `LView` where the anchor node is stored. `<!-- ICU 0:0 -->`\n   */\n  anchorIdx: number;\n\n  /**\n   * Currently selected ICU case pointer.\n   *\n   * `lView[currentCaseLViewIndex]` stores the currently selected case. This is needed to know how\n   * to clean up the current case when transitioning no the new case.\n   *\n   * If the value stored is:\n   * `null`: No current case selected.\n   *   `<0`: A flag which means that the ICU just switched and that `icuUpdate` must be executed\n   *         regardless of the `mask`. (After the execution the flag is cleared)\n   *   `>=0` A currently selected case index.\n   */\n  currentCaseLViewIndex: number;\n\n  /**\n   * A list of case values which the current ICU will try to match.\n   *\n   * The last value is `other`\n   */\n  cases: any[];\n\n  /**\n   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n   */\n  create: IcuCreateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n   */\n  remove: I18nRemoveOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n   */\n  update: I18nUpdateOpCodes[];\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Parsed ICU expression\n */\nexport interface IcuExpression {\n  type: IcuType;\n  mainBinding: number;\n  cases: string[];\n  values: (string|IcuExpression)[][];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDomNode, assertIndexInRange} from '../util/assert';\n\nimport {TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {Renderer} from './interfaces/renderer';\nimport {RElement, RNode} from './interfaces/renderer_dom';\nimport {LView} from './interfaces/view';\nimport {getInsertInFrontOfRNodeWithNoI18n, nativeInsertBefore} from './node_manipulation';\nimport {unwrapRNode} from './util/view_utils';\n\n\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nexport function getInsertInFrontOfRNodeWithI18n(\n    parentTNode: TNode, currentTNode: TNode, lView: LView): RNode|null {\n  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n  const insertBeforeIndex =\n      Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n  } else {\n    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n    return unwrapRNode(lView[insertBeforeIndex]);\n  }\n}\n\n\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function processI18nInsertBefore(\n    renderer: Renderer, childTNode: TNode, lView: LView, childRNode: RNode|RNode[],\n    parentRElement: RElement|null): void {\n  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n  if (Array.isArray(tNodeInsertBeforeIndex)) {\n    // An array indicates that there are i18n nodes that need to be added as children of this\n    // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n    // only now can be added. The first element of the array is the normal index where we should\n    // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n    // `childRNode`.\n    ngDevMode && assertDomNode(childRNode);\n    let i18nParent: RElement|null = childRNode as RElement;\n    let anchorRNode: RNode|null = null;\n    if (!(childTNode.type & TNodeType.AnyRNode)) {\n      anchorRNode = i18nParent;\n      i18nParent = parentRElement;\n    }\n    if (i18nParent !== null && childTNode.componentOffset === -1) {\n      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n        // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n        // see `assertDomNode` below.\n        const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual} from '../../util/assert';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\n\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `ɵɵi18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `ɵɵelementStart` instruction.\n * 3. `ɵɵelementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\nexport function addTNodeAndUpdateInsertBeforeIndex(previousTNodes: TNode[], newTNode: TNode) {\n  // Start with Rule1\n  ngDevMode &&\n      assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n\n  previousTNodes.push(newTNode);\n  if (previousTNodes.length > 1) {\n    for (let i = previousTNodes.length - 2; i >= 0; i--) {\n      const existingTNode = previousTNodes[i];\n      // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n      // It is safe to ignore them.\n      if (!isI18nText(existingTNode)) {\n        if (isNewTNodeCreatedBefore(existingTNode, newTNode) &&\n            getInsertBeforeIndex(existingTNode) === null) {\n          // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n          // then add the `insertBeforeIndex`.\n          setInsertBeforeIndex(existingTNode, newTNode.index);\n        }\n      }\n    }\n  }\n}\n\nfunction isI18nText(tNode: TNode): boolean {\n  return !(tNode.type & TNodeType.Placeholder);\n}\n\nfunction isNewTNodeCreatedBefore(existingTNode: TNode, newTNode: TNode): boolean {\n  return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\n\nfunction getInsertBeforeIndex(tNode: TNode): number|null {\n  const index = tNode.insertBeforeIndex;\n  return Array.isArray(index) ? index[0] : index;\n}\n\nfunction setInsertBeforeIndex(tNode: TNode, value: number): void {\n  const index = tNode.insertBeforeIndex;\n  if (Array.isArray(index)) {\n    // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n    index[0] = value;\n  } else {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    tNode.insertBeforeIndex = value;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertGreaterThan, assertGreaterThanOrEqual, throwError} from '../../util/assert';\nimport {assertTIcu, assertTNode} from '../assert';\nimport {createTNodeAtIndex} from '../instructions/shared';\nimport {IcuCreateOpCode, TIcu} from '../interfaces/i18n';\nimport {TIcuContainerNode, TNode, TNodeType} from '../interfaces/node';\nimport {LView, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {setI18nHandling} from '../node_manipulation';\nimport {getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore} from '../node_manipulation_i18n';\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\n\n\n/**\n * Retrieve `TIcu` at a given `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be read from.\n */\nexport function getTIcu(tView: TView, index: number): TIcu|null {\n  const value = tView.data[index] as null | TIcu | TIcuContainerNode | string;\n  if (value === null || typeof value === 'string') return null;\n  if (ngDevMode &&\n      !(value.hasOwnProperty('tViews') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n    throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n  }\n  // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n  // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n  // will be just two cases which fits into the browser inline cache (inline cache can take up to\n  // 4)\n  const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value as TIcu :\n                                                               (value as TIcuContainerNode).value;\n  ngDevMode && assertTIcu(tIcu);\n  return tIcu;\n}\n\n/**\n * Store `TIcu` at a give `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be stored at in `Tview.data`\n * @param tIcu The TIcu to store.\n */\nexport function setTIcu(tView: TView, index: number, tIcu: TIcu): void {\n  const tNode = tView.data[index] as null | TIcuContainerNode;\n  ngDevMode &&\n      assertEqual(\n          tNode === null || tNode.hasOwnProperty('tViews'), true,\n          'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n  if (tNode === null) {\n    tView.data[index] = tIcu;\n  } else {\n    ngDevMode && assertTNodeType(tNode, TNodeType.Icu);\n    tNode.value = tIcu;\n  }\n}\n\n/**\n * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n *\n * See `TNode.insertBeforeIndex`\n */\nexport function setTNodeInsertBeforeIndex(tNode: TNode, index: number) {\n  ngDevMode && assertTNode(tNode);\n  let insertBeforeIndex = tNode.insertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    insertBeforeIndex = tNode.insertBeforeIndex =\n        [null!/* may be updated to number later */, index];\n  } else {\n    assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n    (insertBeforeIndex as number[]).push(index);\n  }\n}\n\n/**\n * Create `TNode.type=TNodeType.Placeholder` node.\n *\n * See `TNodeType.Placeholder` for more information.\n */\nexport function createTNodePlaceholder(\n    tView: TView, previousTNodes: TNode[], index: number): TNode {\n  const tNode = createTNodeAtIndex(tView, index, TNodeType.Placeholder, null, null);\n  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n  return tNode;\n}\n\n\n/**\n * Returns current ICU case.\n *\n * ICU cases are stored as index into the `TIcu.cases`.\n * At times it is necessary to communicate that the ICU case just switched and that next ICU update\n * should update all bindings regardless of the mask. In such a case the we store negative numbers\n * for cases which have just been switched. This function removes the negative flag.\n */\nexport function getCurrentICUCaseIndex(tIcu: TIcu, lView: LView) {\n  const currentCase: number|null = lView[tIcu.currentCaseLViewIndex];\n  return currentCase === null ? currentCase : (currentCase < 0 ? ~currentCase : currentCase);\n}\n\nexport function getParentFromIcuCreateOpCode(mergedCode: number): number {\n  return mergedCode >>> IcuCreateOpCode.SHIFT_PARENT;\n}\n\nexport function getRefFromIcuCreateOpCode(mergedCode: number): number {\n  return (mergedCode & IcuCreateOpCode.MASK_REF) >>> IcuCreateOpCode.SHIFT_REF;\n}\n\nexport function getInstructionFromIcuCreateOpCode(mergedCode: number): number {\n  return mergedCode & IcuCreateOpCode.MASK_INSTRUCTION;\n}\n\nexport function icuCreateOpCode(opCode: IcuCreateOpCode, parentIdx: number, refIdx: number) {\n  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n  ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n  return opCode | parentIdx << IcuCreateOpCode.SHIFT_PARENT | refIdx << IcuCreateOpCode.SHIFT_REF;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../../errors';\nimport {getPluralCase} from '../../i18n/localization';\nimport {assertDefined, assertDomNode, assertEqual, assertGreaterThan, assertIndexInRange, throwError} from '../../util/assert';\nimport {assertIndexInExpandoRange, assertTIcu} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {elementPropertyInternal, setElementAttribute} from '../instructions/shared';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes, IcuType, TI18n, TIcu} from '../interfaces/i18n';\nimport {TNode} from '../interfaces/node';\nimport {RElement, RNode, RText} from '../interfaces/renderer_dom';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\nimport {createCommentNode, createElementNode, createTextNode, nativeInsertBefore, nativeParentNode, nativeRemoveNode, updateTextNode} from '../node_manipulation';\nimport {getBindingIndex} from '../state';\nimport {renderStringify} from '../util/stringify_utils';\nimport {getNativeByIndex, unwrapRNode} from '../util/view_utils';\n\nimport {getLocaleId} from './i18n_locale_id';\nimport {getCurrentICUCaseIndex, getParentFromIcuCreateOpCode, getRefFromIcuCreateOpCode, getTIcu} from './i18n_util';\n\n\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `ɵɵi18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `ɵɵi18nExp` then all changes past 32nd `ɵɵi18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\nlet changeMask = 0b0;\n\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `ɵɵi18nExp`\n */\nlet changeMaskCounter = 0;\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `ɵɵi18nExp`.\n *\n * @param hasChange did `ɵɵi18nExp` detect a change.\n */\nexport function setMaskBit(hasChange: boolean) {\n  if (hasChange) {\n    changeMask = changeMask | (1 << Math.min(changeMaskCounter, 31));\n  }\n  changeMaskCounter++;\n}\n\nexport function applyI18n(tView: TView, lView: LView, index: number) {\n  if (changeMaskCounter > 0) {\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const tI18n = tView.data[index] as TI18n | I18nUpdateOpCodes;\n    // When `index` points to an `ɵɵi18nAttributes` then we have an array otherwise `TI18n`\n    const updateOpCodes: I18nUpdateOpCodes =\n        Array.isArray(tI18n) ? tI18n as I18nUpdateOpCodes : (tI18n as TI18n).update;\n    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n  }\n  // Reset changeMask & maskBit to default for the next update cycle\n  changeMask = 0b0;\n  changeMaskCounter = 0;\n}\n\n\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\nexport function applyCreateOpCodes(\n    lView: LView, createOpCodes: I18nCreateOpCodes, parentRNode: RElement|null,\n    insertInFrontOf: RElement|null): void {\n  const renderer = lView[RENDERER];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++] as any;\n    const text = createOpCodes[i] as string;\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow =\n        (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    let rNode = lView[index];\n    if (rNode === null) {\n      // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n      // case which was already instantiated, no need to create new DOM nodes.\n      rNode = lView[index] =\n          isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n    }\n    if (appendNow && parentRNode !== null) {\n      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n    }\n  }\n}\n\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\nexport function applyMutableOpCodes(\n    tView: TView, mutableOpCodes: IcuCreateOpCodes, lView: LView, anchorRNode: RNode): void {\n  ngDevMode && assertDomNode(anchorRNode);\n  const renderer = lView[RENDERER];\n  // `rootIdx` represents the node into which all inserts happen.\n  let rootIdx: number|null = null;\n  // `rootRNode` represents the real node into which we insert. This can be different from\n  // `lView[rootIdx]` if we have projection.\n  //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n  //    LView which has no parent.)\n  //  - `RElement` The element representing the root after taking projection into account.\n  let rootRNode!: RElement|null;\n  for (let i = 0; i < mutableOpCodes.length; i++) {\n    const opCode = mutableOpCodes[i];\n    if (typeof opCode == 'string') {\n      const textNodeIndex = mutableOpCodes[++i] as number;\n      if (lView[textNodeIndex] === null) {\n        ngDevMode && ngDevMode.rendererCreateTextNode++;\n        ngDevMode && assertIndexInRange(lView, textNodeIndex);\n        lView[textNodeIndex] = createTextNode(renderer, opCode);\n      }\n    } else if (typeof opCode == 'number') {\n      switch (opCode & IcuCreateOpCode.MASK_INSTRUCTION) {\n        case IcuCreateOpCode.AppendChild:\n          const parentIdx = getParentFromIcuCreateOpCode(opCode);\n          if (rootIdx === null) {\n            // The first operation should save the `rootIdx` because the first operation\n            // must insert into the root. (Only subsequent operations can insert into a dynamic\n            // parent)\n            rootIdx = parentIdx;\n            rootRNode = nativeParentNode(renderer, anchorRNode);\n          }\n          let insertInFrontOf: RNode|null;\n          let parentRNode: RElement|null;\n          if (parentIdx === rootIdx) {\n            insertInFrontOf = anchorRNode;\n            parentRNode = rootRNode;\n          } else {\n            insertInFrontOf = null;\n            parentRNode = unwrapRNode(lView[parentIdx]) as RElement;\n          }\n          // FIXME(misko): Refactor with `processI18nText`\n          if (parentRNode !== null) {\n            // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n            // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n            // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n            // get picked up and added.\n            ngDevMode && assertDomNode(parentRNode);\n            const refIdx = getRefFromIcuCreateOpCode(opCode);\n            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n            // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n            // which can't have components.\n            const child = lView[refIdx] as RElement;\n            ngDevMode && assertDomNode(child);\n            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n            const tIcu = getTIcu(tView, refIdx);\n            if (tIcu !== null && typeof tIcu === 'object') {\n              // If we just added a comment node which has ICU then that ICU may have already been\n              // rendered and therefore we need to re-add it here.\n              ngDevMode && assertTIcu(tIcu);\n              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n              if (caseIndex !== null) {\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n              }\n            }\n          }\n          break;\n        case IcuCreateOpCode.Attr:\n          const elementNodeIndex = opCode >>> IcuCreateOpCode.SHIFT_REF;\n          const attrName = mutableOpCodes[++i] as string;\n          const attrValue = mutableOpCodes[++i] as string;\n          // This code is used for ICU expressions only, since we don't support\n          // directives/components in ICUs, we don't need to worry about inputs here\n          setElementAttribute(\n              renderer, getNativeByIndex(elementNodeIndex, lView) as RElement, null, null, attrName,\n              attrValue, null);\n          break;\n        default:\n          if (ngDevMode) {\n            throw new RuntimeError(\n                RuntimeErrorCode.INVALID_I18N_STRUCTURE,\n                `Unable to determine the type of mutate operation for \"${opCode}\"`);\n          }\n      }\n    } else {\n      switch (opCode) {\n        case ICU_MARKER:\n          const commentValue = mutableOpCodes[++i] as string;\n          const commentNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[commentNodeIndex] === null) {\n            ngDevMode &&\n                assertEqual(\n                    typeof commentValue, 'string',\n                    `Expected \"${commentValue}\" to be a comment node value`);\n            ngDevMode && ngDevMode.rendererCreateComment++;\n            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n            const commentRNode = lView[commentNodeIndex] =\n                createCommentNode(renderer, commentValue);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(commentRNode, lView);\n          }\n          break;\n        case ELEMENT_MARKER:\n          const tagName = mutableOpCodes[++i] as string;\n          const elementNodeIndex = mutableOpCodes[++i] as number;\n          if (lView[elementNodeIndex] === null) {\n            ngDevMode &&\n                assertEqual(\n                    typeof tagName, 'string',\n                    `Expected \"${tagName}\" to be an element node tag name`);\n\n            ngDevMode && ngDevMode.rendererCreateElement++;\n            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n            const elementRNode = lView[elementNodeIndex] =\n                createElementNode(renderer, tagName, null);\n            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n            attachPatchData(elementRNode, lView);\n          }\n          break;\n        default:\n          ngDevMode &&\n              throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n      }\n    }\n  }\n}\n\n\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\nexport function applyUpdateOpCodes(\n    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, bindingsStartIndex: number,\n    changeMask: number) {\n  for (let i = 0; i < updateOpCodes.length; i++) {\n    // bit code to check if we should apply the next update\n    const checkBit = updateOpCodes[i] as number;\n    // Number of opCodes to skip until next set of update codes\n    const skipCodes = updateOpCodes[++i] as number;\n    if (checkBit & changeMask) {\n      // The value has been updated since last checked\n      let value = '';\n      for (let j = i + 1; j <= (i + skipCodes); j++) {\n        const opCode = updateOpCodes[j];\n        if (typeof opCode == 'string') {\n          value += opCode;\n        } else if (typeof opCode == 'number') {\n          if (opCode < 0) {\n            // Negative opCode represent `i18nExp` values offset.\n            value += renderStringify(lView[bindingsStartIndex - opCode]);\n          } else {\n            const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n              case I18nUpdateOpCode.Attr:\n                const propName = updateOpCodes[++j] as string;\n                const sanitizeFn = updateOpCodes[++j] as SanitizerFn | null;\n                const tNodeOrTagName = tView.data[nodeIndex] as TNode | string;\n                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n                if (typeof tNodeOrTagName === 'string') {\n                  // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                  // not have TNode), in which case we know that there are no directives, and hence\n                  // we use attribute setting.\n                  setElementAttribute(\n                      lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value,\n                      sanitizeFn);\n                } else {\n                  elementPropertyInternal(\n                      tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn,\n                      false);\n                }\n                break;\n              case I18nUpdateOpCode.Text:\n                const rText = lView[nodeIndex] as RText | null;\n                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                break;\n              case I18nUpdateOpCode.IcuSwitch:\n                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex)!, lView, value);\n                break;\n              case I18nUpdateOpCode.IcuUpdate:\n                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex)!, bindingsStartIndex, lView);\n                break;\n            }\n          }\n        }\n      }\n    } else {\n      const opCode = updateOpCodes[i + 1] as number;\n      if (opCode > 0 && (opCode & I18nUpdateOpCode.MASK_OPCODE) === I18nUpdateOpCode.IcuUpdate) {\n        // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n        // we still need to execute `icuUpdateCase` because the case has changed recently due to\n        // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n        // pairs.)\n        const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n        const tIcu = getTIcu(tView, nodeIndex)!;\n        const currentIndex = lView[tIcu.currentCaseLViewIndex];\n        if (currentIndex < 0) {\n          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n        }\n      }\n    }\n    i += skipCodes;\n  }\n}\n\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param lView Current `LView`\n */\nfunction applyIcuUpdateCase(tView: TView, tIcu: TIcu, bindingsStartIndex: number, lView: LView) {\n  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n  if (activeCaseIndex !== null) {\n    let mask = changeMask;\n    if (activeCaseIndex < 0) {\n      // Clear the flag.\n      // Negative number means that the ICU was freshly created and we need to force the update.\n      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n      // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n      mask = -1;\n    }\n    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n  }\n}\n\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\nfunction applyIcuSwitchCase(tView: TView, tIcu: TIcu, lView: LView, value: string) {\n  // Rebuild a new case for this ICU\n  const caseIndex = getCaseIndex(tIcu, value);\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== caseIndex) {\n    applyIcuSwitchCaseRemove(tView, tIcu, lView);\n    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n    if (caseIndex !== null) {\n      // Add the nodes for the new case\n      const anchorRNode = lView[tIcu.anchorIdx];\n      if (anchorRNode) {\n        ngDevMode && assertDomNode(anchorRNode);\n        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n      }\n    }\n  }\n}\n\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\nfunction applyIcuSwitchCaseRemove(tView: TView, tIcu: TIcu, lView: LView) {\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== null) {\n    const removeCodes = tIcu.remove[activeCaseIndex];\n    for (let i = 0; i < removeCodes.length; i++) {\n      const nodeOrIcuIndex = removeCodes[i] as number;\n      if (nodeOrIcuIndex > 0) {\n        // Positive numbers are `RNode`s.\n        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n      } else {\n        // Negative numbers are ICUs\n        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex)!, lView);\n      }\n    }\n  }\n}\n\n\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\nfunction getCaseIndex(icuExpression: TIcu, bindingValue: string): number|null {\n  let index = icuExpression.cases.indexOf(bindingValue);\n  if (index === -1) {\n    switch (icuExpression.type) {\n      case IcuType.plural: {\n        const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n        index = icuExpression.cases.indexOf(resolvedCase);\n        if (index === -1 && resolvedCase !== 'other') {\n          index = icuExpression.cases.indexOf('other');\n        }\n        break;\n      }\n      case IcuType.select: {\n        index = icuExpression.cases.indexOf('other');\n        break;\n      }\n    }\n  }\n  return index === -1 ? null : index;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDomNode, assertNumber, assertNumberInRange} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {assertTIcu, assertTNodeForLView} from '../assert';\nimport {getCurrentICUCaseIndex} from '../i18n/i18n_util';\nimport {I18nRemoveOpCodes, TIcu} from '../interfaces/i18n';\nimport {TIcuContainerNode} from '../interfaces/node';\nimport {RNode} from '../interfaces/renderer_dom';\nimport {LView, TVIEW} from '../interfaces/view';\n\nexport function loadIcuContainerVisitor() {\n  const _stack: any[] = [];\n  let _index: number = -1;\n  let _lView: LView;\n  let _removes: I18nRemoveOpCodes;\n\n  /**\n   * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n   * to determine which root belong to the ICU.\n   *\n   * Example of usage.\n   * ```\n   * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n   * let rNode: RNode|null;\n   * while(rNode = nextRNode()) {\n   *   console.log(rNode);\n   * }\n   * ```\n   *\n   * @param tIcuContainerNode Current `TIcuContainerNode`\n   * @param lView `LView` where the `RNode`s should be looked up.\n   */\n  function icuContainerIteratorStart(tIcuContainerNode: TIcuContainerNode, lView: LView): () =>\n      RNode | null {\n    _lView = lView;\n    while (_stack.length) _stack.pop();\n    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n    enterIcu(tIcuContainerNode.value, lView);\n    return icuContainerIteratorNext;\n  }\n\n  function enterIcu(tIcu: TIcu, lView: LView) {\n    _index = 0;\n    const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n    if (currentCase !== null) {\n      ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n      _removes = tIcu.remove[currentCase];\n    } else {\n      _removes = EMPTY_ARRAY as any;\n    }\n  }\n\n\n  function icuContainerIteratorNext(): RNode|null {\n    if (_index < _removes.length) {\n      const removeOpCode = _removes[_index++] as number;\n      ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n      if (removeOpCode > 0) {\n        const rNode = _lView[removeOpCode];\n        ngDevMode && assertDomNode(rNode);\n        return rNode;\n      } else {\n        _stack.push(_index, _removes);\n        // ICUs are represented by negative indices\n        const tIcuIndex = ~removeOpCode;\n        const tIcu = _lView[TVIEW].data[tIcuIndex] as TIcu;\n        ngDevMode && assertTIcu(tIcu);\n        enterIcu(tIcu, _lView);\n        return icuContainerIteratorNext();\n      }\n    } else {\n      if (_stack.length === 0) {\n        return null;\n      } else {\n        _removes = _stack.pop();\n        _index = _stack.pop();\n        return icuContainerIteratorNext();\n      }\n    }\n  }\n\n  return icuContainerIteratorStart;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {XSS_SECURITY_URL} from '../../error_details_base_url';\nimport {getTemplateContent, URI_ATTRS, VALID_ATTRS, VALID_ELEMENTS} from '../../sanitization/html_sanitizer';\nimport {getInertBodyHelper} from '../../sanitization/inert_body';\nimport {_sanitizeUrl} from '../../sanitization/url_sanitizer';\nimport {assertDefined, assertEqual, assertGreaterThanOrEqual, assertOneOf, assertString} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\nimport {loadIcuContainerVisitor} from '../instructions/i18n_icu_container_visitor';\nimport {allocExpando, createTNodeAtIndex} from '../instructions/shared';\nimport {getDocument} from '../interfaces/document';\nimport {ELEMENT_MARKER, I18nCreateOpCode, I18nCreateOpCodes, I18nRemoveOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, ICU_MARKER, IcuCreateOpCode, IcuCreateOpCodes, IcuExpression, IcuType, TI18n, TIcu} from '../interfaces/i18n';\nimport {TNode, TNodeType} from '../interfaces/node';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {HEADER_OFFSET, LView, TView} from '../interfaces/view';\nimport {getCurrentParentTNode, getCurrentTNode, setCurrentTNode} from '../state';\n\nimport {i18nCreateOpCodesToString, i18nRemoveOpCodesToString, i18nUpdateOpCodesToString, icuCreateOpCodesToString} from './i18n_debug';\nimport {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\nimport {ensureIcuContainerVisitorLoaded} from './i18n_tree_shaking';\nimport {createTNodePlaceholder, icuCreateOpCode, setTIcu, setTNodeInsertBeforeIndex} from './i18n_util';\n\n\n\nconst BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\nconst ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /�(\\d+)�/;\nconst ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\n\nconst MARKER = `�`;\nconst SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\nconst PH_REGEXP = /�(\\/?[#*]\\d+):?\\d*�/gi;\n\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here, since translations\n * might contain this special character.\n */\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value: string): string {\n  return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n\n/**\n * Patch a `debug` property getter on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debugGetter Getter returning a value to patch\n */\nfunction attachDebugGetter<T>(obj: T, debugGetter: (this: T) => any): void {\n  if (ngDevMode) {\n    Object.defineProperty(obj, 'debug', {get: debugGetter, enumerable: false});\n  } else {\n    throw new Error(\n        'This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n  }\n}\n\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `ɵɵi18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\nexport function i18nStartFirstCreatePass(\n    tView: TView, parentTNodeIndex: number, lView: LView, index: number, message: string,\n    subTemplateIndex: number) {\n  const rootTNode = getCurrentParentTNode();\n  const createOpCodes: I18nCreateOpCodes = [] as any;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  const existingTNodeStack: TNode[][] = [[]];\n  if (ngDevMode) {\n    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n\n  message = getTranslationForTemplate(message, subTemplateIndex);\n  const msgParts = replaceNgsp(message).split(PH_REGEXP);\n  for (let i = 0; i < msgParts.length; i++) {\n    let value = msgParts[i];\n    if ((i & 1) === 0) {\n      // Even indexes are text (including bindings & ICU expressions)\n      const parts = i18nParseTextIntoPartsAndICU(value);\n      for (let j = 0; j < parts.length; j++) {\n        let part = parts[j];\n        if ((j & 1) === 0) {\n          // `j` is odd therefore `part` is string\n          const text = part as string;\n          ngDevMode && assertString(text, 'Parsed ICU part should be string');\n          if (text !== '') {\n            i18nStartFirstCreatePassProcessTextNode(\n                tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n          }\n        } else {\n          // `j` is Even therefor `part` is an `ICUExpression`\n          const icuExpression: IcuExpression = part as IcuExpression;\n          // Verify that ICU expression has the right shape. Translations might contain invalid\n          // constructions (while original messages were correct), so ICU parsing at runtime may\n          // not succeed (thus `icuExpression` remains a string).\n          // Note: we intentionally retain the error here by not using `ngDevMode`, because\n          // the value can change based on the locale and users aren't guaranteed to hit\n          // an invalid string while they're developing.\n          if (typeof icuExpression !== 'object') {\n            throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n          }\n          const icuContainerTNode = createTNodeAndAddOpCode(\n              tView, rootTNode, existingTNodeStack[0], lView, createOpCodes,\n              ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n          const icuNodeIndex = icuContainerTNode.index;\n          ngDevMode &&\n              assertGreaterThanOrEqual(\n                  icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n          icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n        }\n      }\n    } else {\n      // Odd indexes are placeholders (elements and sub-templates)\n      // At this point value is something like: '/#1:2' (originally coming from '�/#1:2�')\n      const isClosing = value.charCodeAt(0) === CharCode.SLASH;\n      const type = value.charCodeAt(isClosing ? 1 : 0);\n      ngDevMode && assertOneOf(type, CharCode.STAR, CharCode.HASH);\n      const index = HEADER_OFFSET + Number.parseInt(value.substring((isClosing ? 2 : 1)));\n      if (isClosing) {\n        existingTNodeStack.shift();\n        setCurrentTNode(getCurrentParentTNode()!, false);\n      } else {\n        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n        existingTNodeStack.unshift([]);\n        setCurrentTNode(tNode, true);\n      }\n    }\n  }\n\n  tView.data[index] = <TI18n>{\n    create: createOpCodes,\n    update: updateOpCodes,\n  };\n}\n\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\nfunction createTNodeAndAddOpCode(\n    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], lView: LView,\n    createOpCodes: I18nCreateOpCodes, text: string|null, isICU: boolean): TNode {\n  const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n  let parentTNode = getCurrentParentTNode();\n\n  if (rootTNode === parentTNode) {\n    // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n    // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n    // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n    parentTNode = null;\n  }\n  if (parentTNode === null) {\n    // If we don't have a parent that means that we can eagerly add nodes.\n    // If we have a parent than these nodes can't be added now (as the parent has not been created\n    // yet) and instead the `parentTNode` is responsible for adding it. See\n    // `TNode.insertBeforeIndex`\n    opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n  }\n  if (isICU) {\n    opCode |= I18nCreateOpCode.COMMENT;\n    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n  }\n  createOpCodes.push(opCode, text === null ? '' : text);\n  // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n  // bindings are.\n  const tNode = createTNodeAtIndex(\n      tView, i18nNodeIdx, isICU ? TNodeType.Icu : TNodeType.Text,\n      text === null ? (ngDevMode ? '{{?}}' : '') : text, null);\n  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n  const tNodeIdx = tNode.index;\n  setCurrentTNode(tNode, false /* Text nodes are self closing */);\n  if (parentTNode !== null && rootTNode !== parentTNode) {\n    // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n    // We have to make sure to add ourselves to the parent.\n    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n  }\n  return tNode;\n}\n\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\nfunction i18nStartFirstCreatePassProcessTextNode(\n    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], createOpCodes: I18nCreateOpCodes,\n    updateOpCodes: I18nUpdateOpCodes, lView: LView, text: string): void {\n  const hasBinding = text.match(BINDING_REGEXP);\n  const tNode = createTNodeAndAddOpCode(\n      tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n  if (hasBinding) {\n    generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);\n  }\n}\n\n/**\n * See `i18nAttributes` above.\n */\nexport function i18nAttributesFirstPass(tView: TView, index: number, values: string[]) {\n  const previousElement = getCurrentTNode()!;\n  const previousElementIndex = previousElement.index;\n  const updateOpCodes: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  if (tView.firstCreatePass && tView.data[index] === null) {\n    for (let i = 0; i < values.length; i += 2) {\n      const attrName = values[i];\n      const message = values[i + 1];\n\n      if (message !== '') {\n        // Check if attribute value contains an ICU and throw an error if that's the case.\n        // ICUs in element attributes are not supported.\n        // Note: we intentionally retain the error here by not using `ngDevMode`, because\n        // the `value` can change based on the locale and users aren't guaranteed to hit\n        // an invalid string while they're developing.\n        if (ICU_REGEXP.test(message)) {\n          throw new Error(\n              `ICU expressions are not supported in attributes. Message: \"${message}\".`);\n        }\n\n        // i18n attributes that hit this code path are guaranteed to have bindings, because\n        // the compiler treats static i18n attributes as regular attribute bindings.\n        // Since this may not be the first i18n attribute on this element we need to pass in how\n        // many previous bindings there have already been.\n        generateBindingUpdateOpCodes(\n            updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes),\n            null);\n      }\n    }\n    tView.data[index] = updateOpCodes;\n  }\n}\n\n\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\nfunction generateBindingUpdateOpCodes(\n    updateOpCodes: I18nUpdateOpCodes, str: string, destinationNode: number, attrName: string|null,\n    bindingStart: number, sanitizeFn: SanitizerFn|null): number {\n  ngDevMode &&\n      assertGreaterThanOrEqual(\n          destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n  const maskIndex = updateOpCodes.length;  // Location of mask\n  const sizeIndex = maskIndex + 1;         // location of size for skipping\n  updateOpCodes.push(null, null);          // Alloc space for mask and size\n  const startIndex = maskIndex + 2;        // location of first allocation.\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  const textParts = str.split(BINDING_REGEXP);\n  let mask = 0;\n\n  for (let j = 0; j < textParts.length; j++) {\n    const textValue = textParts[j];\n\n    if (j & 1) {\n      // Odd indexes are bindings\n      const bindingIndex = bindingStart + parseInt(textValue, 10);\n      updateOpCodes.push(-1 - bindingIndex);\n      mask = mask | toMaskBit(bindingIndex);\n    } else if (textValue !== '') {\n      // Even indexes are text\n      updateOpCodes.push(textValue);\n    }\n  }\n\n  updateOpCodes.push(\n      destinationNode << I18nUpdateOpCode.SHIFT_REF |\n      (attrName ? I18nUpdateOpCode.Attr : I18nUpdateOpCode.Text));\n  if (attrName) {\n    updateOpCodes.push(attrName, sanitizeFn);\n  }\n  updateOpCodes[maskIndex] = mask;\n  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n  return mask;\n}\n\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\nfunction countBindings(opCodes: I18nUpdateOpCodes): number {\n  let count = 0;\n  for (let i = 0; i < opCodes.length; i++) {\n    const opCode = opCodes[i];\n    // Bindings are negative numbers.\n    if (typeof opCode === 'number' && opCode < 0) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\nfunction toMaskBit(bindingIndex: number): number {\n  return 1 << Math.min(bindingIndex, 31);\n}\n\nexport function isRootTemplateMessage(subTemplateIndex: number): subTemplateIndex is - 1 {\n  return subTemplateIndex === -1;\n}\n\n\n/**\n * Removes everything inside the sub-templates of a message.\n */\nfunction removeInnerTemplateTranslation(message: string): string {\n  let match;\n  let res = '';\n  let index = 0;\n  let inTemplate = false;\n  let tagMatched;\n\n  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n    if (!inTemplate) {\n      res += message.substring(index, match.index + match[0].length);\n      tagMatched = match[1];\n      inTemplate = true;\n    } else {\n      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n        index = match.index;\n        inTemplate = false;\n      }\n    }\n  }\n\n  ngDevMode &&\n      assertEqual(\n          inTemplate, false,\n          `Tag mismatch: unable to find the end of the sub-template in the translation \"${\n              message}\"`);\n\n  res += message.slice(index);\n  return res;\n}\n\n\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nexport function getTranslationForTemplate(message: string, subTemplateIndex: number) {\n  if (isRootTemplateMessage(subTemplateIndex)) {\n    // We want the root template message, ignore all sub-templates\n    return removeInnerTemplateTranslation(message);\n  } else {\n    // We want a specific sub-template\n    const start =\n        message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n    return removeInnerTemplateTranslation(message.substring(start, end));\n  }\n}\n\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\nexport function icuStart(\n    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n    icuExpression: IcuExpression, anchorIdx: number) {\n  ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n  let bindingMask = 0;\n  const tIcu: TIcu = {\n    type: icuExpression.type,\n    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n    anchorIdx,\n    cases: [],\n    create: [],\n    remove: [],\n    update: []\n  };\n  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n  setTIcu(tView, anchorIdx, tIcu);\n  const values = icuExpression.values;\n  for (let i = 0; i < values.length; i++) {\n    // Each value is an array of strings & other ICU expressions\n    const valueArr = values[i];\n    const nestedIcus: IcuExpression[] = [];\n    for (let j = 0; j < valueArr.length; j++) {\n      const value = valueArr[j];\n      if (typeof value !== 'string') {\n        // It is an nested ICU expression\n        const icuIndex = nestedIcus.push(value as IcuExpression) - 1;\n        // Replace nested ICU expression by a comment node\n        valueArr[j] = `<!--�${icuIndex}�-->`;\n      }\n    }\n    bindingMask = parseIcuCase(\n                      tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i],\n                      valueArr.join(''), nestedIcus) |\n        bindingMask;\n  }\n  if (bindingMask) {\n    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n  }\n}\n\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\nexport function parseICUBlock(pattern: string): IcuExpression {\n  const cases = [];\n  const values: (string|IcuExpression)[][] = [];\n  let icuType = IcuType.plural;\n  let mainBinding = 0;\n  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str: string, binding: string, type: string) {\n    if (type === 'select') {\n      icuType = IcuType.select;\n    } else {\n      icuType = IcuType.plural;\n    }\n    mainBinding = parseInt(binding.slice(1), 10);\n    return '';\n  });\n\n  const parts = i18nParseTextIntoPartsAndICU(pattern) as string[];\n  // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n  for (let pos = 0; pos < parts.length;) {\n    let key = parts[pos++].trim();\n    if (icuType === IcuType.plural) {\n      // Key can be \"=x\", we just want \"x\"\n      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n    }\n    if (key.length) {\n      cases.push(key);\n    }\n\n    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]) as string[];\n    if (cases.length > values.length) {\n      values.push(blocks);\n    }\n  }\n\n  // TODO(ocombe): support ICU expressions in attributes, see #21615\n  return {type: icuType, mainBinding: mainBinding, cases, values};\n}\n\n\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\nexport function i18nParseTextIntoPartsAndICU(pattern: string): (string|IcuExpression)[] {\n  if (!pattern) {\n    return [];\n  }\n\n  let prevPos = 0;\n  const braceStack = [];\n  const results: (string|IcuExpression)[] = [];\n  const braces = /[{}]/g;\n  // lastIndex doesn't get set to 0 so we have to.\n  braces.lastIndex = 0;\n\n  let match;\n  while (match = braces.exec(pattern)) {\n    const pos = match.index;\n    if (match[0] == '}') {\n      braceStack.pop();\n\n      if (braceStack.length == 0) {\n        // End of the block.\n        const block = pattern.substring(prevPos, pos);\n        if (ICU_BLOCK_REGEXP.test(block)) {\n          results.push(parseICUBlock(block));\n        } else {\n          results.push(block);\n        }\n\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        const substring = pattern.substring(prevPos, pos);\n        results.push(substring);\n        prevPos = pos + 1;\n      }\n      braceStack.push('{');\n    }\n  }\n\n  const substring = pattern.substring(prevPos);\n  results.push(substring);\n  return results;\n}\n\n\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\nexport function parseIcuCase(\n    tView: TView, tIcu: TIcu, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n    caseName: string, unsafeCaseHtml: string, nestedIcus: IcuExpression[]): number {\n  const create: IcuCreateOpCodes = [] as any;\n  const remove: I18nRemoveOpCodes = [] as any;\n  const update: I18nUpdateOpCodes = [] as any;\n  if (ngDevMode) {\n    attachDebugGetter(create, icuCreateOpCodesToString);\n    attachDebugGetter(remove, i18nRemoveOpCodesToString);\n    attachDebugGetter(update, i18nUpdateOpCodesToString);\n  }\n  tIcu.cases.push(caseName);\n  tIcu.create.push(create);\n  tIcu.remove.push(remove);\n  tIcu.update.push(update);\n\n  const inertBodyHelper = getInertBodyHelper(getDocument());\n  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n  ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n  const inertRootNode = getTemplateContent(inertBodyElement!) as Element || inertBodyElement;\n  if (inertRootNode) {\n    return walkIcuTree(\n        tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx,\n        nestedIcus, 0);\n  } else {\n    return 0;\n  }\n}\n\nfunction walkIcuTree(\n    tView: TView, tIcu: TIcu, lView: LView, sharedUpdateOpCodes: I18nUpdateOpCodes,\n    create: IcuCreateOpCodes, remove: I18nRemoveOpCodes, update: I18nUpdateOpCodes,\n    parentNode: Element, parentIdx: number, nestedIcus: IcuExpression[], depth: number): number {\n  let bindingMask = 0;\n  let currentNode = parentNode.firstChild;\n  while (currentNode) {\n    const newIndex = allocExpando(tView, lView, 1, null);\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = currentNode as Element;\n        const tagName = element.tagName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n          tView.data[newIndex] = tagName;\n          const elAttrs = element.attributes;\n          for (let i = 0; i < elAttrs.length; i++) {\n            const attr = elAttrs.item(i)!;\n            const lowerAttrName = attr.name.toLowerCase();\n            const hasBinding = !!attr.value.match(BINDING_REGEXP);\n            // we assume the input string is safe, unless it's using a binding\n            if (hasBinding) {\n              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                if (URI_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(\n                      update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                } else {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                }\n              } else {\n                ngDevMode &&\n                    console.warn(\n                        `WARNING: ignoring unsafe attribute value ` +\n                        `${lowerAttrName} on element ${tagName} ` +\n                        `(see ${XSS_SECURITY_URL})`);\n              }\n            } else {\n              addCreateAttribute(create, newIndex, attr);\n            }\n          }\n          // Parse the children of this node (if any)\n          bindingMask = walkIcuTree(\n                            tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update,\n                            currentNode as Element, newIndex, nestedIcus, depth + 1) |\n              bindingMask;\n          addRemoveNode(remove, newIndex, depth);\n        }\n        break;\n      case Node.TEXT_NODE:\n        const value = currentNode.textContent || '';\n        const hasBinding = value.match(BINDING_REGEXP);\n        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n        addRemoveNode(remove, newIndex, depth);\n        if (hasBinding) {\n          bindingMask =\n              generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n        }\n        break;\n      case Node.COMMENT_NODE:\n        // Check if the comment node is a placeholder for a nested ICU\n        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n        if (isNestedIcu) {\n          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n          const icuExpression: IcuExpression = nestedIcus[nestedIcuIndex];\n          // Create the comment node that will anchor the ICU expression\n          addCreateNodeAndAppend(\n              create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx,\n              newIndex);\n          icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n          addRemoveNestedIcu(remove, newIndex, depth);\n        }\n        break;\n    }\n    currentNode = currentNode.nextSibling;\n  }\n  return bindingMask;\n}\n\nfunction addRemoveNode(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(index);\n  }\n}\n\nfunction addRemoveNestedIcu(remove: I18nRemoveOpCodes, index: number, depth: number) {\n  if (depth === 0) {\n    remove.push(~index);  // remove ICU at `index`\n    remove.push(index);   // remove ICU comment at `index`\n  }\n}\n\nfunction addUpdateIcuSwitch(\n    update: I18nUpdateOpCodes, icuExpression: IcuExpression, index: number) {\n  update.push(\n      toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding,\n      index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch);\n}\n\nfunction addUpdateIcuUpdate(update: I18nUpdateOpCodes, bindingMask: number, index: number) {\n  update.push(bindingMask, 1, index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate);\n}\n\nfunction addCreateNodeAndAppend(\n    create: IcuCreateOpCodes, marker: null|ICU_MARKER|ELEMENT_MARKER, text: string,\n    appendToParentIdx: number, createAtIdx: number) {\n  if (marker !== null) {\n    create.push(marker);\n  }\n  create.push(\n      text, createAtIdx,\n      icuCreateOpCode(IcuCreateOpCode.AppendChild, appendToParentIdx, createAtIdx));\n}\n\nfunction addCreateAttribute(create: IcuCreateOpCodes, newIndex: number, attr: Attr) {\n  create.push(newIndex << IcuCreateOpCode.SHIFT_REF | IcuCreateOpCode.Attr, attr.name, attr.value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// i18nPostprocess consts\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n\n// Parsed placeholder structure used in postprocessing (within `i18nPostprocess` function)\n// Contains the following fields: [templateId, isCloseTemplateTag, placeholder]\ntype PostprocessPlaceholder = [number, boolean, string];\n\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function i18nPostprocess(\n    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n  /**\n   * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\n   *\n   * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n   * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\n   * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\n   * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\n   * front of �#6�. The post processing step restores the right order by keeping track of the\n   * template id stack and looks for placeholders that belong to the currently active template.\n   */\n  let result: string = message;\n  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n    const matches: {[key: string]: PostprocessPlaceholder[]} = {};\n    const templateIdsStack: number[] = [ROOT_TEMPLATE_ID];\n    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m: any, phs: string, tmpl: string): string => {\n      const content = phs || tmpl;\n      const placeholders: PostprocessPlaceholder[] = matches[content] || [];\n      if (!placeholders.length) {\n        content.split('|').forEach((placeholder: string) => {\n          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n          placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n        });\n        matches[content] = placeholders;\n      }\n\n      if (!placeholders.length) {\n        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n      }\n\n      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n      let idx = 0;\n      // find placeholder index that matches current template id\n      for (let i = 0; i < placeholders.length; i++) {\n        if (placeholders[i][0] === currentTemplateId) {\n          idx = i;\n          break;\n        }\n      }\n      // update template id stack based on the current tag extracted\n      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n      if (isCloseTemplateTag) {\n        templateIdsStack.pop();\n      } else if (currentTemplateId !== templateId) {\n        templateIdsStack.push(templateId);\n      }\n      // remove processed tag from the list\n      placeholders.splice(idx, 1);\n      return placeholder;\n    });\n  }\n\n  // return current result if no replacements specified\n  if (!Object.keys(replacements).length) {\n    return result;\n  }\n\n  /**\n   * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n   */\n  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end): string => {\n    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n  });\n\n  /**\n   * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n   */\n  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key): string => {\n    return replacements.hasOwnProperty(key) ? replacements[key] as string : match;\n  });\n\n  /**\n   * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\n   * multiple ICUs have the same placeholder name\n   */\n  result = result.replace(PP_ICUS_REGEXP, (match, key): string => {\n    if (replacements.hasOwnProperty(key)) {\n      const list = replacements[key] as string[];\n      if (!list.length) {\n        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n      }\n      return list.shift()!;\n    }\n    return match;\n  });\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../../util/ng_dev_mode';\nimport '../../util/ng_i18n_closure_mode';\n\nimport {assertDefined} from '../../util/assert';\nimport {bindingUpdated} from '../bindings';\nimport {applyCreateOpCodes, applyI18n, setMaskBit} from '../i18n/i18n_apply';\nimport {i18nAttributesFirstPass, i18nStartFirstCreatePass} from '../i18n/i18n_parse';\nimport {i18nPostprocess} from '../i18n/i18n_postprocess';\nimport {TI18n} from '../interfaces/i18n';\nimport {TElementNode, TNodeType} from '../interfaces/node';\nimport {HEADER_OFFSET, T_HOST} from '../interfaces/view';\nimport {getClosestRElement} from '../node_manipulation';\nimport {getCurrentParentTNode, getLView, getTView, nextBindingIndex, setInI18nBlock} from '../state';\nimport {getConstant} from '../util/view_utils';\n\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport function ɵɵi18nStart(\n    index: number, messageIndex: number, subTemplateIndex: number = -1): void {\n  const tView = getTView();\n  const lView = getLView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const message = getConstant<string>(tView.consts, messageIndex)!;\n  const parentTNode = getCurrentParentTNode() as TElementNode | null;\n  if (tView.firstCreatePass) {\n    i18nStartFirstCreatePass(\n        tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message,\n        subTemplateIndex);\n  }\n  const tI18n = tView.data[adjustedIndex] as TI18n;\n  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n  // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n  // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n  const insertInFrontOf = parentTNode && (parentTNode.type & TNodeType.ElementContainer) ?\n      lView[parentTNode.index] :\n      null;\n  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n  setInI18nBlock(true);\n}\n\n\n\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\nexport function ɵɵi18nEnd(): void {\n  setInI18nBlock(false);\n}\n\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nexport function ɵɵi18n(index: number, messageIndex: number, subTemplateIndex?: number): void {\n  ɵɵi18nStart(index, messageIndex, subTemplateIndex);\n  ɵɵi18nEnd();\n}\n\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\nexport function ɵɵi18nAttributes(index: number, attrsIndex: number): void {\n  const tView = getTView();\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const attrs = getConstant<string[]>(tView.consts, attrsIndex)!;\n  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\n\n\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\nexport function ɵɵi18nExp<T>(value: T): typeof ɵɵi18nExp {\n  const lView = getLView();\n  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n  return ɵɵi18nExp;\n}\n\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\nexport function ɵɵi18nApply(index: number) {\n  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\n\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nexport function ɵɵi18nPostprocess(\n    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n  return i18nPostprocess(message, replacements);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {forwardRef, resolveForwardRef} from '../../di/forward_ref';\nimport {ɵɵinject, ɵɵinvalidFactoryDep} from '../../di/injector_compatibility';\nimport {ɵɵdefineInjectable, ɵɵdefineInjector} from '../../di/interface/defs';\nimport {registerNgModuleType} from '../../linker/ng_module_registration';\nimport * as iframe_attrs_validation from '../../sanitization/iframe_attrs_validation';\nimport * as sanitization from '../../sanitization/sanitization';\nimport * as r3 from '../index';\n\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nexport const angularCoreEnv: {[name: string]: Function} =\n    (() => ({\n       'ɵɵattribute': r3.ɵɵattribute,\n       'ɵɵattributeInterpolate1': r3.ɵɵattributeInterpolate1,\n       'ɵɵattributeInterpolate2': r3.ɵɵattributeInterpolate2,\n       'ɵɵattributeInterpolate3': r3.ɵɵattributeInterpolate3,\n       'ɵɵattributeInterpolate4': r3.ɵɵattributeInterpolate4,\n       'ɵɵattributeInterpolate5': r3.ɵɵattributeInterpolate5,\n       'ɵɵattributeInterpolate6': r3.ɵɵattributeInterpolate6,\n       'ɵɵattributeInterpolate7': r3.ɵɵattributeInterpolate7,\n       'ɵɵattributeInterpolate8': r3.ɵɵattributeInterpolate8,\n       'ɵɵattributeInterpolateV': r3.ɵɵattributeInterpolateV,\n       'ɵɵdefineComponent': r3.ɵɵdefineComponent,\n       'ɵɵdefineDirective': r3.ɵɵdefineDirective,\n       'ɵɵdefineInjectable': ɵɵdefineInjectable,\n       'ɵɵdefineInjector': ɵɵdefineInjector,\n       'ɵɵdefineNgModule': r3.ɵɵdefineNgModule,\n       'ɵɵdefinePipe': r3.ɵɵdefinePipe,\n       'ɵɵdirectiveInject': r3.ɵɵdirectiveInject,\n       'ɵɵgetInheritedFactory': r3.ɵɵgetInheritedFactory,\n       'ɵɵinject': ɵɵinject,\n       'ɵɵinjectAttribute': r3.ɵɵinjectAttribute,\n       'ɵɵinvalidFactory': r3.ɵɵinvalidFactory,\n       'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n       'ɵɵtemplateRefExtractor': r3.ɵɵtemplateRefExtractor,\n       'ɵɵresetView': r3.ɵɵresetView,\n       'ɵɵHostDirectivesFeature': r3.ɵɵHostDirectivesFeature,\n       'ɵɵNgOnChangesFeature': r3.ɵɵNgOnChangesFeature,\n       'ɵɵProvidersFeature': r3.ɵɵProvidersFeature,\n       'ɵɵCopyDefinitionFeature': r3.ɵɵCopyDefinitionFeature,\n       'ɵɵInheritDefinitionFeature': r3.ɵɵInheritDefinitionFeature,\n       'ɵɵStandaloneFeature': r3.ɵɵStandaloneFeature,\n       'ɵɵnextContext': r3.ɵɵnextContext,\n       'ɵɵnamespaceHTML': r3.ɵɵnamespaceHTML,\n       'ɵɵnamespaceMathML': r3.ɵɵnamespaceMathML,\n       'ɵɵnamespaceSVG': r3.ɵɵnamespaceSVG,\n       'ɵɵenableBindings': r3.ɵɵenableBindings,\n       'ɵɵdisableBindings': r3.ɵɵdisableBindings,\n       'ɵɵelementStart': r3.ɵɵelementStart,\n       'ɵɵelementEnd': r3.ɵɵelementEnd,\n       'ɵɵelement': r3.ɵɵelement,\n       'ɵɵelementContainerStart': r3.ɵɵelementContainerStart,\n       'ɵɵelementContainerEnd': r3.ɵɵelementContainerEnd,\n       'ɵɵelementContainer': r3.ɵɵelementContainer,\n       'ɵɵpureFunction0': r3.ɵɵpureFunction0,\n       'ɵɵpureFunction1': r3.ɵɵpureFunction1,\n       'ɵɵpureFunction2': r3.ɵɵpureFunction2,\n       'ɵɵpureFunction3': r3.ɵɵpureFunction3,\n       'ɵɵpureFunction4': r3.ɵɵpureFunction4,\n       'ɵɵpureFunction5': r3.ɵɵpureFunction5,\n       'ɵɵpureFunction6': r3.ɵɵpureFunction6,\n       'ɵɵpureFunction7': r3.ɵɵpureFunction7,\n       'ɵɵpureFunction8': r3.ɵɵpureFunction8,\n       'ɵɵpureFunctionV': r3.ɵɵpureFunctionV,\n       'ɵɵgetCurrentView': r3.ɵɵgetCurrentView,\n       'ɵɵrestoreView': r3.ɵɵrestoreView,\n       'ɵɵlistener': r3.ɵɵlistener,\n       'ɵɵprojection': r3.ɵɵprojection,\n       'ɵɵsyntheticHostProperty': r3.ɵɵsyntheticHostProperty,\n       'ɵɵsyntheticHostListener': r3.ɵɵsyntheticHostListener,\n       'ɵɵpipeBind1': r3.ɵɵpipeBind1,\n       'ɵɵpipeBind2': r3.ɵɵpipeBind2,\n       'ɵɵpipeBind3': r3.ɵɵpipeBind3,\n       'ɵɵpipeBind4': r3.ɵɵpipeBind4,\n       'ɵɵpipeBindV': r3.ɵɵpipeBindV,\n       'ɵɵprojectionDef': r3.ɵɵprojectionDef,\n       'ɵɵhostProperty': r3.ɵɵhostProperty,\n       'ɵɵproperty': r3.ɵɵproperty,\n       'ɵɵpropertyInterpolate': r3.ɵɵpropertyInterpolate,\n       'ɵɵpropertyInterpolate1': r3.ɵɵpropertyInterpolate1,\n       'ɵɵpropertyInterpolate2': r3.ɵɵpropertyInterpolate2,\n       'ɵɵpropertyInterpolate3': r3.ɵɵpropertyInterpolate3,\n       'ɵɵpropertyInterpolate4': r3.ɵɵpropertyInterpolate4,\n       'ɵɵpropertyInterpolate5': r3.ɵɵpropertyInterpolate5,\n       'ɵɵpropertyInterpolate6': r3.ɵɵpropertyInterpolate6,\n       'ɵɵpropertyInterpolate7': r3.ɵɵpropertyInterpolate7,\n       'ɵɵpropertyInterpolate8': r3.ɵɵpropertyInterpolate8,\n       'ɵɵpropertyInterpolateV': r3.ɵɵpropertyInterpolateV,\n       'ɵɵpipe': r3.ɵɵpipe,\n       'ɵɵqueryRefresh': r3.ɵɵqueryRefresh,\n       'ɵɵviewQuery': r3.ɵɵviewQuery,\n       'ɵɵloadQuery': r3.ɵɵloadQuery,\n       'ɵɵcontentQuery': r3.ɵɵcontentQuery,\n       'ɵɵreference': r3.ɵɵreference,\n       'ɵɵclassMap': r3.ɵɵclassMap,\n       'ɵɵclassMapInterpolate1': r3.ɵɵclassMapInterpolate1,\n       'ɵɵclassMapInterpolate2': r3.ɵɵclassMapInterpolate2,\n       'ɵɵclassMapInterpolate3': r3.ɵɵclassMapInterpolate3,\n       'ɵɵclassMapInterpolate4': r3.ɵɵclassMapInterpolate4,\n       'ɵɵclassMapInterpolate5': r3.ɵɵclassMapInterpolate5,\n       'ɵɵclassMapInterpolate6': r3.ɵɵclassMapInterpolate6,\n       'ɵɵclassMapInterpolate7': r3.ɵɵclassMapInterpolate7,\n       'ɵɵclassMapInterpolate8': r3.ɵɵclassMapInterpolate8,\n       'ɵɵclassMapInterpolateV': r3.ɵɵclassMapInterpolateV,\n       'ɵɵstyleMap': r3.ɵɵstyleMap,\n       'ɵɵstyleMapInterpolate1': r3.ɵɵstyleMapInterpolate1,\n       'ɵɵstyleMapInterpolate2': r3.ɵɵstyleMapInterpolate2,\n       'ɵɵstyleMapInterpolate3': r3.ɵɵstyleMapInterpolate3,\n       'ɵɵstyleMapInterpolate4': r3.ɵɵstyleMapInterpolate4,\n       'ɵɵstyleMapInterpolate5': r3.ɵɵstyleMapInterpolate5,\n       'ɵɵstyleMapInterpolate6': r3.ɵɵstyleMapInterpolate6,\n       'ɵɵstyleMapInterpolate7': r3.ɵɵstyleMapInterpolate7,\n       'ɵɵstyleMapInterpolate8': r3.ɵɵstyleMapInterpolate8,\n       'ɵɵstyleMapInterpolateV': r3.ɵɵstyleMapInterpolateV,\n       'ɵɵstyleProp': r3.ɵɵstyleProp,\n       'ɵɵstylePropInterpolate1': r3.ɵɵstylePropInterpolate1,\n       'ɵɵstylePropInterpolate2': r3.ɵɵstylePropInterpolate2,\n       'ɵɵstylePropInterpolate3': r3.ɵɵstylePropInterpolate3,\n       'ɵɵstylePropInterpolate4': r3.ɵɵstylePropInterpolate4,\n       'ɵɵstylePropInterpolate5': r3.ɵɵstylePropInterpolate5,\n       'ɵɵstylePropInterpolate6': r3.ɵɵstylePropInterpolate6,\n       'ɵɵstylePropInterpolate7': r3.ɵɵstylePropInterpolate7,\n       'ɵɵstylePropInterpolate8': r3.ɵɵstylePropInterpolate8,\n       'ɵɵstylePropInterpolateV': r3.ɵɵstylePropInterpolateV,\n       'ɵɵclassProp': r3.ɵɵclassProp,\n       'ɵɵadvance': r3.ɵɵadvance,\n       'ɵɵtemplate': r3.ɵɵtemplate,\n       'ɵɵtext': r3.ɵɵtext,\n       'ɵɵtextInterpolate': r3.ɵɵtextInterpolate,\n       'ɵɵtextInterpolate1': r3.ɵɵtextInterpolate1,\n       'ɵɵtextInterpolate2': r3.ɵɵtextInterpolate2,\n       'ɵɵtextInterpolate3': r3.ɵɵtextInterpolate3,\n       'ɵɵtextInterpolate4': r3.ɵɵtextInterpolate4,\n       'ɵɵtextInterpolate5': r3.ɵɵtextInterpolate5,\n       'ɵɵtextInterpolate6': r3.ɵɵtextInterpolate6,\n       'ɵɵtextInterpolate7': r3.ɵɵtextInterpolate7,\n       'ɵɵtextInterpolate8': r3.ɵɵtextInterpolate8,\n       'ɵɵtextInterpolateV': r3.ɵɵtextInterpolateV,\n       'ɵɵi18n': r3.ɵɵi18n,\n       'ɵɵi18nAttributes': r3.ɵɵi18nAttributes,\n       'ɵɵi18nExp': r3.ɵɵi18nExp,\n       'ɵɵi18nStart': r3.ɵɵi18nStart,\n       'ɵɵi18nEnd': r3.ɵɵi18nEnd,\n       'ɵɵi18nApply': r3.ɵɵi18nApply,\n       'ɵɵi18nPostprocess': r3.ɵɵi18nPostprocess,\n       'ɵɵresolveWindow': r3.ɵɵresolveWindow,\n       'ɵɵresolveDocument': r3.ɵɵresolveDocument,\n       'ɵɵresolveBody': r3.ɵɵresolveBody,\n       'ɵɵsetComponentScope': r3.ɵɵsetComponentScope,\n       'ɵɵsetNgModuleScope': r3.ɵɵsetNgModuleScope,\n       'ɵɵregisterNgModuleType': registerNgModuleType,\n\n       'ɵɵsanitizeHtml': sanitization.ɵɵsanitizeHtml,\n       'ɵɵsanitizeStyle': sanitization.ɵɵsanitizeStyle,\n       'ɵɵsanitizeResourceUrl': sanitization.ɵɵsanitizeResourceUrl,\n       'ɵɵsanitizeScript': sanitization.ɵɵsanitizeScript,\n       'ɵɵsanitizeUrl': sanitization.ɵɵsanitizeUrl,\n       'ɵɵsanitizeUrlOrResourceUrl': sanitization.ɵɵsanitizeUrlOrResourceUrl,\n       'ɵɵtrustConstantHtml': sanitization.ɵɵtrustConstantHtml,\n       'ɵɵtrustConstantResourceUrl': sanitization.ɵɵtrustConstantResourceUrl,\n       'ɵɵvalidateIframeAttribute': iframe_attrs_validation.ɵɵvalidateIframeAttribute,\n\n       'forwardRef': forwardRef,\n       'resolveForwardRef': resolveForwardRef,\n     }))();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {getBindingIndex, getLView, getSelectedTNode, getTView} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {elementAttributeInternal, storePropertyBindingMetadata} from './shared';\n\n\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate1(\n    attrName: string, prefix: string, v0: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return ɵɵattributeInterpolate1;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate2(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return ɵɵattributeInterpolate2;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate3(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1,\n            suffix);\n  }\n  return ɵɵattributeInterpolate3;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate4(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2,\n            suffix);\n  }\n  return ɵɵattributeInterpolate4;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate5(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2,\n            i3, suffix);\n  }\n  return ɵɵattributeInterpolate5;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate6(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string, sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2,\n            i3, i4, suffix);\n  }\n  return ɵɵattributeInterpolate6;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate7(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2,\n            i3, i4, i5, suffix);\n  }\n  return ɵɵattributeInterpolate7;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolate8(\n    attrName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn, namespace?: string): typeof ɵɵattributeInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2,\n            i3, i4, i5, i6, suffix);\n  }\n  return ɵɵattributeInterpolate8;\n}\n\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵattributeInterpolateV(\n    attrName: string, values: any[], sanitizer?: SanitizerFn,\n    namespace?: string): typeof ɵɵattributeInterpolateV {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          getTView().data, tNode, 'attr.' + attrName,\n          getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n  return ɵɵattributeInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {ɵɵstyleMap} from './styling';\n\n\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function ɵɵstyleMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  ɵɵstyleMap(interpolatedValue);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLView,} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingProperty} from './styling';\n\n\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate1(\n    prop: string, prefix: string, v0: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate1;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate2(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate2;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate3(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate3;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate4(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, valueSuffix?: string|null): typeof ɵɵstylePropInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate4;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate5(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate5;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate6(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate6;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate7(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    valueSuffix?: string|null): typeof ɵɵstylePropInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate7;\n}\n\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolate8(\n    prop: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, valueSuffix?: string|null): typeof ɵɵstylePropInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate8;\n}\n\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵstylePropInterpolateV(\n    prop: string, values: any[], valueSuffix?: string|null): typeof ɵɵstylePropInterpolateV {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {RuntimeError, RuntimeErrorCode} from '../errors';\nimport {getTemplateLocationDetails} from '../render3/instructions/element_validation';\nimport {TNodeType} from '../render3/interfaces/node';\nimport {RComment, RElement} from '../render3/interfaces/renderer_dom';\nimport {RENDERER} from '../render3/interfaces/view';\nimport {nativeRemoveNode} from '../render3/node_manipulation';\nimport {getLView, getSelectedTNode} from '../render3/state';\nimport {getNativeByTNode} from '../render3/util/view_utils';\nimport {trustedHTMLFromString} from '../util/security/trusted_types';\n\n\n/**\n * Validation function invoked at runtime for each binding that might potentially\n * represent a security-sensitive attribute of an <iframe>.\n * See `IFRAME_SECURITY_SENSITIVE_ATTRS` in the\n * `packages/compiler/src/schema/dom_security_schema.ts` script for the full list\n * of such attributes.\n *\n * @codeGenApi\n */\nexport function ɵɵvalidateIframeAttribute(attrValue: any, tagName: string, attrName: string) {\n  const lView = getLView();\n  const tNode = getSelectedTNode()!;\n  const element = getNativeByTNode(tNode, lView) as RElement | RComment;\n\n  // Restrict any dynamic bindings of security-sensitive attributes/properties\n  // on an <iframe> for security reasons.\n  if (tNode.type === TNodeType.Element && tagName.toLowerCase() === 'iframe') {\n    const iframe = element as HTMLIFrameElement;\n\n    // Unset previously applied `src` and `srcdoc` if we come across a situation when\n    // a security-sensitive attribute is set later via an attribute/property binding.\n    iframe.src = '';\n    iframe.srcdoc = trustedHTMLFromString('') as unknown as string;\n\n    // Also remove the <iframe> from the document.\n    nativeRemoveNode(lView[RENDERER], iframe);\n\n    const errorMessage = ngDevMode &&\n        `Angular has detected that the \\`${attrName}\\` was applied ` +\n            `as a binding to an <iframe>${getTemplateLocationDetails(lView)}. ` +\n            `For security reasons, the \\`${attrName}\\` can be set on an <iframe> ` +\n            `as a static attribute only. \\n` +\n            `To fix this, switch the \\`${attrName}\\` binding to a static attribute ` +\n            `in a template or in host bindings section.`;\n    throw new RuntimeError(RuntimeErrorCode.UNSAFE_IFRAME_ATTRS, errorMessage);\n  }\n  return attrValue;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ModuleWithProviders} from '../../di/interface/provider';\nimport {Type} from '../../interface/type';\nimport {NgModuleDef} from '../../metadata/ng_module_def';\nimport {getNgModuleDef} from '../definition';\n\nexport function isModuleWithProviders(value: any): value is ModuleWithProviders<{}> {\n  return (value as {ngModule?: any}).ngModule !== undefined;\n}\n\nexport function isNgModule<T>(value: Type<T>): value is Type<T>&{ɵmod: NgModuleDef<T>} {\n  return !!getNgModuleDef(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3InjectorMetadataFacade} from '../../compiler/compiler_facade';\nimport {resolveForwardRef} from '../../di/forward_ref';\nimport {NG_INJ_DEF} from '../../di/interface/defs';\nimport {ModuleWithProviders} from '../../di/interface/provider';\nimport {reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {registerNgModuleType} from '../../linker/ng_module_registration';\nimport {Component} from '../../metadata/directives';\nimport {NgModule} from '../../metadata/ng_module';\nimport {NgModuleDef, NgModuleTransitiveScopes, NgModuleType} from '../../metadata/ng_module_def';\nimport {deepForEach, flatten} from '../../util/array_utils';\nimport {assertDefined} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {getComponentDef, getDirectiveDef, getNgModuleDef, getPipeDef, isStandalone} from '../definition';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF, NG_MOD_DEF, NG_PIPE_DEF} from '../fields';\nimport {ComponentDef} from '../interfaces/definition';\nimport {maybeUnwrapFn} from '../util/misc_utils';\nimport {stringifyForError} from '../util/stringify_utils';\n\nimport {angularCoreEnv} from './environment';\nimport {patchModuleCompilation} from './module_patch';\nimport {isModuleWithProviders, isNgModule} from './util';\n\ninterface ModuleQueueItem {\n  moduleType: Type<any>;\n  ngModule: NgModule;\n}\n\nconst moduleQueue: ModuleQueueItem[] = [];\n\n/**\n * Enqueues moduleDef to be checked later to see if scope can be set on its\n * component declarations.\n */\nfunction enqueueModuleForDelayedScoping(moduleType: Type<any>, ngModule: NgModule) {\n  moduleQueue.push({moduleType, ngModule});\n}\n\nlet flushingModuleQueue = false;\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\nexport function flushModuleScopingQueueAsMuchAsPossible() {\n  if (!flushingModuleQueue) {\n    flushingModuleQueue = true;\n    try {\n      for (let i = moduleQueue.length - 1; i >= 0; i--) {\n        const {moduleType, ngModule} = moduleQueue[i];\n\n        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n          // dequeue\n          moduleQueue.splice(i, 1);\n          setScopeOnDeclaredComponents(moduleType, ngModule);\n        }\n      }\n    } finally {\n      flushingModuleQueue = false;\n    }\n  }\n}\n\n/**\n * Returns truthy if a declaration has resolved. If the declaration happens to be\n * an array of declarations, it will recurse to check each declaration in that array\n * (which may also be arrays).\n */\nfunction isResolvedDeclaration(declaration: any[]|Type<any>): boolean {\n  if (Array.isArray(declaration)) {\n    return declaration.every(isResolvedDeclaration);\n  }\n  return !!resolveForwardRef(declaration);\n}\n\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nexport function compileNgModule(moduleType: Type<any>, ngModule: NgModule = {}): void {\n  patchModuleCompilation();\n  compileNgModuleDefs(moduleType as NgModuleType, ngModule);\n  if (ngModule.id !== undefined) {\n    registerNgModuleType(moduleType as NgModuleType, ngModule.id);\n  }\n\n  // Because we don't know if all declarations have resolved yet at the moment the\n  // NgModule decorator is executing, we're enqueueing the setting of module scope\n  // on its declarations to be run at a later time when all declarations for the module,\n  // including forward refs, have resolved.\n  enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\n\n/**\n * Compiles and adds the `ɵmod`, `ɵfac` and `ɵinj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\nexport function compileNgModuleDefs(\n    moduleType: NgModuleType, ngModule: NgModule,\n    allowDuplicateDeclarationsInRoot: boolean = false): void {\n  ngDevMode && assertDefined(moduleType, 'Required value moduleType');\n  ngDevMode && assertDefined(ngModule, 'Required value ngModule');\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n  let ngModuleDef: any = null;\n  Object.defineProperty(moduleType, NG_MOD_DEF, {\n    configurable: true,\n    get: () => {\n      if (ngModuleDef === null) {\n        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n          // We need to assert this immediately, because allowing it to continue will cause it to\n          // go into an infinite loop before we've reached the point where we throw all the errors.\n          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n        }\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {\n          type: moduleType,\n          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n          declarations: declarations.map(resolveForwardRef),\n          imports: flatten(ngModule.imports || EMPTY_ARRAY)\n                       .map(resolveForwardRef)\n                       .map(expandModuleWithProviders),\n          exports: flatten(ngModule.exports || EMPTY_ARRAY)\n                       .map(resolveForwardRef)\n                       .map(expandModuleWithProviders),\n          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,\n          id: ngModule.id || null,\n        });\n        // Set `schemas` on ngModuleDef to an empty array in JIT mode to indicate that runtime\n        // should verify that there are no unknown elements in a template. In AOT mode, that check\n        // happens at compile time and `schemas` information is not present on Component and Module\n        // defs after compilation (so the check doesn't happen the second time at runtime).\n        if (!ngModuleDef.schemas) {\n          ngModuleDef.schemas = [];\n        }\n      }\n      return ngModuleDef;\n    }\n  });\n\n  let ngFactoryDef: any = null;\n  Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {\n          name: moduleType.name,\n          type: moduleType,\n          deps: reflectDependencies(moduleType),\n          target: compiler.FactoryTarget.NgModule,\n          typeArgumentCount: 0,\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n\n  let ngInjectorDef: any = null;\n  Object.defineProperty(moduleType, NG_INJ_DEF, {\n    get: () => {\n      if (ngInjectorDef === null) {\n        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\n        const meta: R3InjectorMetadataFacade = {\n          name: moduleType.name,\n          type: moduleType,\n          providers: ngModule.providers || EMPTY_ARRAY,\n          imports: [\n            (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),\n            (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef),\n          ],\n        };\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'NgModule', type: moduleType});\n        ngInjectorDef =\n            compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);\n      }\n      return ngInjectorDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nexport function generateStandaloneInDeclarationsError(type: Type<any>, location: string) {\n  const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n  const suffix = `\"${stringifyForError(type)}\" is marked as standalone and can't be declared ` +\n      'in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?';\n  return `${prefix} ${location}, ${suffix}`;\n}\n\nfunction verifySemanticsOfNgModuleDef(\n    moduleType: NgModuleType, allowDuplicateDeclarationsInRoot: boolean,\n    importingModule?: NgModuleType): void {\n  if (verifiedNgModule.get(moduleType)) return;\n\n  // skip verifications of standalone components, directives, and pipes\n  if (isStandalone(moduleType)) return;\n\n  verifiedNgModule.set(moduleType, true);\n  moduleType = resolveForwardRef(moduleType);\n  let ngModuleDef: NgModuleDef<any>;\n  if (importingModule) {\n    ngModuleDef = getNgModuleDef(moduleType)!;\n    if (!ngModuleDef) {\n      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  } else {\n    ngModuleDef = getNgModuleDef(moduleType, true);\n  }\n  const errors: string[] = [];\n  const declarations = maybeUnwrapFn(ngModuleDef.declarations);\n  const imports = maybeUnwrapFn(ngModuleDef.imports);\n  flatten(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {\n    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n  });\n  const exports = maybeUnwrapFn(ngModuleDef.exports);\n  declarations.forEach(verifyDeclarationsHaveDefinitions);\n  declarations.forEach(verifyDirectivesHaveSelector);\n  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));\n  const combinedDeclarations: Type<any>[] = [\n    ...declarations.map(resolveForwardRef),\n    ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef),\n  ];\n  exports.forEach(verifyExportsAreDeclaredOrReExported);\n  declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n  declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);\n\n  const ngModule = getAnnotation<NgModule>(moduleType, 'NgModule');\n  if (ngModule) {\n    ngModule.imports &&\n        flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {\n          verifySemanticsOfNgModuleImport(mod, moduleType);\n          verifySemanticsOfNgModuleDef(mod, false, moduleType);\n        });\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n    ngModule.entryComponents &&\n        deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);\n  }\n\n  // Throw Error if any errors were detected.\n  if (errors.length) {\n    throw new Error(errors.join('\\n'));\n  }\n  ////////////////////////////////////////////////////////////////////////////////////////////////\n  function verifyDeclarationsHaveDefinitions(type: Type<any>): void {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    if (!def) {\n      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${\n          stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);\n    }\n  }\n\n  function verifyDirectivesHaveSelector(type: Type<any>): void {\n    type = resolveForwardRef(type);\n    const def = getDirectiveDef(type);\n    if (!getComponentDef(type) && def && def.selectors.length == 0) {\n      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n    }\n  }\n\n  function verifyNotStandalone(type: Type<any>, moduleType: NgModuleType): void {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    if (def?.standalone) {\n      const location = `\"${stringifyForError(moduleType)}\" NgModule`;\n      errors.push(generateStandaloneInDeclarationsError(type, location));\n    }\n  }\n\n  function verifyExportsAreDeclaredOrReExported(type: Type<any>) {\n    type = resolveForwardRef(type);\n    const kind = getComponentDef(type) && 'component' || getDirectiveDef(type) && 'directive' ||\n        getPipeDef(type) && 'pipe';\n    if (kind) {\n      // only checked if we are declared as Component, Directive, or Pipe\n      // Modules don't need to be declared or imported.\n      if (combinedDeclarations.lastIndexOf(type) === -1) {\n        // We are exporting something which we don't explicitly declare or import.\n        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${\n            stringifyForError(moduleType)} as it was neither declared nor imported!`);\n      }\n    }\n  }\n\n  function verifyDeclarationIsUnique(type: Type<any>, suppressErrors: boolean) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (existingModule && existingModule !== moduleType) {\n      if (!suppressErrors) {\n        const modules = [existingModule, moduleType].map(stringifyForError).sort();\n        errors.push(\n            `Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${\n                modules[0]} and ${modules[1]}! ` +\n            `Please consider moving ${stringifyForError(type)} to a higher module that imports ${\n                modules[0]} and ${modules[1]}. ` +\n            `You can also create a new NgModule that exports and includes ${\n                stringifyForError(\n                    type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);\n      }\n    } else {\n      // Mark type as having owner.\n      ownerNgModule.set(type, moduleType);\n    }\n  }\n\n  function verifyComponentIsPartOfNgModule(type: Type<any>) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (!existingModule && !isStandalone(type)) {\n      errors.push(`Component ${\n          stringifyForError(\n              type)} is not part of any NgModule or the module has not been imported into your module.`);\n    }\n  }\n\n  function verifyCorrectBootstrapType(type: Type<any>) {\n    type = resolveForwardRef(type);\n    if (!getComponentDef(type)) {\n      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n    }\n    if (isStandalone(type)) {\n      // Note: this error should be the same as the\n      // `NGMODULE_BOOTSTRAP_IS_STANDALONE` one in AOT compiler.\n      errors.push(\n          `The \\`${stringifyForError(type)}\\` class is a standalone component, which can ` +\n          `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` +\n          `function for bootstrap instead.`);\n    }\n  }\n\n  function verifyComponentEntryComponentsIsPartOfNgModule(type: Type<any>) {\n    type = resolveForwardRef(type);\n    if (getComponentDef(type)) {\n      // We know we are component\n      const component = getAnnotation<Component>(type, 'Component');\n      if (component && component.entryComponents) {\n        deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);\n      }\n    }\n  }\n\n  function verifySemanticsOfNgModuleImport(type: Type<any>, importingModule: Type<any>) {\n    type = resolveForwardRef(type);\n\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null && !directiveDef.standalone) {\n      throw new Error(`Unexpected directive '${type.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n\n    const pipeDef = getPipeDef(type);\n    if (pipeDef !== null && !pipeDef.standalone) {\n      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${\n          importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  }\n}\n\nfunction unwrapModuleWithProvidersImports(typeOrWithProviders: NgModuleType<any>|\n                                          {ngModule: NgModuleType<any>}): NgModuleType<any> {\n  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n  return (typeOrWithProviders as any).ngModule || typeOrWithProviders;\n}\n\nfunction getAnnotation<T>(type: any, name: string): T|null {\n  let annotation: T|null = null;\n  collect(type.__annotations__);\n  collect(type.decorators);\n  return annotation;\n\n  function collect(annotations: any[]|null) {\n    if (annotations) {\n      annotations.forEach(readAnnotation);\n    }\n  }\n\n  function readAnnotation(\n      decorator: {type: {prototype: {ngMetadataName: string}, args: any[]}, args: any}): void {\n    if (!annotation) {\n      const proto = Object.getPrototypeOf(decorator);\n      if (proto.ngMetadataName == name) {\n        annotation = decorator as any;\n      } else if (decorator.type) {\n        const proto = Object.getPrototypeOf(decorator.type);\n        if (proto.ngMetadataName == name) {\n          annotation = decorator.args[0];\n        }\n      }\n    }\n  }\n}\n\n/**\n * Keep track of compiled components. This is needed because in tests we often want to compile the\n * same component with more than one NgModule. This would cause an error unless we reset which\n * NgModule the component belongs to. We keep the list of compiled components here so that the\n * TestBed can reset it later.\n */\nlet ownerNgModule = new WeakMap<Type<any>, NgModuleType<any>>();\nlet verifiedNgModule = new WeakMap<NgModuleType<any>, boolean>();\n\nexport function resetCompiledComponents(): void {\n  ownerNgModule = new WeakMap<Type<any>, NgModuleType<any>>();\n  verifiedNgModule = new WeakMap<NgModuleType<any>, boolean>();\n  moduleQueue.length = 0;\n}\n\n/**\n * Computes the combined declarations of explicit declarations, as well as declarations inherited by\n * traversing the exports of imported modules.\n * @param type\n */\nfunction computeCombinedExports(type: Type<any>): Type<any>[] {\n  type = resolveForwardRef(type);\n  const ngModuleDef = getNgModuleDef(type);\n\n  // a standalone component, directive or pipe\n  if (ngModuleDef === null) {\n    return [type];\n  }\n\n  return [...flatten(maybeUnwrapFn(ngModuleDef.exports).map((type) => {\n    const ngModuleDef = getNgModuleDef(type);\n    if (ngModuleDef) {\n      verifySemanticsOfNgModuleDef(type as any as NgModuleType, false);\n      return computeCombinedExports(type);\n    } else {\n      return type;\n    }\n  }))];\n}\n\n/**\n * Some declared components may be compiled asynchronously, and thus may not have their\n * ɵcmp set yet. If this is the case, then a reference to the module is written into\n * the `ngSelectorScope` property of the declared type.\n */\nfunction setScopeOnDeclaredComponents(moduleType: Type<any>, ngModule: NgModule) {\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n\n  const transitiveScopes = transitiveScopesFor(moduleType);\n\n  declarations.forEach(declaration => {\n    declaration = resolveForwardRef(declaration);\n    if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n      // A `ɵcmp` field exists - go ahead and patch the component directly.\n      const component = declaration as Type<any>& {ɵcmp: ComponentDef<any>};\n      const componentDef = getComponentDef(component)!;\n      patchComponentDefWithScope(componentDef, transitiveScopes);\n    } else if (\n        !declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n      // Set `ngSelectorScope` for future reference when the component compilation finishes.\n      (declaration as Type<any>& {ngSelectorScope?: any}).ngSelectorScope = moduleType;\n    }\n  });\n}\n\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nexport function patchComponentDefWithScope<C>(\n    componentDef: ComponentDef<C>, transitiveScopes: NgModuleTransitiveScopes) {\n  componentDef.directiveDefs = () =>\n      Array.from(transitiveScopes.compilation.directives)\n          .map(\n              dir => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir)! : getDirectiveDef(dir)!\n              )\n          .filter(def => !!def);\n  componentDef.pipeDefs = () =>\n      Array.from(transitiveScopes.compilation.pipes).map(pipe => getPipeDef(pipe)!);\n  componentDef.schemas = transitiveScopes.schemas;\n\n  // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n  // may face a problem where previously compiled defs available to a given Component/Directive\n  // are cached in TView and may become stale (in case any of these defs gets recompiled). In\n  // order to avoid this problem, we force fresh TView to be created.\n  componentDef.tView = null;\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\nexport function transitiveScopesFor<T>(type: Type<T>): NgModuleTransitiveScopes {\n  if (isNgModule(type)) {\n    return transitiveScopesForNgModule(type);\n  } else if (isStandalone(type)) {\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set<any>(),\n          pipes: new Set<any>(),\n        },\n        exported: {\n          directives: new Set<any>([type]),\n          pipes: new Set<any>(),\n        },\n      };\n    }\n\n    const pipeDef = getPipeDef(type);\n    if (pipeDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set<any>(),\n          pipes: new Set<any>(),\n        },\n        exported: {\n          directives: new Set<any>(),\n          pipes: new Set<any>([type]),\n        },\n      };\n    }\n  }\n\n  // TODO: change the error message to be more user-facing and take standalone into account\n  throw new Error(`${type.name} does not have a module def (ɵmod property)`);\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. This function can\n * be called on modules with components that have not fully compiled yet, but the result should not\n * be used until they have.\n *\n * @param moduleType module that transitive scope should be calculated for.\n */\nexport function transitiveScopesForNgModule<T>(moduleType: Type<T>): NgModuleTransitiveScopes {\n  const def = getNgModuleDef(moduleType, true);\n\n  if (def.transitiveCompileScopes !== null) {\n    return def.transitiveCompileScopes;\n  }\n\n  const scopes: NgModuleTransitiveScopes = {\n    schemas: def.schemas || null,\n    compilation: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n    exported: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n  };\n\n  maybeUnwrapFn(def.imports).forEach(<I>(imported: Type<I>) => {\n    // When this module imports another, the imported module's exported directives and pipes are\n    // added to the compilation scope of this module.\n    const importedScope = transitiveScopesFor(imported);\n    importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));\n    importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));\n  });\n\n  maybeUnwrapFn(def.declarations).forEach(declared => {\n    const declaredWithDefs = declared as Type<any>& {\n      ɵpipe?: any;\n    };\n\n    if (getPipeDef(declaredWithDefs)) {\n      scopes.compilation.pipes.add(declared);\n    } else {\n      // Either declared has a ɵcmp or ɵdir, or it's a component which hasn't\n      // had its template compiled yet. In either case, it gets added to the compilation's\n      // directives.\n      scopes.compilation.directives.add(declared);\n    }\n  });\n\n  maybeUnwrapFn(def.exports).forEach(<E>(exported: Type<E>) => {\n    const exportedType = exported as Type<E>& {\n      // Components, Directives, NgModules, and Pipes can all be exported.\n      ɵcmp?: any;\n      ɵdir?: any;\n      ɵmod?: NgModuleDef<E>;\n      ɵpipe?: any;\n    };\n\n    // Either the type is a module, a pipe, or a component/directive (which may not have a\n    // ɵcmp as it might be compiled asynchronously).\n    if (isNgModule(exportedType)) {\n      // When this module exports another, the exported module's exported directives and pipes are\n      // added to both the compilation and exported scopes of this module.\n      const exportedScope = transitiveScopesFor(exportedType);\n      exportedScope.exported.directives.forEach(entry => {\n        scopes.compilation.directives.add(entry);\n        scopes.exported.directives.add(entry);\n      });\n      exportedScope.exported.pipes.forEach(entry => {\n        scopes.compilation.pipes.add(entry);\n        scopes.exported.pipes.add(entry);\n      });\n    } else if (getPipeDef(exportedType)) {\n      scopes.exported.pipes.add(exportedType);\n    } else {\n      scopes.exported.directives.add(exportedType);\n    }\n  });\n\n  def.transitiveCompileScopes = scopes;\n  return scopes;\n}\n\nfunction expandModuleWithProviders(value: Type<any>|ModuleWithProviders<{}>): Type<any> {\n  if (isModuleWithProviders(value)) {\n    return value.ngModule;\n  }\n  return value;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3DirectiveMetadataFacade} from '../../compiler/compiler_facade';\nimport {R3ComponentMetadataFacade, R3QueryMetadataFacade} from '../../compiler/compiler_facade_interface';\nimport {isForwardRef, resolveForwardRef} from '../../di/forward_ref';\nimport {getReflect, reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {Query} from '../../metadata/di';\nimport {Component, Directive, Input} from '../../metadata/directives';\nimport {componentNeedsResolution, maybeQueueResolutionOfComponentResources} from '../../metadata/resource_loading';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {flatten} from '../../util/array_utils';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from '../../util/empty';\nimport {initNgDevMode} from '../../util/ng_dev_mode';\nimport {getComponentDef, getDirectiveDef, getNgModuleDef, getPipeDef} from '../definition';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF} from '../fields';\nimport {ComponentDef, ComponentType, DirectiveDefList, PipeDefList} from '../interfaces/definition';\nimport {stringifyForError} from '../util/stringify_utils';\n\nimport {angularCoreEnv} from './environment';\nimport {getJitOptions} from './jit_options';\nimport {flushModuleScopingQueueAsMuchAsPossible, patchComponentDefWithScope, transitiveScopesFor} from './module';\nimport {isModuleWithProviders} from './util';\n\n/**\n * Keep track of the compilation depth to avoid reentrancy issues during JIT compilation. This\n * matters in the following scenario:\n *\n * Consider a component 'A' that extends component 'B', both declared in module 'M'. During\n * the compilation of 'A' the definition of 'B' is requested to capture the inheritance chain,\n * potentially triggering compilation of 'B'. If this nested compilation were to trigger\n * `flushModuleScopingQueueAsMuchAsPossible` it may happen that module 'M' is still pending in the\n * queue, resulting in 'A' and 'B' to be patched with the NgModule scope. As the compilation of\n * 'A' is still in progress, this would introduce a circular dependency on its compilation. To avoid\n * this issue, the module scope queue is only flushed for compilations at the depth 0, to ensure\n * all compilations have finished.\n */\nlet compilationDepth = 0;\n\n/**\n * Compile an Angular component according to its decorator metadata, and patch the resulting\n * component def (ɵcmp) onto the component type.\n *\n * Compilation may be asynchronous (due to the need to resolve URLs for the component template or\n * other resources, for example). In the event that compilation is not immediate, `compileComponent`\n * will enqueue resource resolution into a global queue and will fail to return the `ɵcmp`\n * until the global queue has been resolved with a call to `resolveComponentResources`.\n */\nexport function compileComponent(type: Type<any>, metadata: Component): void {\n  // Initialize ngDevMode. This must be the first statement in compileComponent.\n  // See the `initNgDevMode` docstring for more information.\n  (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n\n  let ngComponentDef: ComponentDef<unknown>|null = null;\n\n  // Metadata may have resources which need to be resolved.\n  maybeQueueResolutionOfComponentResources(type, metadata);\n\n  // Note that we're using the same function as `Directive`, because that's only subset of metadata\n  // that we need to create the ngFactoryDef. We're avoiding using the component metadata\n  // because we'd have to resolve the asynchronous templates.\n  addDirectiveFactoryDef(type, metadata);\n\n  Object.defineProperty(type, NG_COMP_DEF, {\n    get: () => {\n      if (ngComponentDef === null) {\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'component', type: type});\n\n        if (componentNeedsResolution(metadata)) {\n          const error = [`Component '${type.name}' is not resolved:`];\n          if (metadata.templateUrl) {\n            error.push(` - templateUrl: ${metadata.templateUrl}`);\n          }\n          if (metadata.styleUrls && metadata.styleUrls.length) {\n            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);\n          }\n          error.push(`Did you run and wait for 'resolveComponentResources()'?`);\n          throw new Error(error.join('\\n'));\n        }\n\n        // This const was called `jitOptions` previously but had to be renamed to `options` because\n        // of a bug with Terser that caused optimized JIT builds to throw a `ReferenceError`.\n        // This bug was investigated in https://github.com/angular/angular-cli/issues/17264.\n        // We should not rename it back until https://github.com/terser/terser/issues/615 is fixed.\n        const options = getJitOptions();\n        let preserveWhitespaces = metadata.preserveWhitespaces;\n        if (preserveWhitespaces === undefined) {\n          if (options !== null && options.preserveWhitespaces !== undefined) {\n            preserveWhitespaces = options.preserveWhitespaces;\n          } else {\n            preserveWhitespaces = false;\n          }\n        }\n        let encapsulation = metadata.encapsulation;\n        if (encapsulation === undefined) {\n          if (options !== null && options.defaultEncapsulation !== undefined) {\n            encapsulation = options.defaultEncapsulation;\n          } else {\n            encapsulation = ViewEncapsulation.Emulated;\n          }\n        }\n\n        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;\n        const meta: R3ComponentMetadataFacade = {\n          ...directiveMetadata(type, metadata),\n          typeSourceSpan: compiler.createParseSourceSpan('Component', type.name, templateUrl),\n          template: metadata.template || '',\n          preserveWhitespaces,\n          styles: metadata.styles || EMPTY_ARRAY,\n          animations: metadata.animations,\n          // JIT components are always compiled against an empty set of `declarations`. Instead, the\n          // `directiveDefs` and `pipeDefs` are updated at a later point:\n          //  * for NgModule-based components, they're set when the NgModule which declares the\n          //    component resolves in the module scoping queue\n          //  * for standalone components, they're set just below, after `compileComponent`.\n          declarations: [],\n          changeDetection: metadata.changeDetection,\n          encapsulation,\n          interpolation: metadata.interpolation,\n          viewProviders: metadata.viewProviders || null,\n          isStandalone: !!metadata.standalone,\n        };\n\n        compilationDepth++;\n        try {\n          if (meta.usesInheritance) {\n            addDirectiveDefToUndecoratedParents(type);\n          }\n          ngComponentDef =\n              compiler.compileComponent(angularCoreEnv, templateUrl, meta) as ComponentDef<unknown>;\n\n          if (metadata.standalone) {\n            // Patch the component definition for standalone components with `directiveDefs` and\n            // `pipeDefs` functions which lazily compute the directives/pipes available in the\n            // standalone component. Also set `dependencies` to the lazily resolved list of imports.\n            const imports: Type<any>[] = flatten(metadata.imports || EMPTY_ARRAY);\n            const {directiveDefs, pipeDefs} = getStandaloneDefFunctions(type, imports);\n            ngComponentDef.directiveDefs = directiveDefs;\n            ngComponentDef.pipeDefs = pipeDefs;\n            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);\n          }\n        } finally {\n          // Ensure that the compilation depth is decremented even when the compilation failed.\n          compilationDepth--;\n        }\n\n        if (compilationDepth === 0) {\n          // When NgModule decorator executed, we enqueued the module definition such that\n          // it would only dequeue and add itself as module scope to all of its declarations,\n          // but only if  if all of its declarations had resolved. This call runs the check\n          // to see if any modules that are in the queue can be dequeued and add scope to\n          // their declarations.\n          flushModuleScopingQueueAsMuchAsPossible();\n        }\n\n        // If component compilation is async, then the @NgModule annotation which declares the\n        // component may execute and set an ngSelectorScope property on the component type. This\n        // allows the component to patch itself with directiveDefs from the module after it\n        // finishes compiling.\n        if (hasSelectorScope(type)) {\n          const scopes = transitiveScopesFor(type.ngSelectorScope);\n          patchComponentDefWithScope(ngComponentDef, scopes);\n        }\n\n        if (metadata.schemas) {\n          if (metadata.standalone) {\n            ngComponentDef.schemas = metadata.schemas;\n          } else {\n            throw new Error(`The 'schemas' was specified for the ${\n                stringifyForError(type)} but is only valid on a component that is standalone.`);\n          }\n        } else if (metadata.standalone) {\n          ngComponentDef.schemas = [];\n        }\n      }\n      return ngComponentDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getDependencyTypeForError(type: Type<any>) {\n  if (getComponentDef(type)) return 'component';\n  if (getDirectiveDef(type)) return 'directive';\n  if (getPipeDef(type)) return 'pipe';\n  return 'type';\n}\n\nfunction verifyStandaloneImport(depType: Type<unknown>, importingType: Type<unknown>) {\n  if (isForwardRef(depType)) {\n    depType = resolveForwardRef(depType);\n    if (!depType) {\n      throw new Error(`Expected forwardRef function, imported from \"${\n          stringifyForError(importingType)}\", to return a standalone entity or NgModule but got \"${\n          stringifyForError(depType) || depType}\".`);\n    }\n  }\n\n  if (getNgModuleDef(depType) == null) {\n    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef(depType);\n    if (def != null) {\n      // if a component, directive or pipe is imported make sure that it is standalone\n      if (!def.standalone) {\n        throw new Error(`The \"${stringifyForError(depType)}\" ${\n            getDependencyTypeForError(depType)}, imported from \"${\n            stringifyForError(\n                importingType)}\", is not standalone. Did you forget to add the standalone: true flag?`);\n      }\n    } else {\n      // it can be either a module with provider or an unknown (not annotated) type\n      if (isModuleWithProviders(depType)) {\n        throw new Error(`A module with providers was imported from \"${\n            stringifyForError(\n                importingType)}\". Modules with providers are not supported in standalone components imports.`);\n      } else {\n        throw new Error(`The \"${stringifyForError(depType)}\" type, imported from \"${\n            stringifyForError(\n                importingType)}\", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);\n      }\n    }\n  }\n}\n\n/**\n * Build memoized `directiveDefs` and `pipeDefs` functions for the component definition of a\n * standalone component, which process `imports` and filter out directives and pipes. The use of\n * memoized functions here allows for the delayed resolution of any `forwardRef`s present in the\n * component's `imports`.\n */\nfunction getStandaloneDefFunctions(type: Type<any>, imports: Type<any>[]): {\n  directiveDefs: () => DirectiveDefList,\n  pipeDefs: () => PipeDefList,\n} {\n  let cachedDirectiveDefs: DirectiveDefList|null = null;\n  let cachedPipeDefs: PipeDefList|null = null;\n  const directiveDefs = () => {\n    if (cachedDirectiveDefs === null) {\n      // Standalone components are always able to self-reference, so include the component's own\n      // definition in its `directiveDefs`.\n      cachedDirectiveDefs = [getComponentDef(type)!];\n      const seen = new Set<Type<unknown>>();\n\n      for (const rawDep of imports) {\n        ngDevMode && verifyStandaloneImport(rawDep, type);\n\n        const dep = resolveForwardRef(rawDep);\n        if (seen.has(dep)) {\n          continue;\n        }\n        seen.add(dep);\n\n        if (!!getNgModuleDef(dep)) {\n          const scope = transitiveScopesFor(dep);\n          for (const dir of scope.exported.directives) {\n            const def = getComponentDef(dir) || getDirectiveDef(dir);\n            if (def && !seen.has(dir)) {\n              seen.add(dir);\n              cachedDirectiveDefs.push(def);\n            }\n          }\n        } else {\n          const def = getComponentDef(dep) || getDirectiveDef(dep);\n          if (def) {\n            cachedDirectiveDefs.push(def);\n          }\n        }\n      }\n    }\n    return cachedDirectiveDefs;\n  };\n\n  const pipeDefs = () => {\n    if (cachedPipeDefs === null) {\n      cachedPipeDefs = [];\n      const seen = new Set<Type<unknown>>();\n\n      for (const rawDep of imports) {\n        const dep = resolveForwardRef(rawDep);\n        if (seen.has(dep)) {\n          continue;\n        }\n        seen.add(dep);\n\n        if (!!getNgModuleDef(dep)) {\n          const scope = transitiveScopesFor(dep);\n          for (const pipe of scope.exported.pipes) {\n            const def = getPipeDef(pipe);\n            if (def && !seen.has(pipe)) {\n              seen.add(pipe);\n              cachedPipeDefs.push(def);\n            }\n          }\n        } else {\n          const def = getPipeDef(dep);\n          if (def) {\n            cachedPipeDefs.push(def);\n          }\n        }\n      }\n    }\n    return cachedPipeDefs;\n  };\n\n  return {\n    directiveDefs,\n    pipeDefs,\n  };\n}\n\nfunction hasSelectorScope<T>(component: Type<T>): component is Type<T>&\n    {ngSelectorScope: Type<any>} {\n  return (component as {ngSelectorScope?: any}).ngSelectorScope !== undefined;\n}\n\n/**\n * Compile an Angular directive according to its decorator metadata, and patch the resulting\n * directive def onto the component type.\n *\n * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which\n * will resolve when compilation completes and the directive becomes usable.\n */\nexport function compileDirective(type: Type<any>, directive: Directive|null): void {\n  let ngDirectiveDef: any = null;\n\n  addDirectiveFactoryDef(type, directive || {});\n\n  Object.defineProperty(type, NG_DIR_DEF, {\n    get: () => {\n      if (ngDirectiveDef === null) {\n        // `directive` can be null in the case of abstract directives as a base class\n        // that use `@Directive()` with no selector. In that case, pass empty object to the\n        // `directiveMetadata` function instead of null.\n        const meta = getDirectiveMetadata(type, directive || {});\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n        ngDirectiveDef =\n            compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);\n      }\n      return ngDirectiveDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getDirectiveMetadata(type: Type<any>, metadata: Directive) {\n  const name = type && type.name;\n  const sourceMapUrl = `ng:///${name}/ɵdir.js`;\n  const compiler = getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n  const facade = directiveMetadata(type as ComponentType<any>, metadata);\n  facade.typeSourceSpan = compiler.createParseSourceSpan('Directive', name, sourceMapUrl);\n  if (facade.usesInheritance) {\n    addDirectiveDefToUndecoratedParents(type);\n  }\n  return {metadata: facade, sourceMapUrl};\n}\n\nfunction addDirectiveFactoryDef(type: Type<any>, metadata: Directive|Component) {\n  let ngFactoryDef: any = null;\n\n  Object.defineProperty(type, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const meta = getDirectiveMetadata(type, metadata);\n        const compiler =\n            getCompilerFacade({usage: JitCompilerUsage.Decorator, kind: 'directive', type});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/ɵfac.js`, {\n          name: meta.metadata.name,\n          type: meta.metadata.type,\n          typeArgumentCount: 0,\n          deps: reflectDependencies(type),\n          target: compiler.FactoryTarget.Directive\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nexport function extendsDirectlyFromObject(type: Type<any>): boolean {\n  return Object.getPrototypeOf(type.prototype) === Object.prototype;\n}\n\n/**\n * Extract the `R3DirectiveMetadata` for a particular directive (either a `Directive` or a\n * `Component`).\n */\nexport function directiveMetadata(type: Type<any>, metadata: Directive): R3DirectiveMetadataFacade {\n  // Reflect inputs and outputs.\n  const reflect = getReflect();\n  const propMetadata = reflect.ownPropMetadata(type);\n\n  return {\n    name: type.name,\n    type: type,\n    selector: metadata.selector !== undefined ? metadata.selector : null,\n    host: metadata.host || EMPTY_OBJ,\n    propMetadata: propMetadata,\n    inputs: metadata.inputs || EMPTY_ARRAY,\n    outputs: metadata.outputs || EMPTY_ARRAY,\n    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),\n    lifecycle: {usesOnChanges: reflect.hasLifecycleHook(type, 'ngOnChanges')},\n    typeSourceSpan: null!,\n    usesInheritance: !extendsDirectlyFromObject(type),\n    exportAs: extractExportAs(metadata.exportAs),\n    providers: metadata.providers || null,\n    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),\n    isStandalone: !!metadata.standalone,\n    hostDirectives: metadata.hostDirectives?.map(\n                        directive => typeof directive === 'function' ? {directive} : directive) ||\n        null\n  };\n}\n\n/**\n * Adds a directive definition to all parent classes of a type that don't have an Angular decorator.\n */\nfunction addDirectiveDefToUndecoratedParents(type: Type<any>) {\n  const objPrototype = Object.prototype;\n  let parent = Object.getPrototypeOf(type.prototype).constructor;\n\n  // Go up the prototype until we hit `Object`.\n  while (parent && parent !== objPrototype) {\n    // Since inheritance works if the class was annotated already, we only need to add\n    // the def if there are no annotations and the def hasn't been created already.\n    if (!getDirectiveDef(parent) && !getComponentDef(parent) &&\n        shouldAddAbstractDirective(parent)) {\n      compileDirective(parent, null);\n    }\n    parent = Object.getPrototypeOf(parent);\n  }\n}\n\nfunction convertToR3QueryPredicate(selector: any): any|string[] {\n  return typeof selector === 'string' ? splitByComma(selector) : resolveForwardRef(selector);\n}\n\nexport function convertToR3QueryMetadata(propertyName: string, ann: Query): R3QueryMetadataFacade {\n  return {\n    propertyName: propertyName,\n    predicate: convertToR3QueryPredicate(ann.selector),\n    descendants: ann.descendants,\n    first: ann.first,\n    read: ann.read ? ann.read : null,\n    static: !!ann.static,\n    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,\n  };\n}\nfunction extractQueriesMetadata(\n    type: Type<any>, propMetadata: {[key: string]: any[]},\n    isQueryAnn: (ann: any) => ann is Query): R3QueryMetadataFacade[] {\n  const queriesMeta: R3QueryMetadataFacade[] = [];\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      const annotations = propMetadata[field];\n      annotations.forEach(ann => {\n        if (isQueryAnn(ann)) {\n          if (!ann.selector) {\n            throw new Error(\n                `Can't construct a query for the property \"${field}\" of ` +\n                `\"${stringifyForError(type)}\" since the query selector wasn't defined.`);\n          }\n          if (annotations.some(isInputAnnotation)) {\n            throw new Error(`Cannot combine @Input decorators with query decorators`);\n          }\n          queriesMeta.push(convertToR3QueryMetadata(field, ann));\n        }\n      });\n    }\n  }\n  return queriesMeta;\n}\n\nfunction extractExportAs(exportAs: string|undefined): string[]|null {\n  return exportAs === undefined ? null : splitByComma(exportAs);\n}\n\nfunction isContentQuery(value: any): value is Query {\n  const name = value.ngMetadataName;\n  return name === 'ContentChild' || name === 'ContentChildren';\n}\n\nfunction isViewQuery(value: any): value is Query {\n  const name = value.ngMetadataName;\n  return name === 'ViewChild' || name === 'ViewChildren';\n}\n\nfunction isInputAnnotation(value: any): value is Input {\n  return value.ngMetadataName === 'Input';\n}\n\nfunction splitByComma(value: string): string[] {\n  return value.split(',').map(piece => piece.trim());\n}\n\nconst LIFECYCLE_HOOKS = [\n  'ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked',\n  'ngAfterContentInit', 'ngAfterContentChecked'\n];\n\nfunction shouldAddAbstractDirective(type: Type<any>): boolean {\n  const reflect = getReflect();\n\n  if (LIFECYCLE_HOOKS.some(hookName => reflect.hasLifecycleHook(type, hookName))) {\n    return true;\n  }\n\n  const propMetadata = reflect.propMetadata(type);\n\n  for (const field in propMetadata) {\n    const annotations = propMetadata[field];\n\n    for (let i = 0; i < annotations.length; i++) {\n      const current = annotations[i];\n      const metadataName = current.ngMetadataName;\n\n      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) ||\n          metadataName === 'Output' || metadataName === 'HostBinding' ||\n          metadataName === 'HostListener') {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getCompilerFacade, JitCompilerUsage, R3PipeMetadataFacade} from '../../compiler/compiler_facade';\nimport {reflectDependencies} from '../../di/jit/util';\nimport {Type} from '../../interface/type';\nimport {Pipe} from '../../metadata/directives';\nimport {NG_FACTORY_DEF, NG_PIPE_DEF} from '../fields';\n\nimport {angularCoreEnv} from './environment';\n\nexport function compilePipe(type: Type<any>, meta: Pipe): void {\n  let ngPipeDef: any = null;\n  let ngFactoryDef: any = null;\n\n  Object.defineProperty(type, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const metadata = getPipeMetadata(type, meta);\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'pipe', type: metadata.type});\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/ɵfac.js`, {\n          name: metadata.name,\n          type: metadata.type,\n          typeArgumentCount: 0,\n          deps: reflectDependencies(type),\n          target: compiler.FactoryTarget.Pipe\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n\n  Object.defineProperty(type, NG_PIPE_DEF, {\n    get: () => {\n      if (ngPipeDef === null) {\n        const metadata = getPipeMetadata(type, meta);\n        const compiler = getCompilerFacade(\n            {usage: JitCompilerUsage.Decorator, kind: 'pipe', type: metadata.type});\n        ngPipeDef =\n            compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/ɵpipe.js`, metadata);\n      }\n      return ngPipeDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode,\n  });\n}\n\nfunction getPipeMetadata(type: Type<any>, meta: Pipe): R3PipeMetadataFacade {\n  return {\n    type: type,\n    name: type.name,\n    pipeName: meta.name,\n    pure: meta.pure !== undefined ? meta.pure : true,\n    isStandalone: !!meta.standalone,\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {Provider} from '../di/interface/provider';\nimport {Type} from '../interface/type';\nimport {compileComponent, compileDirective} from '../render3/jit/directive';\nimport {compilePipe} from '../render3/jit/pipe';\nimport {makeDecorator, makePropDecorator, TypeDecorator} from '../util/decorators';\n\nimport {SchemaMetadata} from './schema';\nimport {ViewEncapsulation} from './view';\n\n\n\n/**\n * Type of the Directive decorator / constructor function.\n * @publicApi\n */\nexport interface DirectiveDecorator {\n  /**\n   * Decorator that marks a class as an Angular directive.\n   * You can define your own directives to attach custom behavior to elements in the DOM.\n   *\n   * The options provide configuration metadata that determines\n   * how the directive should be processed, instantiated and used at\n   * runtime.\n   *\n   * Directive classes, like component classes, can implement\n   * [life-cycle hooks](guide/lifecycle-hooks) to influence their configuration and behavior.\n   *\n   *\n   * @usageNotes\n   * To define a directive, mark the class with the decorator and provide metadata.\n   *\n   * ```ts\n   * import {Directive} from '@angular/core';\n   *\n   * @Directive({\n   *   selector: 'my-directive',\n   * })\n   * export class MyDirective {\n   * ...\n   * }\n   * ```\n   *\n   * ### Declaring directives\n   *\n   * In order to make a directive available to other components in your application, you should do\n   * one of the following:\n   *  - either mark the directive as [standalone](guide/standalone-components),\n   *  - or declare it in an NgModule by adding it to the `declarations` and `exports` fields.\n   *\n   * ** Marking a directive as standalone **\n   *\n   * You can add the `standalone: true` flag to the Directive decorator metadata to declare it as\n   * [standalone](guide/standalone-components):\n   *\n   * ```ts\n   * @Directive({\n   *   standalone: true,\n   *   selector: 'my-directive',\n   * })\n   * class MyDirective {}\n   * ```\n   *\n   * When marking a directive as standalone, please make sure that the directive is not already\n   * declared in an NgModule.\n   *\n   *\n   * ** Declaring a directive in an NgModule **\n   *\n   * Another approach is to declare a directive in an NgModule:\n   *\n   * ```ts\n   * @Directive({\n   *   selector: 'my-directive',\n   * })\n   * class MyDirective {}\n   *\n   * @NgModule({\n   *   declarations: [MyDirective, SomeComponent],\n   *   exports: [MyDirective], // making it available outside of this module\n   * })\n   * class SomeNgModule {}\n   * ```\n   *\n   * When declaring a directive in an NgModule, please make sure that:\n   *  - the directive is declared in exactly one NgModule.\n   *  - the directive is not standalone.\n   *  - you do not re-declare a directive imported from another module.\n   *  - the directive is included into the `exports` field as well if you want this directive to be\n   *    accessible for components outside of the NgModule.\n   *\n   *\n   * @Annotation\n   */\n  (obj?: Directive): TypeDecorator;\n\n  /**\n   * See the `Directive` decorator.\n   */\n  new(obj?: Directive): Directive;\n}\n\n/**\n * Directive decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport interface Directive {\n  /**\n   * The CSS selector that identifies this directive in a template\n   * and triggers instantiation of the directive.\n   *\n   * Declare as one of the following:\n   *\n   * - `element-name`: Select by element name.\n   * - `.class`: Select by class name.\n   * - `[attribute]`: Select by attribute name.\n   * - `[attribute=value]`: Select by attribute name and value.\n   * - `:not(sub_selector)`: Select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: Select if either `selector1` or `selector2` matches.\n   *\n   * Angular only allows directives to apply on CSS selectors that do not cross\n   * element boundaries.\n   *\n   * For the following template HTML, a directive with an `input[type=text]` selector,\n   * would be instantiated only on the `<input type=\"text\">` element.\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   */\n  selector?: string;\n\n  /**\n   * Enumerates the set of data-bound input properties for a directive\n   *\n   * Angular automatically updates input properties during change detection.\n   * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property where the value is written.\n   * - `bindingProperty` specifies the DOM property where the value is read from.\n   *\n   * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.\n   *\n   * @usageNotes\n   *\n   * The following example creates a component with two data-bound properties.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   inputs: ['bankName', 'id: account-id'],\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   bankName: string;\n   *   id: string;\n   * }\n   * ```\n   *\n   */\n  inputs?: string[];\n\n  /**\n   * Enumerates the set of event-bound output properties.\n   *\n   * When an output property emits an event, an event handler attached to that event\n   * in the template is invoked.\n   *\n   * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property that emits events.\n   * - `bindingProperty` specifies the DOM property the event handler is attached to.\n   *\n   * @usageNotes\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'child-dir',\n   *   outputs: [ 'bankNameChange' ]\n   *   template: `<input (input)=\"bankNameChange.emit($event.target.value)\" />`\n   * })\n   * class ChildDir {\n   *  bankNameChange: EventEmitter<string> = new EventEmitter<string>();\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `\n   *     {{ bankName }} <child-dir (bankNameChange)=\"onBankNameChange($event)\"></child-dir>\n   *   `\n   * })\n   * class MainComponent {\n   *  bankName: string;\n   *\n   *   onBankNameChange(bankName: string) {\n   *     this.bankName = bankName;\n   *   }\n   * }\n   * ```\n   *\n   */\n  outputs?: string[];\n\n  /**\n   * Configures the [injector](guide/glossary#injector) of this\n   * directive or component with a [token](guide/glossary#di-token)\n   * that maps to a [provider](guide/glossary#provider) of a dependency.\n   */\n  providers?: Provider[];\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * @usageNotes\n   *\n   * ```ts\n   * @Directive({\n   *   selector: 'child-dir',\n   *   exportAs: 'child'\n   * })\n   * class ChildDir {\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `<child-dir #c=\"child\"></child-dir>`\n   * })\n   * class MainComponent {\n   * }\n   * ```\n   *\n   */\n  exportAs?: string;\n\n  /**\n   * Configures the queries that will be injected into the directive.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * @usageNotes\n   *\n   * The following example shows how queries are defined\n   * and when their results are available in lifecycle hooks:\n   *\n   * ```ts\n   * @Component({\n   *   selector: 'someDir',\n   *   queries: {\n   *     contentChildren: new ContentChildren(ChildDirective),\n   *     viewChildren: new ViewChildren(ChildDirective)\n   *   },\n   *   template: '<child-directive></child-directive>'\n   * })\n   * class SomeDir {\n   *   contentChildren: QueryList<ChildDirective>,\n   *   viewChildren: QueryList<ChildDirective>\n   *\n   *   ngAfterContentInit() {\n   *     // contentChildren is set\n   *   }\n   *\n   *   ngAfterViewInit() {\n   *     // viewChildren is set\n   *   }\n   * }\n   * ```\n   *\n   * @Annotation\n   */\n  queries?: {[key: string]: any};\n\n  /**\n   * Maps class properties to host element bindings for properties,\n   * attributes, and events, using a set of key-value pairs.\n   *\n   * Angular automatically checks host property bindings during change detection.\n   * If a binding changes, Angular updates the directive's host element.\n   *\n   * When the key is a property of the host element, the property value is\n   * the propagated to the specified DOM property.\n   *\n   * When the key is a static attribute in the DOM, the attribute value\n   * is propagated to the specified property in the host element.\n   *\n   * For event handling:\n   * - The key is the DOM event that the directive listens to.\n   * To listen to global events, add the target to the event name.\n   * The target can be `window`, `document` or `body`.\n   * - The value is the statement to execute when the event occurs. If the\n   * statement evaluates to `false`, then `preventDefault` is applied on the DOM\n   * event. A handler method can refer to the `$event` local variable.\n   *\n   */\n  host?: {[key: string]: string};\n\n  /**\n   * When present, this directive/component is ignored by the AOT compiler.\n   * It remains in distributed code, and the JIT compiler attempts to compile it\n   * at run time, in the browser.\n   * To ensure the correct behavior, the app must import `@angular/compiler`.\n   */\n  jit?: true;\n\n  /**\n   * Angular directives marked as `standalone` do not need to be declared in an NgModule. Such\n   * directives don't depend on any \"intermediate context\" of an NgModule (ex. configured\n   * providers).\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  standalone?: boolean;\n\n  /**\n   * Standalone directives that should be applied to the host whenever the directive is matched.\n   * By default, none of the inputs or outputs of the host directives will be available on the host,\n   * unless they are specified in the `inputs` or `outputs` properties.\n   *\n   * You can additionally alias inputs and outputs by putting a colon and the alias after the\n   * original input or output name. For example, if a directive applied via `hostDirectives`\n   * defines an input named `menuDisabled`, you can alias this to `disabled` by adding\n   * `'menuDisabled: disabled'` as an entry to `inputs`.\n   */\n  hostDirectives?: (Type<unknown>|{\n    directive: Type<unknown>,\n    inputs?: string[],\n    outputs?: string[],\n  })[];\n}\n\n/**\n * Type of the Directive metadata.\n *\n * @publicApi\n */\nexport const Directive: DirectiveDecorator = makeDecorator(\n    'Directive', (dir: Directive = {}) => dir, undefined, undefined,\n    (type: Type<any>, meta: Directive) => compileDirective(type, meta));\n\n/**\n * Component decorator interface\n *\n * @publicApi\n */\nexport interface ComponentDecorator {\n  /**\n   * Decorator that marks a class as an Angular component and provides configuration\n   * metadata that determines how the component should be processed,\n   * instantiated, and used at runtime.\n   *\n   * Components are the most basic UI building block of an Angular app.\n   * An Angular app contains a tree of Angular components.\n   *\n   * Angular components are a subset of directives, always associated with a template.\n   * Unlike other directives, only one component can be instantiated for a given element in a\n   * template.\n   *\n   * A component must belong to an NgModule in order for it to be available\n   * to another component or application. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `NgModule` metadata.\n   *\n   * Note that, in addition to these options for configuring a directive,\n   * you can control a component's runtime behavior by implementing\n   * life-cycle hooks. For more information, see the\n   * [Lifecycle Hooks](guide/lifecycle-hooks) guide.\n   *\n   * @usageNotes\n   *\n   * ### Setting component inputs\n   *\n   * The following example creates a component with two data-bound properties,\n   * specified by the `inputs` value.\n   *\n   * <code-example path=\"core/ts/metadata/directives.ts\" region=\"component-input\"></code-example>\n   *\n   *\n   * ### Setting component outputs\n   *\n   * The following example shows two event emitters that emit on an interval. One\n   * emits an output every second, while the other emits every five seconds.\n   *\n   * {@example core/ts/metadata/directives.ts region='component-output-interval'}\n   *\n   * ### Injecting a class with a view provider\n   *\n   * The following simple example injects a class into a component\n   * using the view provider specified in component metadata:\n   *\n   * ```ts\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Directive({\n   *   selector: 'needs-greeter'\n   * })\n   * class NeedsGreeter {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'greet',\n   *   viewProviders: [\n   *     Greeter\n   *   ],\n   *   template: `<needs-greeter></needs-greeter>`\n   * })\n   * class HelloWorld {\n   * }\n   *\n   * ```\n   *\n   * ### Preserving whitespace\n   *\n   * Removing whitespace can greatly reduce AOT-generated code size and speed up view creation.\n   * As of Angular 6, the default for `preserveWhitespaces` is false (whitespace is removed).\n   * To change the default setting for all components in your application, set\n   * the `preserveWhitespaces` option of the AOT compiler.\n   *\n   * By default, the AOT compiler removes whitespace characters as follows:\n   * * Trims all whitespaces at the beginning and the end of a template.\n   * * Removes whitespace-only text nodes. For example,\n   *\n   * ```html\n   * <button>Action 1</button>  <button>Action 2</button>\n   * ```\n   *\n   * becomes:\n   *\n   * ```html\n   * <button>Action 1</button><button>Action 2</button>\n   * ```\n   *\n   * * Replaces a series of whitespace characters in text nodes with a single space.\n   * For example, `<span>\\n some text\\n</span>` becomes `<span> some text </span>`.\n   * * Does NOT alter text nodes inside HTML tags such as `<pre>` or `<textarea>`,\n   * where whitespace characters are significant.\n   *\n   * Note that these transformations can influence DOM nodes layout, although impact\n   * should be minimal.\n   *\n   * You can override the default behavior to preserve whitespace characters\n   * in certain fragments of a template. For example, you can exclude an entire\n   * DOM sub-tree by using the `ngPreserveWhitespaces` attribute:\n   *\n   * ```html\n   * <div ngPreserveWhitespaces>\n   *     whitespaces are preserved here\n   *     <span>    and here </span>\n   * </div>\n   * ```\n   *\n   * You can force a single space to be preserved in a text node by using `&ngsp;`,\n   * which is replaced with a space character by Angular's template\n   * compiler:\n   *\n   * ```html\n   * <a>Spaces</a>&ngsp;<a>between</a>&ngsp;<a>links.</a>\n   * <!-- compiled to be equivalent to:\n   *  <a>Spaces</a> <a>between</a> <a>links.</a>  -->\n   * ```\n   *\n   * Note that sequences of `&ngsp;` are still collapsed to just one space character when\n   * the `preserveWhitespaces` option is set to `false`.\n   *\n   * ```html\n   * <a>before</a>&ngsp;&ngsp;&ngsp;<a>after</a>\n   * <!-- compiled to be equivalent to:\n   *  <a>before</a> <a>after</a> -->\n   * ```\n   *\n   * To preserve sequences of whitespace characters, use the\n   * `ngPreserveWhitespaces` attribute.\n   *\n   * @Annotation\n   */\n  (obj: Component): TypeDecorator;\n  /**\n   * See the `Component` decorator.\n   */\n  new(obj: Component): Component;\n}\n\n/**\n * Supplies configuration metadata for an Angular component.\n *\n * @publicApi\n */\nexport interface Component extends Directive {\n  /**\n   * The change-detection strategy to use for this component.\n   *\n   * When a component is instantiated, Angular creates a change detector,\n   * which is responsible for propagating the component's bindings.\n   * The strategy is one of:\n   * - `ChangeDetectionStrategy#OnPush` sets the strategy to `CheckOnce` (on demand).\n   * - `ChangeDetectionStrategy#Default` sets the strategy to `CheckAlways`.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Defines the set of injectable objects that are visible to its view DOM children.\n   * See [example](#injecting-a-class-with-a-view-provider).\n   *\n   */\n  viewProviders?: Provider[];\n\n  /**\n   * The module ID of the module that contains the component.\n   * The component must be able to resolve relative URLs for templates and styles.\n   * SystemJS exposes the `__moduleName` variable within each module.\n   * In CommonJS, this can  be set to `module.id`.\n   *\n   */\n  moduleId?: string;\n\n  /**\n   * The relative path or absolute URL of a template file for an Angular component.\n   * If provided, do not supply an inline template using `template`.\n   *\n   */\n  templateUrl?: string;\n\n  /**\n   * An inline template for an Angular component. If provided,\n   * do not supply a template file using `templateUrl`.\n   *\n   */\n  template?: string;\n\n  /**\n   * One or more relative paths or absolute URLs for files containing CSS stylesheets to use\n   * in this component.\n   */\n  styleUrls?: string[];\n\n  /**\n   * One or more inline CSS stylesheets to use\n   * in this component.\n   */\n  styles?: string[];\n\n  /**\n   * One or more animation `trigger()` calls, containing\n   * [`state()`](api/animations/state) and `transition()` definitions.\n   * See the [Animations guide](/guide/animations) and animations API documentation.\n   *\n   */\n  animations?: any[];\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Possible values:\n   * - `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate\n   *                                 a native Shadow DOM CSS encapsulation behavior.\n   * - `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n   * - `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n   *\n   * If not supplied, the value is taken from the `CompilerOptions`\n   * which defaults to `ViewEncapsulation.Emulated`.\n   *\n   * If the policy is `ViewEncapsulation.Emulated` and the component has no\n   * {@link Component#styles styles} nor {@link Component#styleUrls styleUrls},\n   * the policy is automatically switched to `ViewEncapsulation.None`.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Overrides the default interpolation start and end delimiters (`{{` and `}}`).\n   */\n  interpolation?: [string, string];\n\n  /**\n   * A set of components that should be compiled along with\n   * this component. For each component listed here,\n   * Angular creates a {@link ComponentFactory} and stores it in the\n   * {@link ComponentFactoryResolver}.\n   * @deprecated Since 9.0.0. With Ivy, this property is no longer necessary.\n   */\n  entryComponents?: Array<Type<any>|any[]>;\n\n  /**\n   * True to preserve or false to remove potentially superfluous whitespace characters\n   * from the compiled template. Whitespace characters are those matching the `\\s`\n   * character class in JavaScript regular expressions. Default is false, unless\n   * overridden in compiler options.\n   */\n  preserveWhitespaces?: boolean;\n\n  /**\n   * Angular components marked as `standalone` do not need to be declared in an NgModule. Such\n   * components directly manage their own template dependencies (components, directives, and pipes\n   * used in a template) via the imports property.\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  standalone?: boolean;\n\n  /**\n   * The imports property specifies the standalone component's template dependencies — those\n   * directives, components, and pipes that can be used within its template. Standalone components\n   * can import other standalone components, directives, and pipes as well as existing NgModules.\n   *\n   * This property is only available for standalone components - specifying it for components\n   * declared in an NgModule generates a compilation error.\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  imports?: (Type<any>|ReadonlyArray<any>)[];\n\n  /**\n   * The set of schemas that declare elements to be allowed in a standalone component. Elements and\n   * properties that are neither Angular components nor directives must be declared in a schema.\n   *\n   * This property is only available for standalone components - specifying it for components\n   * declared in an NgModule generates a compilation error.\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  schemas?: SchemaMetadata[];\n}\n\n/**\n * Component decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Component: ComponentDecorator = makeDecorator(\n    'Component', (c: Component = {}) => ({changeDetection: ChangeDetectionStrategy.Default, ...c}),\n    Directive, undefined, (type: Type<any>, meta: Component) => compileComponent(type, meta));\n\n/**\n * Type of the Pipe decorator / constructor function.\n *\n * @publicApi\n */\nexport interface PipeDecorator {\n  /**\n   *\n   * Decorator that marks a class as pipe and supplies configuration metadata.\n   *\n   * A pipe class must implement the `PipeTransform` interface.\n   * For example, if the name is \"myPipe\", use a template binding expression\n   * such as the following:\n   *\n   * ```\n   * {{ exp | myPipe }}\n   * ```\n   *\n   * The result of the expression is passed to the pipe's `transform()` method.\n   *\n   * A pipe must belong to an NgModule in order for it to be available\n   * to a template. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `NgModule` metadata.\n   *\n   * @see [Style Guide: Pipe Names](guide/styleguide#02-09)\n   *\n   */\n  (obj: Pipe): TypeDecorator;\n\n  /**\n   * See the `Pipe` decorator.\n   */\n  new(obj: Pipe): Pipe;\n}\n\n/**\n * Type of the Pipe metadata.\n *\n * @publicApi\n */\nexport interface Pipe {\n  /**\n   * The pipe name to use in template bindings.\n   * Typically uses [lowerCamelCase](guide/glossary#case-types)\n   * because the name cannot contain hyphens.\n   */\n  name: string;\n\n  /**\n   * When true, the pipe is pure, meaning that the\n   * `transform()` method is invoked only when its input arguments\n   * change. Pipes are pure by default.\n   *\n   * If the pipe has internal state (that is, the result\n   * depends on state other than its arguments), set `pure` to false.\n   * In this case, the pipe is invoked on each change-detection cycle,\n   * even if the arguments have not changed.\n   */\n  pure?: boolean;\n\n  /**\n   * Angular pipes marked as `standalone` do not need to be declared in an NgModule. Such\n   * pipes don't depend on any \"intermediate context\" of an NgModule (ex. configured providers).\n   *\n   * More information about standalone components, directives, and pipes can be found in [this\n   * guide](guide/standalone-components).\n   */\n  standalone?: boolean;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Pipe: PipeDecorator = makeDecorator(\n    'Pipe', (p: Pipe) => ({pure: true, ...p}), undefined, undefined,\n    (type: Type<any>, meta: Pipe) => compilePipe(type, meta));\n\n\n/**\n * @publicApi\n */\nexport interface InputDecorator {\n  /**\n   * Decorator that marks a class field as an input property and supplies configuration metadata.\n   * The input property is bound to a DOM property in the template. During change detection,\n   * Angular automatically updates the data property with the DOM property's value.\n   *\n   * @usageNotes\n   *\n   * You can supply an optional name to use in templates when the\n   * component is instantiated, that maps to the\n   * name of the bound property. By default, the original\n   * name of the bound property is used for input binding.\n   *\n   * The following example creates a component with two input properties,\n   * one of which is given a special binding name.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   // This property is bound using its original name.\n   *   @Input() bankName: string;\n   *   // this property value is bound to a different property name\n   *   // when this component is instantiated in a template.\n   *   @Input('account-id') id: string;\n   *\n   *   // this property is not bound, and is not automatically updated by Angular\n   *   normalizedBankName: string;\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `\n   *     <bank-account bankName=\"RBC\" account-id=\"4747\"></bank-account>\n   *   `\n   * })\n   * class App {}\n   * ```\n   *\n   * @see [Input and Output properties](guide/inputs-outputs)\n   */\n  (bindingPropertyName?: string): any;\n  new(bindingPropertyName?: string): any;\n}\n\n/**\n * Type of metadata for an `Input` property.\n *\n * @publicApi\n */\nexport interface Input {\n  /**\n   * The name of the DOM property to which the input property is bound.\n   */\n  bindingPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Input: InputDecorator =\n    makePropDecorator('Input', (bindingPropertyName?: string) => ({bindingPropertyName}));\n\n/**\n * Type of the Output decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OutputDecorator {\n  /**\n   * Decorator that marks a class field as an output property and supplies configuration metadata.\n   * The DOM property bound to the output property is automatically updated during change detection.\n   *\n   * @usageNotes\n   *\n   * You can supply an optional name to use in templates when the\n   * component is instantiated, that maps to the\n   * name of the bound property. By default, the original\n   * name of the bound property is used for output binding.\n   *\n   * See `Input` decorator for an example of providing a binding name.\n   *\n   * @see [Input and Output properties](guide/inputs-outputs)\n   *\n   */\n  (bindingPropertyName?: string): any;\n  new(bindingPropertyName?: string): any;\n}\n\n/**\n * Type of the Output metadata.\n *\n * @publicApi\n */\nexport interface Output {\n  /**\n   * The name of the DOM property to which the output property is bound.\n   */\n  bindingPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const Output: OutputDecorator =\n    makePropDecorator('Output', (bindingPropertyName?: string) => ({bindingPropertyName}));\n\n\n\n/**\n * Type of the HostBinding decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostBindingDecorator {\n  /**\n   * Decorator that marks a DOM property as a host-binding property and supplies configuration\n   * metadata.\n   * Angular automatically checks host property bindings during change detection, and\n   * if a binding changes it updates the host element of the directive.\n   *\n   * @usageNotes\n   *\n   * The following example creates a directive that sets the `valid` and `invalid`\n   * properties on the DOM element that has an `ngModel` directive on it.\n   *\n   * ```typescript\n   * @Directive({selector: '[ngModel]'})\n   * class NgModelStatus {\n   *   constructor(public control: NgModel) {}\n   *   @HostBinding('class.valid') get valid() { return this.control.valid; }\n   *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `<input [(ngModel)]=\"prop\">`,\n   * })\n   * class App {\n   *   prop;\n   * }\n   * ```\n   *\n   */\n  (hostPropertyName?: string): any;\n  new(hostPropertyName?: string): any;\n}\n\n/**\n * Type of the HostBinding metadata.\n *\n * @publicApi\n */\nexport interface HostBinding {\n  /**\n   * The DOM property that is bound to a data property.\n   */\n  hostPropertyName?: string;\n}\n\n/**\n * @Annotation\n * @publicApi\n */\nexport const HostBinding: HostBindingDecorator =\n    makePropDecorator('HostBinding', (hostPropertyName?: string) => ({hostPropertyName}));\n\n\n/**\n * Type of the HostListener decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostListenerDecorator {\n  /**\n   * Decorator that declares a DOM event to listen for,\n   * and provides a handler method to run when that event occurs.\n   *\n   * Angular invokes the supplied handler method when the host element emits the specified event,\n   * and updates the bound element with the result.\n   *\n   * If the handler method returns false, applies `preventDefault` on the bound element.\n   */\n  (eventName: string, args?: string[]): any;\n  new(eventName: string, args?: string[]): any;\n}\n\n/**\n * Type of the HostListener metadata.\n *\n * @publicApi\n */\nexport interface HostListener {\n  /**\n   * The DOM event to listen for.\n   */\n  eventName?: string;\n  /**\n   * A set of arguments to pass to the handler method when the event occurs.\n   */\n  args?: string[];\n}\n\n/**\n * Decorator that binds a DOM event to a host listener and supplies configuration metadata.\n * Angular invokes the supplied handler method when the host element emits the specified event,\n * and updates the bound element with the result.\n *\n * If the handler method returns false, applies `preventDefault` on the bound element.\n *\n * @usageNotes\n *\n * The following example declares a directive\n * that attaches a click listener to a button and counts clicks.\n *\n * ```ts\n * @Directive({selector: 'button[counting]'})\n * class CountClicks {\n *   numberOfClicks = 0;\n *\n *   @HostListener('click', ['$event.target'])\n *   onClick(btn) {\n *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\n *   }\n * }\n *\n * @Component({\n *   selector: 'app',\n *   template: '<button counting>Increment</button>',\n * })\n * class App {}\n *\n * ```\n *\n * The following example registers another DOM event handler that listens for `Enter` key-press\n * events on the global `window`.\n * ``` ts\n * import { HostListener, Component } from \"@angular/core\";\n *\n * @Component({\n *   selector: 'app',\n *   template: `<h1>Hello, you have pressed enter {{counter}} number of times!</h1> Press enter key\n * to increment the counter.\n *   <button (click)=\"resetCounter()\">Reset Counter</button>`\n * })\n * class AppComponent {\n *   counter = 0;\n *   @HostListener('window:keydown.enter', ['$event'])\n *   handleKeyDown(event: KeyboardEvent) {\n *     this.counter++;\n *   }\n *   resetCounter() {\n *     this.counter = 0;\n *   }\n * }\n * ```\n * The list of valid key names for `keydown` and `keyup` events\n * can be found here:\n * https://www.w3.org/TR/DOM-Level-3-Events-key/#named-key-attribute-values\n *\n * Note that keys can also be combined, e.g. `@HostListener('keydown.shift.a')`.\n *\n * The global target names that can be used to prefix an event name are\n * `document:`, `window:` and `body:`.\n *\n * @Annotation\n * @publicApi\n */\nexport const HostListener: HostListenerDecorator =\n    makePropDecorator('HostListener', (eventName?: string, args?: string[]) => ({eventName, args}));\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {keyValueArraySet} from '../../util/array_utils';\nimport {getLView} from '../state';\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {checkStylingMap, classStringParser} from './styling';\n\n\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate1(prefix: string, v0: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): void {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nexport function ɵɵclassMapInterpolateV(values: any[]): void {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {RENDERER} from '../interfaces/view';\nimport {getBindingIndex, getLView, getSelectedTNode, getTView} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {elementPropertyInternal, storePropertyBindingMetadata} from './shared';\n\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate(\n    propName: string, v0: any, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate {\n  ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer);\n  return ɵɵpropertyInterpolate;\n}\n\n\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate1(\n    propName: string, prefix: string, v0: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate1 {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return ɵɵpropertyInterpolate1;\n}\n\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate2(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate2 {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return ɵɵpropertyInterpolate2;\n}\n\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate3(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate3 {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n  return ɵɵpropertyInterpolate3;\n}\n\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate4(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate4 {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n  return ɵɵpropertyInterpolate4;\n}\n\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate5(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate5 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n  return ɵɵpropertyInterpolate5;\n}\n\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate6(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate6 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n  return ɵɵpropertyInterpolate6;\n}\n\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate7(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string,\n    sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate7 {\n  const lView = getLView();\n  const interpolatedValue =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5,\n            suffix);\n  }\n  return ɵɵpropertyInterpolate7;\n}\n\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolate8(\n    propName: string, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string, sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolate8 {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode &&\n        storePropertyBindingMetadata(\n            tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6,\n            suffix);\n  }\n  return ɵɵpropertyInterpolate8;\n}\n\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings in between those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵpropertyInterpolateV(\n    propName: string, values: any[], sanitizer?: SanitizerFn): typeof ɵɵpropertyInterpolateV {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];  // prefix\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(\n          tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1,\n          ...interpolationInBetween);\n    }\n  }\n  return ɵɵpropertyInterpolateV;\n}\n"],"names":["ES5_DELEGATE_CTOR","ES2015_INHERITED_CLASS","ES2015_INHERITED_CLASS_WITH_CTOR","ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR","ReflectionCapabilities","constructor","reflect","this","_reflect","global","factory","t","args","_zipTypesAndAnnotations","paramTypes","paramAnnotations","result","newArray","length","i","Object","concat","_ownParameters","type","parentCtor","typeStr","toString","test","parameters","tsickleCtorParams","ctorParameters","map","ctorParam","convertTsickleDecoratorIntoMetadata","decorators","hasOwnProperty","PARAMETERS","getOwnMetadata","isType","getParentCtor","_ownAnnotations","typeOrFunc","annotations","ANNOTATIONS","ownAnnotations","_ownPropMetadata","propMetadata","propDecorators","keys","forEach","prop","PROP_METADATA","parentPropMetadata","propName","ownPropMetadata","push","hasLifecycleHook","lcProperty","Type","prototype","decoratorInvocations","decoratorInvocation","annotationCls","ctor","parentProto","getPrototypeOf","Attribute","makeParamDecorator","attributeName","__NG_ELEMENT_ID__","ɵɵinjectAttribute","getReflect","reflectDependencies","dep","meta","token","attribute","host","optional","self","skipSelf","Array","isArray","j","param","undefined","proto","Optional","ngMetadataName","SkipSelf","Self","Host","Inject","RuntimeError","ngDevMode","reflectDependency","modules","Map","findHostDirectiveDefs","currentDef","matchedDefs","hostDirectiveDefs","hostDirectives","hostDirectiveConfig","hostDirectiveDef","getDirectiveDef","directive","patchDeclaredInputs","declaredInputs","inputs","set","bindingArrayToMap","bindings","EMPTY_OBJ","exposedInputs","publicName","remappedPublicName","privateName","COPY_DIRECTIVE_FIELDS","COPY_COMPONENT_FIELDS","ELEMENT_MARKER","marker","ICU_MARKER","I18nCreateOpCode","getInsertInFrontOfRNodeWithI18n","parentTNode","currentTNode","lView","tNodeInsertBeforeIndex","insertBeforeIndex","getInsertInFrontOfRNodeWithNoI18n","unwrapRNode","processI18nInsertBefore","renderer","childTNode","childRNode","parentRElement","i18nParent","anchorRNode","componentOffset","i18nChild","nativeInsertBefore","addTNodeAndUpdateInsertBeforeIndex","previousTNodes","newTNode","existingTNode","isI18nText","isNewTNodeCreatedBefore","getInsertBeforeIndex","setInsertBeforeIndex","index","tNode","value","setI18nHandling","getTIcu","tView","data","createTNodePlaceholder","createTNodeAtIndex","getCurrentICUCaseIndex","tIcu","currentCase","currentCaseLViewIndex","changeMask","changeMaskCounter","applyMutableOpCodes","mutableOpCodes","RENDERER","rootRNode","rootIdx","opCode","textNodeIndex","createTextNode","parentIdx","insertInFrontOf","parentRNode","nativeParentNode","refIdx","child","caseIndex","create","anchorIdx","elementNodeIndex","attrName","attrValue","setElementAttribute","getNativeByIndex","commentValue","commentNodeIndex","commentRNode","createCommentNode","attachPatchData","tagName","elementRNode","createElementNode","applyUpdateOpCodes","updateOpCodes","bindingsStartIndex","checkBit","skipCodes","renderStringify","nodeIndex","sanitizeFn","tNodeOrTagName","elementPropertyInternal","rText","updateTextNode","applyIcuSwitchCase","applyIcuUpdateCase","activeCaseIndex","mask","update","icuExpression","bindingValue","cases","indexOf","resolvedCase","getPluralCase","getLocaleId","getCaseIndex","applyIcuSwitchCaseRemove","removeCodes","remove","nodeOrIcuIndex","rNode","nativeRemoveNode","loadIcuContainerVisitor","_stack","_lView","_removes","_index","enterIcu","EMPTY_ARRAY","icuContainerIteratorNext","removeOpCode","tIcuIndex","TVIEW","pop","tIcuContainerNode","BINDING_REGEXP","ICU_REGEXP","NESTED_ICU","ICU_BLOCK_REGEXP","MARKER","SUBTEMPLATE_REGEXP","PH_REGEXP","NGSP_UNICODE_REGEXP","createTNodeAndAddOpCode","rootTNode","existingTNodes","createOpCodes","text","isICU","i18nNodeIdx","allocExpando","SHIFT","getCurrentParentTNode","APPEND_EAGERLY","COMMENT","ensureIcuContainerVisitorLoaded","tNodeIdx","setCurrentTNode","assertEqual","setTNodeInsertBeforeIndex","i18nStartFirstCreatePassProcessTextNode","hasBinding","match","generateBindingUpdateOpCodes","str","destinationNode","bindingStart","maskIndex","sizeIndex","startIndex","textParts","split","textValue","bindingIndex","parseInt","toMaskBit","countBindings","opCodes","count","Math","min","removeInnerTemplateTranslation","message","tagMatched","res","inTemplate","exec","substring","slice","icuStart","bindingMask","mainBinding","addUpdateIcuSwitch","setTIcu","values","valueArr","nestedIcus","icuIndex","parseIcuCase","join","addUpdateIcuUpdate","parseICUBlock","pattern","icuType","parts","i18nParseTextIntoPartsAndICU","replace","binding","pos","key","trim","blocks","prevPos","braceStack","results","braces","lastIndex","block","caseName","unsafeCaseHtml","inertBodyElement","getInertBodyHelper","getDocument","getInertBodyElement","inertRootNode","getTemplateContent","walkIcuTree","sharedUpdateOpCodes","parentNode","depth","currentNode","firstChild","newIndex","nodeType","Node","ELEMENT_NODE","element","toLowerCase","VALID_ELEMENTS","addCreateNodeAndAppend","elAttrs","attributes","attr","item","lowerAttrName","name","VALID_ATTRS","URI_ATTRS","_sanitizeUrl","addCreateAttribute","addRemoveNode","TEXT_NODE","textContent","COMMENT_NODE","isNestedIcu","addRemoveNestedIcu","nextSibling","appendToParentIdx","createAtIdx","PP_MULTI_VALUE_PLACEHOLDERS_REGEXP","PP_PLACEHOLDERS_REGEXP","PP_ICU_VARS_REGEXP","PP_ICU_PLACEHOLDERS_REGEXP","PP_ICUS_REGEXP","PP_CLOSE_TEMPLATE_REGEXP","PP_TEMPLATE_ID_REGEXP","ɵɵi18nStart","messageIndex","subTemplateIndex","getTView","getLView","adjustedIndex","HEADER_OFFSET","getConstant","consts","firstCreatePass","parentTNodeIndex","existingTNodeStack","isRootTemplateMessage","start","end","search","RegExp","getTranslationForTemplate","msgParts","part","Error","isClosing","charCodeAt","Number","shift","unshift","i18nStartFirstCreatePass","tI18n","sameViewParentTNode","T_HOST","getClosestRElement","isComment","appendNow","createComment","applyCreateOpCodes","setInI18nBlock","ɵɵi18nEnd","angularCoreEnv","r3","ɵɵattributeInterpolate1","prefix","v0","suffix","sanitizer","namespace","interpolatedValue","interpolation1","NO_CHANGE","getSelectedTNode","elementAttributeInternal","ɵɵattributeInterpolate2","i0","v1","interpolation2","ɵɵattributeInterpolate3","i1","v2","interpolation3","ɵɵattributeInterpolate4","i2","v3","interpolation4","ɵɵattributeInterpolate5","i3","v4","interpolation5","ɵɵattributeInterpolate6","i4","v5","interpolation6","ɵɵattributeInterpolate7","i5","v6","interpolation7","ɵɵattributeInterpolate8","i6","v7","interpolation8","ɵɵattributeInterpolateV","interpolated","interpolationV","ɵɵdefineInjectable","ɵɵdefineInjector","ɵɵinject","ɵɵinvalidFactoryDep","rawHostDirectives","definition","dir","resolveForwardRef","outputs","superDef","superType","getSuperType","isComponentDef","ɵcmp","ɵdir","defAny","field","ɵɵstyleMap","ɵɵstylePropInterpolate1","valueSuffix","checkStylingProperty","ɵɵstylePropInterpolate2","ɵɵstylePropInterpolate3","ɵɵstylePropInterpolate4","ɵɵstylePropInterpolate5","ɵɵstylePropInterpolate6","ɵɵstylePropInterpolate7","ɵɵstylePropInterpolate8","ɵɵstylePropInterpolateV","attrsIndex","attrs","previousElementIndex","getCurrentTNode","i18nAttributesFirstPass","ɵɵi18nExp","bindingUpdated","nextBindingIndex","getBindingIndex","applyI18n","replacements","matches","templateIdsStack","m","phs","tmpl","content","placeholders","placeholder","templateId","isCloseTemplateTag","currentTemplateId","idx","splice","_type","_idx","list","i18nPostprocess","ngModuleType","id","incoming","stringify","assertSameOrNotExisting","get","sanitization","getNativeByTNode","iframe","src","srcdoc","trustedHTMLFromString","errorMessage","forwardRef","isNgModule","getNgModuleDef","moduleQueue","flushingModuleQueue","isResolvedDeclaration","declaration","every","setScopeOnDeclaredComponents","moduleType","ngModule","declarations","flatten","transitiveScopes","transitiveScopesFor","NG_COMP_DEF","component","patchComponentDefWithScope","getComponentDef","NG_DIR_DEF","NG_PIPE_DEF","ngSelectorScope","componentDef","directiveDefs","from","compilation","directives","filter","def","pipeDefs","pipes","pipe","getPipeDef","schemas","transitiveCompileScopes","scopes","Set","exported","maybeUnwrapFn","imports","imported","importedScope","entry","add","declared","declaredWithDefs","exports","exportedType","exportedScope","transitiveScopesForNgModule","isStandalone","WeakMap","compilationDepth","compileDirective","ngDirectiveDef","addDirectiveFactoryDef","defineProperty","getDirectiveMetadata","compiler","getCompilerFacade","usage","kind","sourceMapUrl","metadata","configurable","facade","directiveMetadata","typeSourceSpan","createParseSourceSpan","usesInheritance","addDirectiveDefToUndecoratedParents","ngFactoryDef","NG_FACTORY_DEF","compileFactory","typeArgumentCount","deps","target","FactoryTarget","Directive","extendsDirectlyFromObject","selector","queries","extractQueriesMetadata","isContentQuery","lifecycle","usesOnChanges","exportAs","splitByComma","providers","viewQueries","isViewQuery","standalone","objPrototype","parent","shouldAddAbstractDirective","convertToR3QueryMetadata","propertyName","ann","predicate","descendants","first","read","static","emitDistinctChangesOnly","isQueryAnn","queriesMeta","stringifyForError","some","isInputAnnotation","piece","LIFECYCLE_HOOKS","hookName","current","metadataName","getPipeMetadata","pipeName","pure","makeDecorator","Input","c","changeDetection","ChangeDetectionStrategy","ngComponentDef","maybeQueueResolutionOfComponentResources","componentNeedsResolution","error","templateUrl","styleUrls","JSON","options","getJitOptions","preserveWhitespaces","encapsulation","defaultEncapsulation","ViewEncapsulation","template","styles","animations","interpolation","viewProviders","compileComponent","cachedDirectiveDefs","cachedPipeDefs","seen","rawDep","has","scope","getStandaloneDefFunctions","dependencies","flushModuleScopingQueueAsMuchAsPossible","p","ngPipeDef","Pipe","compilePipe","makePropDecorator","bindingPropertyName","hostPropertyName","eventName","ɵɵclassMapInterpolate1","checkStylingMap","keyValueArraySet","classStringParser","ɵɵclassMapInterpolate2","ɵɵclassMapInterpolate3","ɵɵclassMapInterpolate4","ɵɵclassMapInterpolate5","ɵɵclassMapInterpolate6","ɵɵclassMapInterpolate7","ɵɵclassMapInterpolate8","ɵɵclassMapInterpolateV","ɵɵpropertyInterpolate","ɵɵpropertyInterpolate1","ɵɵpropertyInterpolate2","ɵɵpropertyInterpolate3","ɵɵpropertyInterpolate4","ɵɵpropertyInterpolate5","ɵɵpropertyInterpolate6","ɵɵpropertyInterpolate7","ɵɵpropertyInterpolate8","ɵɵpropertyInterpolateV"],"sourceRoot":""}